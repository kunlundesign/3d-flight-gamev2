<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Warriors - GLB Flight Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .loading-text {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar {
            width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        #glbUpload {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 14px;
        }

        #fileInput {
            margin-top: 10px;
            padding: 8px;
            border: 2px dashed #4CAF50;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
        }

        #fileInput:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 12px;
            max-width: 300px;
        }

        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            color: white;
            font-size: 16px;
            display: none;
            text-align: center;
        }

        .notification-success {
            border-left: 4px solid #4CAF50;
        }

        .notification-error {
            border-left: 4px solid #f44336;
        }

        /* 场景切换面板 */
        #sceneSwitcher {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1200;
            background: rgba(0,0,0,0.65);
            padding: 10px 12px;
            border-radius: 10px;
            display: flex;
            gap: 6px;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 8px rgba(0,0,0,0.4);
        }
        #sceneSwitcher button {
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            color: #fff;
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 6px;
            letter-spacing: 1px;
            transition: background .25s, transform .15s, border-color .25s;
        }
        #sceneSwitcher button:hover { background: rgba(255,255,255,0.18); }
        #sceneSwitcher button:active { transform: scale(.9); }
        #sceneSwitcher button.active { background: linear-gradient(135deg,#3fa9ff,#1e62d0); border-color:#6fc3ff; }

        /* ===== Scoreboard & Name Prompt ===== */
        #scoreboardPanel {
            position: fixed; top: 10px; right: 10px; z-index: 1000;
            background: rgba(0,0,0,0.55); backdrop-filter: blur(6px);
            padding: 10px 14px; border:1px solid rgba(255,255,255,0.15); border-radius:10px; color:#fff;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen;
            width: 240px; max-height: 420px; overflow:auto; box-shadow:0 4px 14px rgba(0,0,0,0.4);
        }
        #scoreboardPanel h3 { margin:0 0 6px; font-size:15px; letter-spacing:0.5px; display:flex; align-items:center; justify-content:space-between; }
        #scoreboardPanel table { width:100%; border-collapse: collapse; font-size:12px; }
        #scoreboardPanel th, #scoreboardPanel td { text-align:left; padding:2px 4px; }
        #scoreboardPanel th { position: sticky; top:0; background: rgba(255,255,255,0.12); backdrop-filter: blur(2px); }
        #scoreboardPanel tr.highlight { background: rgba(255,255,255,0.15); }
        #scoreboardPanel .exportBtn { margin-top:6px; width:100%; background:#2d6be8; border:none; color:#fff; padding:6px 0; border-radius:6px; cursor:pointer; font-size:12px; }
        #scoreboardPanel .exportBtn:hover { background:#4782f5; }
        #playerNameDisplay { font-size:12px; margin-top:4px; color:#8fd1ff; }
        #namePromptOverlay { position:fixed; inset:0; background:rgba(0,0,0,0.72); display:flex; align-items:center; justify-content:center; z-index:2000; }
        #namePromptBox { background:#12161c; padding:26px 32px 32px; border-radius:14px; border:1px solid #2c343d; width:340px; color:#f0f4f8; box-shadow:0 10px 40px -8px rgba(0,0,0,0.7); font-family: system-ui; }
        #namePromptBox h2 { margin:0 0 14px; font-size:18px; letter-spacing:0.5px; }
        #namePromptBox input { width:100%; padding:10px 12px; background:#1d242c; border:1px solid #3a4652; border-radius:8px; color:#fff; font-size:14px; outline:none; }
        #namePromptBox input:focus { border-color:#5d9dff; box-shadow:0 0 0 2px rgba(93,157,255,0.25); }
        #namePromptBox button { margin-top:16px; width:100%; background:linear-gradient(135deg,#3498ff,#006bff); color:#fff; border:none; padding:11px 0; border-radius:9px; font-size:14px; cursor:pointer; font-weight:600; letter-spacing:0.5px; }
        #namePromptBox button:hover { filter:brightness(1.1); }
        #namePromptBox .note { font-size:12px; opacity:0.7; margin-top:10px; line-height:1.5; }
        /* Session real-time stats HUD */
        #hudStats {
            position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.45); padding:6px 14px; border:1px solid rgba(255,255,255,0.18);
            border-radius: 14px; color:#fff; font-size:13px; font-family: system-ui, Arial;
            letter-spacing: .5px; display:flex; gap:16px; align-items:center; z-index:1300;
            backdrop-filter: blur(4px);
        }
        #hudStats span.label { opacity:0.7; margin-right:4px; font-size:11px; text-transform:uppercase; }
        #hudStats .value { font-weight:600; color:#ffd560; }
        #hudStats .total { color:#7dff91; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hudStats" style="display:none;">
            <div><span class="label">Tanks</span><span id="hudTankKills" class="value">0</span></div>
            <div><span class="label">Ships</span><span id="hudShipKills" class="value">0</span></div>
            <div><span class="label">Total</span><span id="hudTotalKills" class="value total">0</span></div>
        </div>
        <div id="loadingScreen">
            <div class="loading-text">SKY WARRIORS</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p style="margin-top: 20px; opacity: 0.8;">Loading 3D Environment...</p>
        </div>

        <div id="glbUpload">
            <h3>Load Your Aircraft</h3>
            <p>Drop a GLB file here or click to browse:</p>
            <input type="file" id="fileInput" accept=".glb,.gltf" />
        </div>

        <div id="instructions">
            <h4>Flight Controls:</h4>
            <p><strong>WASD / Arrow Keys:</strong> Pitch (W/S) and Yaw (A/D) controls</p>
            <p><strong>Q / E:</strong> Roll left/right (360° barrel rolls available!)</p>
            <p><strong>Shift / Space:</strong> Increase throttle</p>
            <p><strong>Ctrl / X:</strong> Decrease throttle</p>
            <p><strong>R:</strong> Toggle weather (Rain/Sunny)</p>
        </div>

        <div id="notification"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        class SkyWarriors {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.aircraft = null;
                this.loadedModel = null;
                
                // Player state
                this.playerPosition = new THREE.Vector3(0, 50, 0);
                this.playerVelocity = new THREE.Vector3(0, 0, 0);
                this.playerSpeed = 60; // Current speed in units/sec
                
                // Flight control state
                this.inputState = {
                    pitch: 0,    // Nose up/down rotation (-π/4 to π/4)
                    yaw: 0,      // Left/right turn rotation  
                    roll: 0,     // Banking rotation
                    speed: 0.6,  // Speed multiplier (0.2 to 1.0)
                    keys: new Set() // Currently pressed keys
                };

                // World wrapping system
                this.lastWrapMessageTime = 0;
                
                // === GLB动画系统 ===
                this.modelAnimationMixer = null;      // 动画混合器
                this.modelAnimations = [];            // 动画片段数组
                this.activeAnimations = [];           // 当前播放的动画
                this.animationClock = new THREE.Clock(); // 动画时钟
                
                // Terrain and environment
                this.terrain = [];
                this.clouds = [];
                // === Environment configuration ===
                // === Scene variant system ===
                // Supported: 'default' | 'snow' | 'desert' | 'ocean'
                this.sceneType = 'default';
                // Try read hash (#snow / #desert / #ocean) for quick switching
                const hash = window.location.hash.replace('#','').toLowerCase();
                if(['snow','desert','ocean','default'].includes(hash)) this.sceneType = hash || 'default';
                this.environmentConfig = this.getEnvironmentConfig(this.sceneType);
                // === Combat targets ===
                this.tanks = []; // 静态坦克目标 { mesh, alive, radius }
                this.warships = []; // 海上战舰 { mesh, alive, radius }
                // Raycaster for ground height sampling
                this.raycaster = new THREE.Raycaster();
                // --- Weapon system state (nose cannons) ---
                this.isFiring = false;          // 是否按住射击
                this.lastShotTime = 0;          // 上次发射时间 (s)
                this.fireInterval = 0.08;       // 射速间隔 ~12.5发/秒
                this.bullets = [];              // 活跃子弹
                this.muzzleFlashes = [];        // 枪口火光
                this.gunBarrels = [];           // 炮口引用
                this.tempVec = new THREE.Vector3();
                this.forwardVec = new THREE.Vector3(0,0,1);
                // === Scoreboard & player identity ===
                this.playerName = null;
                this.scoreData = { players: {} }; // { name: { tank:0, ship:0, total:0, last:timestamp } }
                this.localStorageKey = 'skywarriors_scores_v1';
                // Session real-time counters (not persisted across reload)
                this.sessionKills = { tank:0, ship:0 };
                this.ensurePlayerName();
                this.loadScores();
                this.registerPlayerIfNeeded();
                this.updateScoreboardUI();
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupLighting();
                this.createTerrain();
                this.createClouds();
                this.createDefaultAircraft();
                this.createNoseCannons(); // 机头机炮
                this.setupFileUpload();
                this.setupKeyboardControls();
                this.setupMouseControls(); // 鼠标射击
                this.setupSceneSwitcher(); // 场景切换UI
                this.hideLoadingScreen();
                this.gameLoop();
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                // Fog / background by scene type
                const fogColors = {
                    default: 0x87CEEB,
                    snow: 0xdbe9f5,
                    desert: 0xe2c27b,
                    ocean: 0x6fb2ff
                };
                const fogColor = fogColors[this.sceneType] || 0x87CEEB;
                this.scene.fog = new THREE.Fog(fogColor, 100, 2000);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.camera.position.set(0, 100, 200);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(fogColor, 1);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupLighting() {
                // === 自然环境光 - 模拟晴天柔和光照 ===
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // 降低到0.6，自然柔和
                this.scene.add(ambientLight);
                
                // === 自然太阳光 - 模拟真实晴天阳光 ===
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // 降低到1.0，自然强度
                directionalLight.position.set(100, 300, 100); // 保持自然角度
                directionalLight.castShadow = true;
                
                // 优化阴影质量
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 2000;
                directionalLight.shadow.camera.left = -1000;
                directionalLight.shadow.camera.right = 1000;
                directionalLight.shadow.camera.top = 1000;
                directionalLight.shadow.camera.bottom = -1000;
                directionalLight.shadow.bias = -0.0001;
                this.scene.add(directionalLight);
                
                // === 自然天空光 - 模拟天空散射光 ===
                const skyLight = new THREE.HemisphereLight(
                    0x87CEEB,  // 天空蓝色
                    0x5D8A3A,  // 地面绿色
                    0.4        // 降低到0.4，柔和天空光
                );
                skyLight.position.set(0, 500, 0);
                this.scene.add(skyLight);
                
                // === 移除过强的飞机专用聚光灯 ===
                // 不再添加专用聚光灯，使用自然光照
                
                // === 轻微补光系统 - 仅用于消除过暗阴影 ===
                const fillLights = [
                    { pos: [200, 100, 0], intensity: 0.2 },    // 右侧轻微补光
                    { pos: [-200, 100, 0], intensity: 0.2 },   // 左侧轻微补光
                    { pos: [0, 100, 200], intensity: 0.15 },   // 前方轻微补光
                    { pos: [0, 100, -200], intensity: 0.15 }   // 后方轻微补光
                ];
                
                fillLights.forEach(light => {
                    const fillLight = new THREE.DirectionalLight(0xffffff, light.intensity);
                    fillLight.position.set(light.pos[0], light.pos[1], light.pos[2]);
                    fillLight.castShadow = false; // 补光不产生阴影
                    this.scene.add(fillLight);
                });
                
                // === 移除GLB专用增强光 ===
                // 不再添加专用增强光，使用自然光照
            }

            createTerrain() {
                // Ground plane base
                const groundGeometry = new THREE.PlaneGeometry(8000, 8000, 150, 150);
                let groundColor = 0x5D8A3A; // default grass
                if (this.sceneType === 'snow') groundColor = 0xF2F6F9;
                else if (this.sceneType === 'desert') groundColor = 0xD9C190;
                else if (this.sceneType === 'ocean') groundColor = 0x1b4f8a; // seabed (deep)
                const groundMaterial = new THREE.MeshLambertMaterial({ color: groundColor, wireframe: false });
                
                // Add some height variation to the ground
                const vertices = groundGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.random() * 15 - 7; // 减少地面起伏，更平坦
                }
                groundGeometry.attributes.position.needsUpdate = true;
                groundGeometry.computeVertexNormals();
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -50;
                ground.receiveShadow = true;
                this.scene.add(ground);
                // 保存地面引用用于高度采样
                this.ground = ground;
                
                if (this.sceneType === 'snow') {
                    this.createSnowMountains();
                    this.createConiferForests();
                    // Frozen lakes (reuse lakes with pale blue)
                    this.createLakes(0xbdd9f2, true);
                } else if (this.sceneType === 'desert') {
                    this.createDesertDunes();
                    this.createPyramids();
                    this.createDesertPlants();
                } else if (this.sceneType === 'ocean') {
                    this.createOceanSurface();
                    this.createSmallIslands();
                    this.createWarships(6);
                } else {
                    // default
                    this.createMountainRanges();
                    this.createTrees();
                    this.createLakes();
                    this.createSoilPatches(this.environmentConfig.soilPatchCount);
                    if (this.environmentConfig.rockCount > 0) this.createRocks(this.environmentConfig.rockCount);
                    this.createGrassPatches(this.environmentConfig.grassPatchCount);
                    for (let i=0;i<this.environmentConfig.bushClusterCount;i++) {
                        this.createBushCluster((Math.random()-0.5)*6500,(Math.random()-0.5)*6500,6+Math.random()*8);
                    }
                    if (this.environmentConfig.birdFlocks > 0) {
                        for (let i=0;i<this.environmentConfig.birdFlocks;i++) this.createBirdFlock();
                    }
                }
                // Tanks only in non-ocean scene; warships already handled in ocean branch
                if (this.sceneType !== 'ocean') this.createTanks(30);
            }

            getEnvironmentConfig(type){
                switch(type){
                    case 'snow':
                        return { treeDensityMultiplier: 1.8, rockCount: 10, grassPatchCount: 40, bushClusterCount: 20, birdFlocks:0, soilPatchCount:20 };
                    case 'desert':
                        return { treeDensityMultiplier: 0.4, rockCount: 5, grassPatchCount: 0, bushClusterCount: 5, birdFlocks:0, soilPatchCount:10 };
                    case 'ocean':
                        return { treeDensityMultiplier: 0, rockCount: 0, grassPatchCount: 0, bushClusterCount: 0, birdFlocks:0, soilPatchCount:0 };
                    default:
                        return { treeDensityMultiplier: 2.8, rockCount: 0, grassPatchCount: 180, bushClusterCount: 70, birdFlocks:0, soilPatchCount:120 };
                }
            }

            // ===== Snow Scene Helpers =====
            createSnowMountains(){
                this.createMountainRange(-2500,-1500,7,'high',0xd8dfe6);
                this.createMountainRange(2600,2100,6,'high',0xcfd8de);
                for(let i=0;i<20;i++) this.createSingleMountain((Math.random()-0.5)*7000,(Math.random()-0.5)*7000,'random',0xe0e7ec);
            }
            createConiferForests(){
                for(let i=0;i<140;i++) this.createTree((Math.random()-0.5)*6500,(Math.random()-0.5)*6500,'pine');
            }

            // ===== Desert Scene Helpers =====
            createDesertDunes(){
                // gentle height noise already added; add some dune ridges as low hills
                for(let i=0;i<40;i++){
                    const geo = new THREE.ConeGeometry(120+Math.random()*180, 30+Math.random()*25, 12);
                    geo.scale(2.5,0.4,1.2);
                    const mat = new THREE.MeshLambertMaterial({ color: 0xE3D2A1 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set((Math.random()-0.5)*7000,-35,(Math.random()-0.5)*7000);
                    m.rotation.y = Math.random()*Math.PI;
                    m.castShadow = true; m.receiveShadow = true;
                    this.scene.add(m);
                }
            }
            createPyramids(){
                const pyramidMat = new THREE.MeshLambertMaterial({ color: 0xC9B065 });
                for(let i=0;i<5;i++){
                    const size = 200 + Math.random()*160;
                    const geo = new THREE.ConeGeometry(size/2, size/1.2, 4);
                    const p = new THREE.Mesh(geo, pyramidMat);
                    p.rotation.y = Math.PI/4;
                    p.position.set((Math.random()-0.5)*6000, -50 + size/2.4, (Math.random()-0.5)*6000);
                    p.castShadow = true; p.receiveShadow = true;
                    this.scene.add(p);
                }
            }
            createDesertPlants(){
                // Populus euphratica (胡杨) simplified tall trunk + sparse crown
                for(let i=0;i<60;i++){
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.7,18,6), new THREE.MeshLambertMaterial({ color:0x8b5a2b }));
                    const crown = new THREE.Mesh(new THREE.SphereGeometry(5,8,6), new THREE.MeshLambertMaterial({ color:0xd4c98a }));
                    crown.position.y = 10;
                    const g = new THREE.Group(); g.add(trunk); g.add(crown);
                    g.position.set((Math.random()-0.5)*7000,-50,(Math.random()-0.5)*7000);
                    this.scene.add(g);
                }
                // Cactus
                for(let i=0;i<120;i++){
                    const h = 6 + Math.random()*10;
                    const main = new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.9,h,6), new THREE.MeshLambertMaterial({ color:0x2f6f3b }));
                    const group = new THREE.Group(); group.add(main);
                    if(Math.random()>0.5){
                        const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5, h*0.5,6), main.material);
                        arm.position.y = h*0.4; arm.position.x = 0.9; arm.rotation.z = Math.PI/10;
                        group.add(arm);
                    }
                    group.position.set((Math.random()-0.5)*7000,-50,(Math.random()-0.5)*7000);
                    this.scene.add(group);
                }
                // Sea-buckthorn (沙棘) as low orange shrubs
                for(let i=0;i<160;i++){
                    const r = 1.5 + Math.random()*2.5;
                    const shrub = new THREE.Mesh(new THREE.SphereGeometry(r,8,6), new THREE.MeshLambertMaterial({ color:0xd9922e }));
                    shrub.position.set((Math.random()-0.5)*7200,-50 + r*0.4,(Math.random()-0.5)*7200);
                    shrub.castShadow = true; this.scene.add(shrub);
                }
            }

            // ===== Ocean Scene Helpers =====
            createOceanSurface(){
                // Add reflective water-like plane (simple material placeholder)
                const water = new THREE.Mesh(new THREE.PlaneGeometry(8000,8000,50,50), new THREE.MeshLambertMaterial({ color:0x2f7dd1, transparent:true, opacity:0.95 }));
                water.rotation.x = -Math.PI/2; water.position.y = -40; water.receiveShadow = true;
                this.scene.add(water);
            }
            createSmallIslands(){
                for(let i=0;i<18;i++){
                    const rad = 120 + Math.random()*140;
                    const geo = new THREE.CircleGeometry(rad, 24);
                    const mat = new THREE.MeshLambertMaterial({ color:0xc8c087 });
                    const isl = new THREE.Mesh(geo, mat);
                    isl.rotation.x = -Math.PI/2;
                    isl.position.set((Math.random()-0.5)*6000,-49.5,(Math.random()-0.5)*6000);
                    this.scene.add(isl);
                    // palm or pine few trees reused
                    for(let t=0;t<5;t++) this.createTree(isl.position.x + (Math.random()-0.5)*rad, isl.position.z + (Math.random()-0.5)*rad, 'palm');
                }
            }

            createMountainRanges() {
                // 1. 雄伟的高山脉
                this.createMountainRange(-3000, -2000, 8, 'high', 0x8b7355);
                this.createMountainRange(2500, 2200, 6, 'high', 0x696969);
                
                // 2. 中等山丘
                this.createMountainRange(-1500, 2800, 5, 'medium', 0xA0522D);
                this.createMountainRange(3200, -1200, 7, 'medium', 0x8b7355);
                
                // 3. 低矮丘陵
                this.createMountainRange(0, 3500, 4, 'low', 0x9ACD32);
                this.createMountainRange(-2800, 1000, 5, 'low', 0x228B22);
                
                // 4. 独立山峰
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 7000;
                    const z = (Math.random() - 0.5) * 7000;
                    this.createSingleMountain(x, z, 'random');
                }
            }

            createMountainRange(centerX, centerZ, count, type, color) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = 200 + Math.random() * 300;
                    const x = centerX + Math.cos(angle) * radius;
                    const z = centerZ + Math.sin(angle) * radius;
                    this.createSingleMountain(x, z, type, color);
                }
            }

            createSingleMountain(x, z, type, color) {
                let height, baseRadius, shape, mountainColor;
                switch(type) {
                    case 'high':
                        height = 120 + Math.random()*110;
                        baseRadius = 50 + Math.random()*40;
                        shape = Math.random()<0.2 ? 'ridge' : (Math.random()<0.4 ? 'mesa' : 'cone');
                        mountainColor = color || 0x7a6550; break;
                    case 'medium':
                        height = 70 + Math.random()*60;
                        baseRadius = 40 + Math.random()*30;
                        shape = Math.random()<0.3 ? 'pyramid' : (Math.random()<0.55 ? 'dome' : 'cone');
                        mountainColor = color || 0x9c6233; break;
                    case 'low':
                        height = 30 + Math.random()*45;
                        baseRadius = 32 + Math.random()*22;
                        shape = Math.random()<0.5 ? 'dome' : 'ridge';
                        mountainColor = color || 0x6fae3b; break;
                    default:
                        return this.createSingleMountain(x, z, ['high','medium','low'][Math.floor(Math.random()*3)]);
                }
                if (Math.random()<0.08) shape = 'crater';
                let mountainGeometry;
                switch(shape) {
                    case 'cone':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 10 + Math.floor(Math.random()*5)); break;
                    case 'pyramid':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 4); break;
                    case 'dome':
                        mountainGeometry = new THREE.SphereGeometry(baseRadius, 12, 8,0,Math.PI*2,0,Math.PI/2); mountainGeometry.scale(1,height/baseRadius,1); break;
                    case 'mesa': {
                        const base = new THREE.CylinderGeometry(baseRadius*0.8, baseRadius, height*0.65, 10);
                        const top = new THREE.CylinderGeometry(baseRadius*0.55, baseRadius*0.6, height*0.15, 10); top.translate(0,height*0.4,0);
                        mountainGeometry = BufferGeometryUtils ? BufferGeometryUtils.mergeGeometries([base, top]) : base; break;
                    }
                    case 'ridge':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 6); mountainGeometry.scale(1.8,1,0.6); break;
                    case 'crater':
                        mountainGeometry = new THREE.CylinderGeometry(baseRadius*1.3, baseRadius*1.4, height*0.5, 24,1,true); break;
                }
                const posAttr = mountainGeometry.attributes.position;
                for (let i=0;i<posAttr.count;i++) {
                    const vx = posAttr.getX(i), vy = posAttr.getY(i), vz = posAttr.getZ(i);
                    const noise = (Math.sin(vx*0.15)+Math.sin(vz*0.18))*0.6 + (Math.random()-0.5)*0.9;
                    posAttr.setY(i, vy + noise*2);
                    posAttr.setX(i, vx + (Math.random()-0.5)*0.8);
                    posAttr.setZ(i, vz + (Math.random()-0.5)*0.8);
                }
                posAttr.needsUpdate = true;
                mountainGeometry.computeVertexNormals();
                const hFactor = THREE.MathUtils.clamp((height-40)/140,0,1);
                const baseColor = new THREE.Color(mountainColor);
                const tint = new THREE.Color().setHSL(0.08 + 0.1*hFactor, 0.35, 0.25 + 0.25*hFactor);
                baseColor.lerp(tint,0.4);
                // === 对齐到地面防止悬浮 ===
                mountainGeometry.computeBoundingBox();
                const bbox = mountainGeometry.boundingBox;
                const GROUND_Y = -50;
                // 计算将几何底部贴到地面的中心 Y
                const placeY = GROUND_Y - bbox.min.y; // 使 (placeY + bbox.min.y) == GROUND_Y
                const mountainMaterial = new THREE.MeshLambertMaterial({ color: baseColor });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(x, placeY, z);
                mountain.rotation.y = Math.random()*Math.PI*2;
                mountain.castShadow = true; mountain.receiveShadow = true;
                mountain.userData.type = 'mountain';
                this.scene.add(mountain);
                // 雪顶重新基于实际最高点放置
                if (height > 110) {
                    const snowHeight = height*0.25;
                    const snow = new THREE.Mesh(new THREE.ConeGeometry(baseRadius*0.35, snowHeight, 10), new THREE.MeshLambertMaterial({ color: 0xf5f7f8 }));
                    const topY = mountain.position.y + bbox.max.y; // 山体最高点
                    // 放在最高点稍低一点，保持贴合
                    snow.position.set(x, topY - height*0.12, z);
                    snow.castShadow = false; snow.receiveShadow = true;
                    this.scene.add(snow);
                }
            }

            // === createTerrain 函数结束 ===

            createClouds() {
                // 增加云朵数量并扩大分布范围到新的8000x8000地形
                for (let i = 0; i < 60; i++) { // Increased from 30 to 60
                    const cloudGeometry = new THREE.SphereGeometry(20 + Math.random() * 30, 8, 6);
                    const cloudMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.7
                    });
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    
                    cloud.position.set(
                        (Math.random() - 0.5) * 6000,  // 从 2000 扩大到 6000
                        100 + Math.random() * 200,
                        (Math.random() - 0.5) * 6000   // 从 2000 扩大到 6000
                    );
                    
                    cloud.scale.set(
                        1 + Math.random() * 0.5,
                        0.3 + Math.random() * 0.3,
                        1 + Math.random() * 0.5
                    );
                    
                    this.clouds.push(cloud);
                    this.scene.add(cloud);
                }
            }

            createDefaultAircraft() {
                // Create enhanced P-51 Mustang style fighter aircraft with premium materials
                const planeGroup = new THREE.Group();
                
                // === PREMIUM MATERIALS ===
                const fuselageMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xD3D3D3, // 新机身浅灰
                    metalness: 0.9,
                    roughness: 0.35,
                    envMapIntensity: 1.0
                });
                
                // Wing material switched to wood-like (low metalness, higher roughness) while keeping original color
                const wingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xE14A32, // 颜色保持不变
                    metalness: 0.05,
                    roughness: 0.85
                });
                
                const glassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.25,
                    metalness: 0.0,
                    roughness: 0.0,
                    transmission: 0.9,
                    ior: 1.5
                });
                
                const darkMetalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x5E5E5E, // 机头 / 整流罩用色
                    metalness: 0.95,
                    roughness: 0.4
                });
                
                // === ENHANCED FUSELAGE (机身) ===
                const fuselageGeometry = new THREE.CylinderGeometry(1.4, 0.7, 16, 16);
                const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                fuselage.rotation.x = Math.PI / 2;
                fuselage.position.set(0, 0, 0);
                fuselage.castShadow = true;
                fuselage.receiveShadow = true;
                planeGroup.add(fuselage);
                
                // === DETAILED NOSE CONE (机鼻) ===
                // Nose shortened by 25% (height 4 -> 3)
                const noseGeometry = new THREE.ConeGeometry(1.4, 3, 16);
                const nose = new THREE.Mesh(noseGeometry, fuselageMaterial);
                nose.position.set(0, 0, 10); // center unchanged; tip moves back 0.5
                nose.rotation.x = Math.PI / 2;
                nose.castShadow = true;
                nose.receiveShadow = true;
                planeGroup.add(nose);
                
                // === ENGINE COWLING (发动机整流罩) ===
                const cowlingGeometry = new THREE.CylinderGeometry(1.6, 1.4, 3, 12);
                const cowling = new THREE.Mesh(cowlingGeometry, darkMetalMaterial);
                cowling.rotation.x = Math.PI / 2;
                cowling.position.set(0, 0, 6.5);
                cowling.castShadow = true;
                planeGroup.add(cowling);
                
                // === REALISTIC WINGS (真实机翼) ===
                // Wing root section
                const wingRootGeometry = new THREE.BoxGeometry(4, 0.8, 4);
                const wingRoot = new THREE.Mesh(wingRootGeometry, wingMaterial);
                wingRoot.position.set(0, -0.2, -1);
                wingRoot.castShadow = true;
                planeGroup.add(wingRoot);
                
                // Tapered wing sections for realistic shape
                for (let side = -1; side <= 1; side += 2) {
                    for (let section = 1; section <= 6; section++) {
                        const width = 4 - (section * 0.4);
                        const thickness = 0.8 - (section * 0.08);
                        const wingGeometry = new THREE.BoxGeometry(width, thickness, 3);
                        const wingSection = new THREE.Mesh(wingGeometry, wingMaterial);
                        wingSection.position.set(side * section * 1.8, -0.2 - (section * 0.02), -1);
                        wingSection.castShadow = true;
                        planeGroup.add(wingSection);
                    }
                }
                
                // === CLEAN WING TIPS (简洁翼尖) ===
                // 移除奇怪的半球形翼尖，改为简洁的椭圆翼尖
                const wingTipGeometry = new THREE.BoxGeometry(1, 0.4, 2);
                for (let side = -1; side <= 1; side += 2) {
                    const wingTip = new THREE.Mesh(wingTipGeometry, wingMaterial);
                    wingTip.position.set(side * 10.8, -0.3, -1);
                    wingTip.castShadow = true;
                    planeGroup.add(wingTip);
                }
                
                // === TAIL SECTION (尾翼) ===
                const tailGeometry = new THREE.CylinderGeometry(0.6, 0.4, 4, 8);
                const tail = new THREE.Mesh(tailGeometry, fuselageMaterial);
                tail.rotation.x = Math.PI / 2;
                tail.position.set(0, 0, -8);
                tail.castShadow = true;
                planeGroup.add(tail);
                
                // === HORIZONTAL STABILIZER (水平尾翼) 重新制作：缩放版主翼 (40% span) ===
                // 模仿主翼的分段递减，但整体跨度与各尺寸缩放至 40%
                (function(){
                    const tailGroup = new THREE.Group();
                    const spanScale = 0.4;          // 相对主翼比例
                    const sections = 6;             // 与主翼相同分段数
                    const baseWidth = 4;            // 主翼 root 段宽(沿X) 参考
                    const baseThickness = 0.8;      // 主翼 root 厚度参考
                    const chordBase = 4;            // 主翼 root chord (沿Z) 参考
                    // Root central block
                    const rootWidth = baseWidth * spanScale;
                    const rootThickness = baseThickness * 0.6 * spanScale; // 更薄
                    const rootChord = chordBase * 0.55; // 尾翼 chord 减短
                    const rootGeo = new THREE.BoxGeometry(rootWidth, rootThickness, rootChord);
                    const rootMesh = new THREE.Mesh(rootGeo, wingMaterial);
                    rootMesh.position.set(0, 0, -10);
                    rootMesh.castShadow = true;
                    tailGroup.add(rootMesh);
                    // Side tapered sections
                    for (let side = -1; side <= 1; side += 2) {
                        for (let s = 1; s <= sections; s++) {
                            const width = (baseWidth - s * 0.4) * spanScale;
                            const thickness = (baseThickness - s * 0.08) * 0.6 * spanScale;
                            const chord = (chordBase - s * 0.35) * 0.55; // 渐缩弦长
                            if (width <= 0.2 || thickness <= 0.02) continue;
                            const geo = new THREE.BoxGeometry(width, thickness, Math.max(chord, 0.6));
                            const mesh = new THREE.Mesh(geo, wingMaterial);
                            mesh.position.set(side * (s * 1.8 * spanScale), -0.02 - s * 0.01, -10);
                            mesh.rotation.y = side * THREE.MathUtils.degToRad(1 + s * 0.6); // 轻微后掠
                            mesh.castShadow = true;
                            tailGroup.add(mesh);
                        }
                        // Tip
                        const tipGeo = new THREE.BoxGeometry(0.9 * spanScale, 0.35 * spanScale, 1.2 * 0.55);
                        const tip = new THREE.Mesh(tipGeo, wingMaterial);
                        tip.position.set(side * (sections * 1.8 * spanScale + 0.3), -0.1, -10);
                        tip.castShadow = true;
                        tailGroup.add(tip);
                    }
                    planeGroup.add(tailGroup);
                })();
                
                // === VERTICAL STABILIZER (垂直尾翼) REWORK: 正确右角三角形，短边贴机身，斜边朝前 ===
                (function(){
                    const base = 3.0;        // 前向（+Z）基底长度
                    const height = 4.2;      // 垂直高度 (+Y)
                    const r = 0.32;          // 圆角半径
                    const thickness = 0.18;   // 厚度 (X)
                    // 在二维平面 (x=前向Z, y=高度Y) 上构建右角三角形，右角在根部 (0,0)
                    const shape = new THREE.Shape();
                    // 从根部稍右 (r,0) 开始，顺时针绕行
                    shape.moveTo(r,0);
                    shape.lineTo(base - r,0);                                // 底边
                    shape.quadraticCurveTo(base,0, base, r);                 // 前下角圆角
                    shape.lineTo(r, height - r);                             // 斜边到近顶点
                    shape.quadraticCurveTo(0,height, 0, height - r);         // 顶角圆角（根部上）
                    shape.lineTo(0, r);                                      // 回到前缘根部
                    shape.quadraticCurveTo(0,0, r,0);                         // 根部下角圆角
                    shape.closePath();
                    // 挤出 (depth 沿 +Z，之后旋转使其厚度沿 X)
                    const extrudeGeo = new THREE.ExtrudeGeometry(shape,{ depth: thickness, bevelEnabled:false });
                    // 旋转：将局部 Z(厚度) -> X，全局前向使用局部 X
                    extrudeGeo.rotateY(Math.PI / 2);
                    // 重新计算包围盒并对齐：根部垂直边 (x≈0) 贴机身，底部 y=0
                    extrudeGeo.computeBoundingBox();
                    let bb = extrudeGeo.boundingBox;
                    // 将底部移到 y=0
                    extrudeGeo.translate(0, -bb.min.y, 0);
                    extrudeGeo.computeBoundingBox();
                    bb = extrudeGeo.boundingBox;
                    // 将根部前缘 (z 最小) 移到 z=0
                    if (Math.abs(bb.min.z) > 1e-5) extrudeGeo.translate(0,0,-bb.min.z);
                    // 厚度中心化 (X 居中)
                    extrudeGeo.computeBoundingBox();
                    bb = extrudeGeo.boundingBox;
                    const xCenter = -(bb.min.x + bb.max.x)/2;
                    extrudeGeo.translate(xCenter,0,0);
                    // 创建 Mesh 并放置在尾部基准 z=-10
                    const fin = new THREE.Mesh(extrudeGeo, wingMaterial);
                    fin.position.set(0,0,-10);
                    // 水平翻转（沿Z轴镜像）
                    fin.scale.z = -1;
                    fin.updateMatrix();
                    fin.castShadow = true;
                    planeGroup.add(fin);
                })();
                
                // === ENHANCED PROPELLER ASSEMBLY ===
                // Propeller spinner
                const spinnerGeometry = new THREE.ConeGeometry(0.8, 1.5, 12);
                const spinnerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // 螺旋桨锥 黑色
                    metalness: 0.95, 
                    roughness: 0.25 
                });
                const spinner = new THREE.Mesh(spinnerGeometry, spinnerMaterial);
                spinner.position.set(0, 0, 12.0); // moved back to match shorter nose
                spinner.rotation.x = Math.PI / 2;
                spinner.castShadow = true;
                planeGroup.add(spinner);
                
                // Propeller hub
                const hubGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.6, 12);
                const hub = new THREE.Mesh(hubGeometry, spinnerMaterial); // 黑色金属
                hub.position.set(0, 0, 11.0); // adjusted with shorter nose
                hub.rotation.x = Math.PI / 2;
                hub.castShadow = true;
                planeGroup.add(hub);
                
                // Enhanced propeller blades
                const propGroup = new THREE.Group();
                const bladeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // 螺旋桨叶黑色金属
                    metalness: 0.9,
                    roughness: 0.35
                });
                
                for (let i = 0; i < 3; i++) {
                    // Realistic blade shape with taper
                    const bladeGeometry = new THREE.BoxGeometry(0.3, 8, 0.15);
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.rotation.z = (i * 2 * Math.PI) / 3;
                    blade.castShadow = true;
                    propGroup.add(blade);
                    
                    // Blade tips
                    const tipGeometry = new THREE.SphereGeometry(0.2, 8, 4);
                    const tip = new THREE.Mesh(tipGeometry, bladeMaterial);
                    tip.position.set(0, 4, 0);
                    tip.rotation.z = (i * 2 * Math.PI) / 3;
                    blade.add(tip);
                }
                
                propGroup.position.set(0, 0, 11.3); // adjusted forward group anchor
                planeGroup.add(propGroup);
                this.propeller = propGroup;
                
                // === DETAILED LANDING GEAR (起落架) ===
                const gearMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x404040,
                    metalness: 0.8,
                    roughness: 0.3
                });
                
                // Main gear struts with hydraulics
                for (let side = -1; side <= 1; side += 2) {
                    const strutGeometry = new THREE.CylinderGeometry(0.08, 0.12, 3.5, 8);
                    const strut = new THREE.Mesh(strutGeometry, gearMaterial);
                    strut.position.set(side * 2, -2.2, 0);
                    strut.castShadow = true;
                    planeGroup.add(strut);
                    
                    // Wheels with detailed rims
                    const wheelGeometry = new THREE.CylinderGeometry(0.9, 0.9, 0.4, 16);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a,
                        roughness: 0.9
                    });
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(side * 2, -3.8, 0);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.castShadow = true;
                    planeGroup.add(wheel);
                    
                    // Wheel rims
                    const rimGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.45, 16);
                    const rim = new THREE.Mesh(rimGeometry, gearMaterial);
                    rim.position.set(side * 2, -3.8, 0);
                    rim.rotation.z = Math.PI / 2;
                    rim.castShadow = true;
                    planeGroup.add(rim);
                }
                
                // Tail wheel (reworked with strut similar to main gear)
                const tailGearGroup = new THREE.Group();
                // Strut (thin black support)
                const tailStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 2.2, 8), gearMaterial);
                tailStrut.rotation.z = 0; // vertical
                tailStrut.position.set(0, -0.4, -8.6);
                tailStrut.castShadow = true;
                tailGearGroup.add(tailStrut);
                // Axle block
                const tailAxle = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.6), gearMaterial);
                tailAxle.position.set(0, -1.4, -9.0);
                tailAxle.castShadow = true;
                tailGearGroup.add(tailAxle);
                // Wheel
                const tailWheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.38, 14);
                const tailWheel = new THREE.Mesh(tailWheelGeometry, new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, roughness: 0.9 
                }));
                // Match orientation of main gear wheels (rotate around Z)
                tailWheel.rotation.x = 0;
                tailWheel.rotation.z = Math.PI / 2;
                tailWheel.position.set(0, -1.55, -9.0);
                tailWheel.castShadow = true;
                tailGearGroup.add(tailWheel);
                planeGroup.add(tailGearGroup);
                
                // === COCKPIT CANOPY (半球形座舱盖) with Glass + Frame ===
                // 半球透明玻璃 + 加强筋框架
                const canopyRadius = 1.35; // 略大于机身截面, 贴合
                const canopyGeom = new THREE.SphereGeometry(canopyRadius, 32, 20, 0, Math.PI * 2, 0, Math.PI / 2);
                // 玻璃材质：轻微蓝绿色调，可调
                const canopyGlassMaterial = new THREE.MeshStandardMaterial({
                    color: 0x99c6d8,
                    metalness: 0.0,
                    roughness: 0.05,
                    transparent: true,
                    opacity: 0.28,
                    depthWrite: false
                });
                const canopyGroup = new THREE.Group();
                const canopyGlass = new THREE.Mesh(canopyGeom, canopyGlassMaterial);
                canopyGlass.castShadow = false;
                canopyGlass.receiveShadow = false;
                canopyGroup.add(canopyGlass);

                // 框架材质（稍深金属）
                const canopyFrameMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2d3134,
                    metalness: 0.65,
                    roughness: 0.35
                });
                const frameTubeRadius = 0.04;
                const frameRadialSegments = 12;
                const frameTubularSegments = 48;

                // 底部环形框 (沿 XY 平面) - Torus 默认轴 Y (平面 XZ)，旋转到 XY
                const baseRing = new THREE.Mesh(
                    new THREE.TorusGeometry(canopyRadius * 0.995, frameTubeRadius, frameRadialSegments, frameTubularSegments),
                    canopyFrameMaterial
                );
                baseRing.rotation.x = Math.PI / 2; // 轴从 Y 旋到 Z，使平面变成 XY
                baseRing.castShadow = true;
                canopyGroup.add(baseRing);

                // 前后竖向框 (平面 XZ) - 不旋转 (默认平面 XZ)
                const foreAftRing = new THREE.Mesh(
                    new THREE.TorusGeometry(canopyRadius, frameTubeRadius * 0.75, frameRadialSegments, frameTubularSegments),
                    canopyFrameMaterial
                );
                foreAftRing.castShadow = true;
                canopyGroup.add(foreAftRing);

                // 左右竖向框 (平面 YZ) - 旋转 Z 90°
                const leftRightRing = new THREE.Mesh(
                    new THREE.TorusGeometry(canopyRadius, frameTubeRadius * 0.75, frameRadialSegments, frameTubularSegments),
                    canopyFrameMaterial
                );
                leftRightRing.rotation.z = Math.PI / 2;
                leftRightRing.castShadow = true;
                canopyGroup.add(leftRightRing);

                // 顶部纵向加强筋 (沿 Z 方向的条) 使用细长 Box 略高出表面
                const topSpine = new THREE.Mesh(new THREE.BoxGeometry(frameTubeRadius * 0.9, frameTubeRadius * 0.9, canopyRadius * 2 * 0.92), canopyFrameMaterial);
                topSpine.position.y = canopyRadius * 0.72; // 略低于顶点，避免悬空
                topSpine.castShadow = true;
                canopyGroup.add(topSpine);

                // 轻微整体向上：贴合机身外壳
                canopyGroup.position.set(0, 0.68, 0.2);
                // 水平旋转 90° (绕 Y 轴) 
                canopyGroup.rotation.y = Math.PI / 2;
                planeGroup.add(canopyGroup);
                
                // === COCKPIT INTERIOR (驾驶舱内部) - 调整位置 ===
                const seatGeometry = new THREE.BoxGeometry(0.8, 0.4, 1.2);
                const seatMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a4a4a, 
                    roughness: 0.8 
                });
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(0, 0.1, 0.5); // 稍微降低座椅位置
                seat.castShadow = true;
                planeGroup.add(seat);
                
                // Control stick (操纵杆)
                const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
                const stick = new THREE.Mesh(stickGeometry, darkMetalMaterial);
                stick.position.set(0, 0.4, 1.0); // 调整操纵杆位置
                stick.castShadow = true;
                planeGroup.add(stick);
                
                // Instrument panel (仪表板)
                const panelGeometry = new THREE.BoxGeometry(1.4, 0.6, 0.08);
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a, 
                    roughness: 0.6,
                    metalness: 0.3
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(0, 0.5, 2.0); // 调整仪表板位置
                panel.rotation.x = -Math.PI / 6; // 向后倾斜15度
                panel.castShadow = true;
                planeGroup.add(panel);
                
                // === NAVIGATION LIGHTS (导航灯) ===
                // Wing tip lights with proper aviation colors
                for (let side = -1; side <= 1; side += 2) {
                    const lightGeometry = new THREE.SphereGeometry(0.12, 8, 6);
                    const lightMaterial = new THREE.MeshStandardMaterial({ 
                        color: side > 0 ? 0x00ff00 : 0xff0000, // Green right, red left
                        emissive: side > 0 ? 0x004400 : 0x440000,
                        emissiveIntensity: 0.5,
                        metalness: 0.1,
                        roughness: 0.2
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(side * 11, 0, -1);
                    planeGroup.add(light);
                }
                
                // Tail navigation light
                const tailLightGeometry = new THREE.SphereGeometry(0.08, 8, 6);
                const tailLightMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0x222222,
                    emissiveIntensity: 0.3,
                    metalness: 0.1,
                    roughness: 0.2
                });
                const tailLight = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
                tailLight.position.set(0, 1, -12);
                planeGroup.add(tailLight);
                
                // === ENHANCED ENGINE EXHAUST STACKS (排气管) ===
                for (let i = 0; i < 6; i++) {
                    const exhaustGeometry = new THREE.CylinderGeometry(0.12, 0.18, 1.2, 8);
                    const exhaustMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2a2a2a,
                        metalness: 0.6,
                        roughness: 0.7,
                        emissive: 0x221100,
                        emissiveIntensity: 0.1
                    });
                    const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 1.2;
                    exhaust.position.set(
                        Math.cos(angle) * radius, 
                        Math.sin(angle) * radius, 
                        5
                    );
                    exhaust.rotation.x = Math.PI / 2;
                    exhaust.castShadow = true;
                    planeGroup.add(exhaust);
                }
                
                // === FINAL ASSEMBLY ===
                planeGroup.position.copy(this.playerPosition);
                planeGroup.scale.set(2.16, 2.16, 2.16); // 等比例再放大1.5倍 (原 1.44)
                
                // Store references
                this.aircraft = planeGroup;
                this.scene.add(this.aircraft);
                // 如果默认飞机创建成功后添加机炮（若未在init里）
                if (this.gunBarrels.length === 0) this.createNoseCannons();
            }

            // ================= Nose Cannon System =================
            createNoseCannons() {
                if (!this.aircraft) return;
                // 避免重复添加
                if (this.aircraft.getObjectByName('NoseCannons')) return;
                const barrelsGroup = new THREE.Group();
                barrelsGroup.name = 'NoseCannons';
                const barrelMat = new THREE.MeshStandardMaterial({
                    color: 0x2c2c2c,
                    metalness: 0.85,
                    roughness: 0.25
                });
                const barrelGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.6, 12);
                this.gunBarrels = [];
                for (let s of [-1,1]) {
                    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                    barrel.rotation.x = Math.PI/2;
                    barrel.position.set(s*0.6, -0.15, 7.2);
                    barrel.castShadow = true;
                    barrelsGroup.add(barrel);
                    this.gunBarrels.push(barrel);
                }
                // 装饰基座环
                const ringGeo = new THREE.TorusGeometry(0.28, 0.045, 6, 16);
                for (let s of [-1,1]) {
                    const ring = new THREE.Mesh(ringGeo, new THREE.MeshStandardMaterial({
                        color: 0x555555,
                        metalness: 0.6,
                        roughness: 0.4
                    }));
                    ring.rotation.x = Math.PI/2;
                    ring.position.set(s*0.6, -0.15, 6.45);
                    barrelsGroup.add(ring);
                }
                this.aircraft.add(barrelsGroup);
            }

            setupMouseControls() {
                const canvas = this.renderer.domElement;
                canvas.addEventListener('mousedown', (e)=>{ if (e.button===0) this.isFiring = true; });
                window.addEventListener('mouseup', (e)=>{ if (e.button===0) this.isFiring = false; });
            }

            tryFireGuns(deltaTime) {
                if (!this.isFiring || !this.aircraft || this.gunBarrels.length===0) return;
                const now = performance.now()/1000;
                if (now - this.lastShotTime < this.fireInterval) return;
                this.lastShotTime = now;
                // 前向方向
                this.forwardVec.set(0,0,1).applyEuler(new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll)).normalize();
                // 炮口射击
                this.gunBarrels.forEach(barrel=>{
                    barrel.getWorldPosition(this.tempVec);
                    this.spawnBullet(this.tempVec, this.forwardVec);
                    this.spawnMuzzleFlash(barrel);
                });
            }

            spawnBullet(origin, forward) {
                const geo = new THREE.SphereGeometry(0.45, 10, 10);
                const mat = new THREE.MeshBasicMaterial({ color: 0xfff066 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(origin);
                this.scene.add(mesh);
                const speed = 450;
                this.bullets.push({ mesh, velocity: forward.clone().multiplyScalar(speed), life: 2, age: 0 });
            }

            spawnMuzzleFlash(barrel) {
                const flashGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const flashMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                barrel.getWorldPosition(flash.position);
                this.scene.add(flash);
                this.muzzleFlashes.push({ mesh: flash, age: 0, life: 0.12 });
            }

            // ====== Scoreboard helpers ======
            ensurePlayerName(){
                const storedName = localStorage.getItem('skywarriors_playerName');
                if (storedName) { this.playerName = storedName; return; }
                this.showNamePrompt();
            }
            showNamePrompt(){
                if (document.getElementById('namePromptOverlay')) return;
                const overlay = document.createElement('div'); overlay.id='namePromptOverlay';
                overlay.innerHTML = `\n<div id="namePromptBox">\n  <h2>输入玩家名称</h2>\n  <input id="playerNameInput" maxlength="18" placeholder="例如：王牌飞行员" />\n  <button id="confirmNameBtn">进入战场</button>\n  <div class="note">该名字会用于积分榜并保存在浏览器本地。\n  如果留空将随机生成。</div>\n</div>`;
                document.body.appendChild(overlay);
                overlay.querySelector('#confirmNameBtn').addEventListener('click', ()=>{
                    const val = overlay.querySelector('#playerNameInput').value.trim();
                    this.playerName = val || ('Pilot_' + Math.random().toString(36).slice(2,7));
                    localStorage.setItem('skywarriors_playerName', this.playerName);
                    overlay.remove();
                    this.registerPlayerIfNeeded();
                    this.updateScoreboardUI();
                });
            }
            loadScores(){
                try { const raw = localStorage.getItem(this.localStorageKey); if(raw) this.scoreData = JSON.parse(raw); } catch(e){ console.warn('Load score error', e); }
            }
            saveScores(){
                try { localStorage.setItem(this.localStorageKey, JSON.stringify(this.scoreData)); } catch(e){ console.warn('Save score error', e); }
            }
            registerPlayerIfNeeded(){
                if(!this.playerName) return;
                if(!this.scoreData.players[this.playerName]){
                    this.scoreData.players[this.playerName] = { tank:0, ship:0, total:0, last: Date.now() };
                    this.saveScores();
                }
            }
            recordKill(type){ // type: 'tank' | 'ship'
                if(!this.playerName) return;
                const p = this.scoreData.players[this.playerName]; if(!p) return;
                if(type==='tank') p.tank +=1; else if(type==='ship') p.ship +=1;
                p.total = p.tank + p.ship; p.last = Date.now();
                this.saveScores();
                this.updateScoreboardUI();
                // session counters
                if(type==='tank') this.sessionKills.tank++; else if(type==='ship') this.sessionKills.ship++;
                this.updateHudStats();
            }
            updateScoreboardUI(){
                const panel = document.getElementById('scoreboardPanel');
                if(!panel){ return; }
                panel.style.display = 'block';
                const rowsContainer = document.getElementById('scoreRows');
                if(!rowsContainer) return;
                const entries = Object.entries(this.scoreData.players).map(([name,data])=>({ name, ...data }));
                entries.sort((a,b)=> b.total - a.total || a.name.localeCompare(b.name));
                rowsContainer.innerHTML = '';
                entries.forEach((d,idx)=>{
                    const tr = document.createElement('tr');
                    if (d.name === this.playerName) tr.classList.add('highlight');
                    tr.innerHTML = `<td>${idx+1}</td><td>${d.name}</td><td>${d.tank}</td><td>${d.ship}</td><td>${d.total}</td>`;
                    rowsContainer.appendChild(tr);
                });
                const nameDisp = document.getElementById('playerNameDisplay');
                if(nameDisp) nameDisp.textContent = '当前玩家: ' + (this.playerName||'--');
                const exportBtn = document.getElementById('exportScoreBtn');
                if(exportBtn && !exportBtn.dataset.bound){
                    exportBtn.dataset.bound = '1';
                    exportBtn.addEventListener('click', ()=> this.exportScoresJSON());
                }
            }
            exportScoresJSON(){
                const blob = new Blob([JSON.stringify(this.scoreData,null,2)], { type:'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'scores.json'; a.click();
                URL.revokeObjectURL(url);
                this.showNotification('已导出积分 JSON', 'success');
            }
            updateHudStats(){
                const hud = document.getElementById('hudStats'); if(!hud) return;
                hud.style.display = 'flex';
                const tk = document.getElementById('hudTankKills');
                const sk = document.getElementById('hudShipKills');
                const tt = document.getElementById('hudTotalKills');
                if(tk) tk.textContent = this.sessionKills.tank;
                if(sk) sk.textContent = this.sessionKills.ship;
                if(tt) tt.textContent = this.sessionKills.tank + this.sessionKills.ship;
            }

            updateBullets(deltaTime) {
                // 子弹移动 & 淡出
                for (let i = this.bullets.length-1; i>=0; i--) {
                    const b = this.bullets[i];
                    b.age += deltaTime;
                    b.mesh.position.addScaledVector(b.velocity, deltaTime);
                    // 伸长视觉（沿局部Z用scale模拟）
                    b.mesh.scale.z = 1 + b.age*4;
                    const t = b.age / b.life;
                    if (t > 0.6) {
                        b.mesh.material.transparent = true;
                        b.mesh.material.opacity = 1 - (t-0.6)/0.4;
                    }
                    // ==== 碰撞检测：子弹 vs 坦克 ====
                    if (this.tanks && this.tanks.length>0) {
                        for (let ti = 0; ti < this.tanks.length; ti++) {
                            const tank = this.tanks[ti];
                            if (!tank.alive) continue;
                            const dist = b.mesh.position.distanceTo(tank.mesh.position);
                            if (dist < tank.radius) {
                                // 命中
                                tank.alive = false;
                                this.createExplosion(tank.mesh.position.clone());
                                this.scene.remove(tank.mesh);
                                // 生成残骸/焦黑贴花
                                this.createScorchMark(tank.mesh.position.x, tank.mesh.position.z);
                                // 移除子弹
                                this.scene.remove(b.mesh);
                                b.mesh.geometry.dispose();
                                b.mesh.material.dispose();
                                this.recordKill('tank');
                                this.bullets.splice(i,1);
                                break; // 跳出坦克循环
                            }
                        }
                    }
                    // ==== 碰撞检测：子弹 vs 战舰 ====
                    if (this.warships && this.warships.length>0) {
                        for (let wi=0; wi<this.warships.length; wi++) {
                            const ship = this.warships[wi];
                            if(!ship.alive) continue;
                            const distS = b.mesh.position.distanceTo(ship.mesh.position);
                            if (distS < ship.radius) {
                                ship.alive = false;
                                this.createExplosion(ship.mesh.position.clone().add(new THREE.Vector3(0,5,0)));
                                this.scene.remove(ship.mesh);
                                // 海面焦痕 / 浮渣：简单用一个半透明黑圆
                                this.createSeaScorch(ship.mesh.position.x, ship.mesh.position.z);
                                this.scene.remove(b.mesh);
                                b.mesh.geometry.dispose();
                                b.mesh.material.dispose();
                                this.recordKill('ship');
                                this.bullets.splice(i,1);
                                break;
                            }
                        }
                    }
                    if (b.age >= b.life) {
                        this.scene.remove(b.mesh);
                        b.mesh.geometry.dispose();
                        b.mesh.material.dispose();
                        this.bullets.splice(i,1);
                    }
                }
                // 枪口火光
                for (let i = this.muzzleFlashes.length-1; i>=0; i--) {
                    const f = this.muzzleFlashes[i];
                    f.age += deltaTime;
                    const p = f.age / f.life;
                    f.mesh.scale.setScalar(1 + p*5);
                    f.mesh.material.transparent = true;
                    f.mesh.material.opacity = 1 - p;
                    if (f.age >= f.life) {
                        this.scene.remove(f.mesh);
                        f.mesh.geometry.dispose();
                        f.mesh.material.dispose();
                        this.muzzleFlashes.splice(i,1);
                    }
                }
            }

            // ==== 战舰相关 ====
            createWarships(count=5){
                for(let i=0;i<count;i++){
                    const x = (Math.random()-0.5)*6500;
                    const z = (Math.random()-0.5)*6500;
                    if (Math.hypot(x,z) < 600) { i--; continue; }
                    const ship = this.createWarship(x,z);
                    this.warships.push(ship);
                }
            }
            createWarship(x,z){
                const g = new THREE.Group();
                // 船体梭形 + 甲板
                const hullLen = 160 + Math.random()*60;
                const hullWidth = 22 + Math.random()*6;
                const hullHeight = 10;
                // 梭形 hull: 由一个长盒再用缩放形成纺锤（中宽，两端逐渐变细）
                const spindleGeo = new THREE.BoxGeometry(hullWidth, hullHeight, hullLen, 8,1,16);
                // 手动顶点调整：根据Z距离中心缩放X,Y 形成平滑梭形
                const pos = spindleGeo.attributes.position;
                for(let i=0;i<pos.count;i++){
                    const z = pos.getZ(i);
                    const nz = Math.abs(z)/(hullLen/2); // 0..1
                    const taper = 1 - Math.pow(nz,1.4); // 中央最大
                    pos.setX(i, pos.getX(i)* (0.55 + 0.45*taper));
                    pos.setY(i, pos.getY(i)* (0.55 + 0.45*taper));
                }
                spindleGeo.computeVertexNormals();
                const hullMat = new THREE.MeshStandardMaterial({ color:0x3f454c, metalness:0.25, roughness:0.85 });
                const spindle = new THREE.Mesh(spindleGeo, hullMat);
                spindle.position.y = -41; // 大部分浸入水下，少量露出
                spindle.castShadow = true; spindle.receiveShadow = true;
                g.add(spindle);
                // 上层甲板（略短）
                const deck = new THREE.Mesh(new THREE.BoxGeometry(hullWidth*0.9,4,hullLen*0.62), new THREE.MeshStandardMaterial({ color:0x676d75, metalness:0.25, roughness:0.6 }));
                deck.position.set(0, -36.2, 0); // 露出水面
                deck.castShadow = true; g.add(deck);
                // 指挥塔 + 雷达简化
                const tower = new THREE.Mesh(new THREE.BoxGeometry(hullWidth*0.4,14,hullLen*0.18), new THREE.MeshStandardMaterial({ color:0x7a8088 }));
                tower.position.set(0, deck.position.y + 9, -hullLen*0.08);
                tower.castShadow = true; g.add(tower);
                const radar = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,6,12), new THREE.MeshStandardMaterial({ color:0xd9d9d9 }));
                radar.position.set(0, tower.position.y + 10, -hullLen*0.08);
                radar.rotation.x = Math.PI/2; g.add(radar);
                // 桅杆（高度7）
                const mastHeight = 7;
                const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,mastHeight,10), new THREE.MeshStandardMaterial({ color:0xdddddd, metalness:0.4, roughness:0.5 }));
                mast.position.set(0, deck.position.y + mastHeight/2 + 2, 0);
                mast.castShadow = true; g.add(mast);
                // 红色箭头指示器（与坦克风格统一）
                const arrowGroup = new THREE.Group();
                const arrowMat = new THREE.MeshBasicMaterial({ color:0xff2222 });
                const cone = new THREE.Mesh(new THREE.ConeGeometry(3.2,9,18), arrowMat);
                cone.rotation.x = Math.PI; arrowGroup.add(cone);
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,4.5,12), arrowMat);
                stem.position.y = -6.5; arrowGroup.add(stem);
                arrowGroup.position.set(0, deck.position.y + 18, 0);
                arrowGroup.userData = { pulsePhase: Math.random()*Math.PI*2 };
                g.add(arrowGroup);
                // 炮塔 (前后各一个简化)
                const turretMat = new THREE.MeshStandardMaterial({ color:0x5b6068, metalness:0.3, roughness:0.6 });
                const shipTurretGeo = new THREE.CylinderGeometry(6,6,4,12);
                const mkTurret1 = new THREE.Mesh(shipTurretGeo, turretMat); mkTurret1.position.set(0, deck.position.y + 3, hullLen*0.18); mkTurret1.castShadow=true; g.add(mkTurret1);
                const mkTurret2 = new THREE.Mesh(shipTurretGeo, turretMat); mkTurret2.position.set(0, deck.position.y + 3, -hullLen*0.25); mkTurret2.castShadow=true; g.add(mkTurret2);
                // 炮管双联
                const barrelGeo = new THREE.CylinderGeometry(0.7,0.9,18,12);
                [mkTurret1, mkTurret2].forEach((tur,idx)=>{
                    for(let b=0;b<2;b++){
                        const barrel = new THREE.Mesh(barrelGeo, new THREE.MeshStandardMaterial({ color:0x3a3d42, metalness:0.5, roughness:0.4 }));
                        barrel.rotation.x = Math.PI/2;
                        barrel.position.set((b===0? -1.2:1.2), tur.position.y, tur.position.z + (idx===0? 8: -8));
                        barrel.position.y += 2;
                        g.add(barrel);
                    }
                });
                g.position.set(x,0,z);
                this.scene.add(g);
                return { mesh: g, alive: true, radius: hullWidth*2, indicator: arrowGroup };
            }
            createSeaScorch(x,z){
                const r = 18 + Math.random()*12;
                const geo = new THREE.CircleGeometry(r, 22);
                const mat = new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.25 });
                const scorch = new THREE.Mesh(geo, mat);
                scorch.rotation.x = -Math.PI/2;
                scorch.position.set(x, -39.9, z);
                this.scene.add(scorch);
                setTimeout(()=>{ this.scene.remove(scorch); geo.dispose(); mat.dispose(); }, 8000);
            }

            // === 环境系统函数 ===
            
            createTrees() {
                const m = this.environmentConfig.treeDensityMultiplier;
                this.createDenseForest(-2500, -2000, 800, 600, 'pine', Math.round(80*m));
                this.createDenseForest(1800, 1500, 700, 500, 'oak', Math.round(70*m));
                this.createMediumForest(-1000, 2200, 900, 700, 'mixed', Math.round(45*m));
                this.createMediumForest(2200, -800, 600, 800, 'birch', Math.round(40*m));
                this.createSparseForest(-3000, 0, 1200, 800, 'oak', Math.round(25*m));
                this.createSparseForest(0, -2800, 1000, 600, 'pine', Math.round(20*m));
                this.createSparseForest(1000, 3000, 800, 600, 'palm', Math.round(15*m));
                for (let i = 0; i < Math.round(100*m); i++) {
                    const x = (Math.random()-0.5)*7000;
                    const z = (Math.random()-0.5)*7000;
                    const treeType = ['pine','oak','birch','palm'][Math.floor(Math.random()*4)];
                    this.createTree(x,z,treeType);
                }
            }

            // 密集森林 - 树木紧密排列
            createDenseForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    // 使用聚集分布，模拟真实森林
                    const clusterX = centerX + (Math.random() - 0.5) * width * 0.8;
                    const clusterZ = centerZ + (Math.random() - 0.5) * depth * 0.8;
                    
                    // 在聚集点周围随机分布
                    const offsetX = (Math.random() - 0.5) * 50;
                    const offsetZ = (Math.random() - 0.5) * 50;
                    
                    this.createTree(clusterX + offsetX, clusterZ + offsetZ, forestType);
                }
            }

            // 中等密度森林
            createMediumForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    const x = centerX + (Math.random() - 0.5) * width;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // 随机跳过一些位置，创造空隙
                    if (Math.random() > 0.3) {
                        this.createTree(x, z, forestType);
                    }
                }
            }

            // 稀疏森林
            createSparseForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    const x = centerX + (Math.random() - 0.5) * width;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // 稀疏分布，更多空旷区域
                    if (Math.random() > 0.6) {
                        this.createTree(x, z, forestType);
                    }
                }
            }

            // === 湖泊系统（替换原先的河流系统） ===
            createLakes() {
                if (this.sceneType === 'desert') return; // 沙漠禁用湖泊
                // 创建多个不同大小与形状的湖泊
                const lakeConfigs = [
                    { x: -1500, z: -1200, radius: 350, color: 0x3A87BD }, // 大湖
                    { x: 1200, z: 800, radius: 250, color: 0x357EBA },   // 中型湖
                    { x: 400, z: -1400, radius: 180, color: 0x2F6FAF },  // 中小湖
                    { x: -800, z: 1600, radius: 200, color: 0x337BB5 },  // 森林湖
                    { x: 1800, z: -600, radius: 150, color: 0x2E75AA }   // 丘陵湖
                ];

                lakeConfigs.forEach(cfg => this.createLake(cfg.x, cfg.z, cfg.radius, cfg.color));

                // 生成一些随机小湖/池塘
                for (let i = 0; i < 6; i++) {
                    const x = (Math.random() - 0.5) * 6000;
                    const z = (Math.random() - 0.5) * 6000;
                    const r = 80 + Math.random() * 140;
                    this.createLake(x, z, r, 0x2F6FAF);
                }
            }

            createLake(centerX, centerZ, radius, color) {
                if (this.sceneType === 'desert') return; // 再次防御性检查
                // 使用细分圆形并随机扰动顶点制造自然外形
                const segments = 48;
                const geometry = new THREE.CircleGeometry(radius, segments);
                const pos = geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    if (i === 0) continue; // 跳过中心点
                    const vx = pos.getX(i);
                    const vy = pos.getY(i);
                    const r = Math.sqrt(vx * vx + vy * vy);
                    const deform = 1 + (Math.random() - 0.5) * 0.15; // 轻微形变
                    pos.setX(i, vx * deform);
                    pos.setY(i, vy * deform);
                }
                pos.needsUpdate = true;

                // 添加轻微波浪法线效果（顶点抖动可选）
                geometry.computeVertexNormals();

                const material = new THREE.MeshLambertMaterial({
                    color,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });

                const lake = new THREE.Mesh(geometry, material);
                lake.rotation.x = -Math.PI / 2;
                lake.position.set(centerX, -46, centerZ); // 与地面稍微凹陷一点
                lake.receiveShadow = true;
                this.scene.add(lake);

                // 环湖植被：在湖泊外圈随机生成树木和灌木
                const ringCount = Math.floor(radius / 20);
                for (let i = 0; i < ringCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = radius + 30 + Math.random() * 120;
                    const x = centerX + Math.cos(angle) * dist;
                    const z = centerZ + Math.sin(angle) * dist;
                    const types = ['birch', 'oak', 'pine'];
                    this.createTree(x, z, types[Math.floor(Math.random() * types.length)]);
                }
            }

            createTree(x, z, treeType = 'oak') {
                const treeGroup = new THREE.Group();
                
                // 海洋场景：在树下生成更高、明显的黄色沙滩小岛（圆台状）
                if (this.sceneType === 'ocean') {
                    const baseRadius = treeType === 'palm' ? 30 : 22;
                    const islandRadiusTop = baseRadius * 0.7;
                    const islandRadiusBottom = baseRadius + Math.random() * (treeType === 'palm' ? 18 : 10);
                    const height = 8 + Math.random()*4; // 明显高于水面 (水面 ~ -40)
                    const geo = new THREE.CylinderGeometry(islandRadiusTop, islandRadiusBottom, height, 24, 1, false);
                    geo.translate(0, height/2, 0);
                    const sandColor = new THREE.Color().setHSL(0.12 + Math.random()*0.04, 0.55, 0.62); // 亮黄沙
                    const island = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color: sandColor }));
                    island.position.set(x, -50, z); // 底部贴近原虚拟地平 (-50)
                    island.castShadow = true; island.receiveShadow = true;
                    island.userData.isIsland = true;
                    // 顶部再加一圈更浅的沙滩边缘
                    const rimGeo = new THREE.CylinderGeometry(islandRadiusTop*1.05, islandRadiusTop*1.25, 1.2, 24, 1, false);
                    const rim = new THREE.Mesh(rimGeo, new THREE.MeshLambertMaterial({ color: 0xF5E7A1 }));
                    rim.position.y = height + -50 - 0.4; // 贴近顶部
                    rim.receiveShadow = true;
                    island.add(rim);
                    this.scene.add(island);
                }

                let trunkHeight, trunkRadius;
                
                switch(treeType) {
                    case 'pine': // 优美的松树
                        trunkHeight = 15 + Math.random() * 10;
                        trunkRadius = 0.6 + Math.random() * 0.3;
                        
                        // 松树树干 - 自然棕色
                        const pineTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.7, trunkRadius * 1.2, trunkHeight, 8
                        );
                        const pineTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B4513 // 温暖的棕色
                        });
                        const pineTrunk = new THREE.Mesh(pineTrunkGeometry, pineTrunkMaterial);
                        pineTrunk.position.y = trunkHeight / 2 - 50;
                        pineTrunk.castShadow = true;
                        treeGroup.add(pineTrunk);
                        
                        // 松树层状树冠 - 深绿到浅绿渐变
                        const greenShades = [0x0F4F0F, 0x228B22, 0x32CD32, 0x90EE90];
                        for (let layer = 0; layer < 5; layer++) {
                            const layerRadius = 5 - layer * 0.7;
                            const layerHeight = 3.5 + Math.random() * 0.5;
                            const crownGeometry = new THREE.ConeGeometry(layerRadius, layerHeight, 8);
                            const crownMaterial = new THREE.MeshLambertMaterial({ 
                                color: greenShades[Math.min(layer, 3)]
                            });
                            const crownLayer = new THREE.Mesh(crownGeometry, crownMaterial);
                            crownLayer.position.y = trunkHeight - 50 + layer * 2.8;
                            crownLayer.castShadow = true;
                            treeGroup.add(crownLayer);
                        }
                        break;
                        
                    case 'oak': // 雄伟的橡树
                        trunkHeight = 10 + Math.random() * 8;
                        trunkRadius = 1.2 + Math.random() * 0.6;
                        
                        // 橡树粗壮树干 - 深棕色
                        const oakTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.8, trunkRadius * 1.4, trunkHeight, 8
                        );
                        const oakTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x654321 // 深棕色
                        });
                        const oakTrunk = new THREE.Mesh(oakTrunkGeometry, oakTrunkMaterial);
                        oakTrunk.position.y = trunkHeight / 2 - 50;
                        oakTrunk.castShadow = true;
                        treeGroup.add(oakTrunk);
                        
                        // 橡树茂密树冠 - 多层结构
                        const mainCrownGeometry = new THREE.SphereGeometry(6 + Math.random() * 2, 10, 8);
                        mainCrownGeometry.scale(1.4, 0.9, 1.4); // 压扁的宽阔树冠
                        const mainCrownMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22 // 森林绿
                        });
                        const mainCrown = new THREE.Mesh(mainCrownGeometry, mainCrownMaterial);
                        mainCrown.position.y = trunkHeight - 50 + 4;
                        mainCrown.castShadow = true;
                        treeGroup.add(mainCrown);
                        
                        // 额外的小树冠增加层次感
                        for (let i = 0; i < 3; i++) {
                            const smallCrownGeometry = new THREE.SphereGeometry(2 + Math.random(), 8, 6);
                            const smallCrownMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x32CD32 // 较亮的绿色
                            });
                            const smallCrown = new THREE.Mesh(smallCrownGeometry, smallCrownMaterial);
                            smallCrown.position.set(
                                (Math.random() - 0.5) * 8,
                                trunkHeight - 50 + 3 + Math.random() * 3,
                                (Math.random() - 0.5) * 8
                            );
                            smallCrown.castShadow = true;
                            treeGroup.add(smallCrown);
                        }
                        break;
                        
                    case 'birch': // 优雅的桦树
                        trunkHeight = 12 + Math.random() * 6;
                        trunkRadius = 0.4 + Math.random() * 0.2;
                        
                        // 桦树细长白色树干
                        const birchTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.9, trunkRadius * 1.1, trunkHeight, 8
                        );
                        const birchTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xF5F5DC // 优雅的米色白
                        });
                        const birchTrunk = new THREE.Mesh(birchTrunkGeometry, birchTrunkMaterial);
                        birchTrunk.position.y = trunkHeight / 2 - 50;
                        birchTrunk.castShadow = true;
                        treeGroup.add(birchTrunk);
                        
                        // 桦树垂柳状树冠
                        const birchCrownGeometry = new THREE.SphereGeometry(4 + Math.random() * 1.5, 8, 6);
                        birchCrownGeometry.scale(1.2, 1.4, 1.2); // 稍微拉长
                        const birchCrownMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x9ACD32 // 黄绿色
                        });
                        const birchCrown = new THREE.Mesh(birchCrownGeometry, birchCrownMaterial);
                        birchCrown.position.y = trunkHeight - 50 + 3;
                        birchCrown.castShadow = true;
                        treeGroup.add(birchCrown);
                        break;
                        
                    case 'palm': // 热带棕榈树
                        trunkHeight = 14 + Math.random() * 8;
                        trunkRadius = 0.8;
                        
                        // 棕榈树弯曲树干
                        const palmTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.6, trunkRadius, trunkHeight, 8
                        );
                        const palmTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xD2691E // 温暖的橙棕色
                        });
                        const palmTrunk = new THREE.Mesh(palmTrunkGeometry, palmTrunkMaterial);
                        palmTrunk.position.y = trunkHeight / 2 - 50;
                        palmTrunk.rotation.z = (Math.random() - 0.5) * 0.4; // 轻微倾斜
                        palmTrunk.castShadow = true;
                        treeGroup.add(palmTrunk);
                        
                        // 棕榈叶 - 更真实的造型
                        for (let leaf = 0; leaf < 12; leaf++) {
                            const leafGeometry = new THREE.CylinderGeometry(0.1, 0.4, 7, 4);
                            const leafMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x228B22 // 热带绿
                            });
                            const palmLeaf = new THREE.Mesh(leafGeometry, leafMaterial);
                            const angle = (leaf / 12) * Math.PI * 2;
                            const radius = 2.5 + Math.random() * 0.5;
                            palmLeaf.position.set(
                                Math.cos(angle) * radius,
                                trunkHeight - 50 + 3,
                                Math.sin(angle) * radius
                            );
                            palmLeaf.rotation.z = angle + Math.PI / 2.5; // 向外弯曲
                            palmLeaf.rotation.x = (Math.random() - 0.5) * 0.3; // 随机倾斜
                            palmLeaf.castShadow = true;
                            treeGroup.add(palmLeaf);
                        }
                        break;
                        
                    case 'mixed':
                        // 混合林中随机选择树种
                        const mixedTypes = ['pine', 'oak', 'birch'];
                        return this.createTree(x, z, mixedTypes[Math.floor(Math.random() * mixedTypes.length)]);
                }
                
                // 添加轻微随机旋转，增加自然感
                treeGroup.rotation.y = Math.random() * Math.PI * 2;
                treeGroup.position.set(x, 0, z);
                this.scene.add(treeGroup);
            }

            // === Extra Environment Helpers ===
            createBushCluster(x,z,count=8){
                for (let i=0;i<count;i++){
                    const r = 2 + Math.random()*2.5;
                    const g = new THREE.SphereGeometry(r, 8, 6);
                    const c = new THREE.Color().setHSL(0.28 + Math.random()*0.08, 0.6, 0.35+Math.random()*0.2);
                    const m = new THREE.MeshLambertMaterial({ color: c });
                    const bush = new THREE.Mesh(g,m);
                    const ang = Math.random()*Math.PI*2;
                    const dist = Math.random()*8;
                    bush.position.set(x + Math.cos(ang)*dist, -50 + r*0.5, z + Math.sin(ang)*dist);
                    bush.castShadow = true;
                    this.scene.add(bush);
                }
            }

            createRocks(count){
                for (let i=0;i<count;i++){
                    const s = 3 + Math.random()*10;
                    const g = new THREE.DodecahedronGeometry(s, 0);
                    const col = new THREE.Color().setHSL(0.08 + Math.random()*0.05, 0.2, 0.25 + Math.random()*0.2);
                    const m = new THREE.MeshLambertMaterial({ color: col });
                    const rock = new THREE.Mesh(g,m);
                    rock.position.set((Math.random()-0.5)*7600, -50 + s*0.5, (Math.random()-0.5)*7600);
                    rock.rotation.y = Math.random()*Math.PI*2;
                    rock.castShadow = true;
                    this.scene.add(rock);
                }
            }

            createGrassPatches(count){
                for (let i=0;i<count;i++){
                    const blades = new THREE.Group();
                    const baseX = (Math.random()-0.5)*7600;
                    const baseZ = (Math.random()-0.5)*7600;
                    const bladeCount = 4 + Math.random()*6;
                    for (let b=0;b<bladeCount;b++){
                        const h = 4 + Math.random()*6;
                        const geo = new THREE.CylinderGeometry(0.05,0.25,h,4,1);
                        const mat = new THREE.MeshLambertMaterial({ color: 0x3c8d1e });
                        const blade = new THREE.Mesh(geo,mat);
                        blade.position.set((Math.random()-0.5)*3, -50 + h/2, (Math.random()-0.5)*3);
                        blade.rotation.x = (Math.random()-0.5)*0.4;
                        blade.rotation.z = (Math.random()-0.5)*0.4;
                        blades.add(blade);
                    }
                    blades.position.set(baseX,0,baseZ);
                    this.scene.add(blades);
                }
            }

            createBirdFlock(){
                const flock = new THREE.Group();
                const count = 12 + Math.floor(Math.random()*8);
                for (let i=0;i<count;i++){
                    const geo = new THREE.ConeGeometry(1.2,3,4);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                    const bird = new THREE.Mesh(geo,mat);
                    bird.rotation.x = Math.PI/2;
                    bird.position.set((Math.random()-0.5)*30,(Math.random()-0.5)*10,(Math.random()-0.5)*30);
                    flock.add(bird);
                }
                flock.position.set((Math.random()-0.5)*6000,150 + Math.random()*250,(Math.random()-0.5)*6000);
                flock.userData = { speed: 20 + Math.random()*15, dir: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize() };
                this.scene.add(flock);
                if(!this.flocks) this.flocks=[];
                this.flocks.push(flock);
            }

            updateFlocks(delta){
                if(!this.flocks) return;
                this.flocks.forEach(f=>{
                    f.position.addScaledVector(f.userData.dir, f.userData.speed*delta);
                    f.position.y += Math.sin(Date.now()*0.001 + f.position.x*0.01)*0.2;
                    const limit = 4000;
                    if (f.position.x > limit) f.position.x = -limit;
                    if (f.position.x < -limit) f.position.x = limit;
                    if (f.position.z > limit) f.position.z = -limit;
                    if (f.position.z < -limit) f.position.z = limit;
                });
            }

            createSoilPatches(count){
                for (let i=0;i<count;i++){
                    const r = 40 + Math.random()*120;
                    const geo = new THREE.CircleGeometry(r, 24);
                    const posAttr = geo.attributes.position;
                    for (let v=0; v<posAttr.count; v++) { // 轻微扰动边缘
                        if (v===0) continue;
                        const x = posAttr.getX(v); const y = posAttr.getY(v);
                        const dist = Math.hypot(x,y);
                        const factor = 1 + (Math.random()-0.5)*0.25;
                        posAttr.setX(v, x * factor);
                        posAttr.setY(v, y * factor);
                    }
                    posAttr.needsUpdate = true;
                    const colors = [0x7b5e31,0x6b4a1f,0xa07547,0x8a6235];
                    const mat = new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random()*colors.length)], side: THREE.DoubleSide, opacity: 0.92, transparent: true });
                    const patch = new THREE.Mesh(geo, mat);
                    patch.rotation.x = -Math.PI/2;
                    patch.position.set((Math.random()-0.5)*7600, -49.9, (Math.random()-0.5)*7600);
                    patch.receiveShadow = true;
                    this.scene.add(patch);
                }
            }

            // ================= Tanks =================
            getGroundHeight(x,z){
                if(!this.ground) return -50;
                this.raycaster.set(new THREE.Vector3(x, 500, z), new THREE.Vector3(0,-1,0));
                const hit = this.raycaster.intersectObject(this.ground, false);
                return hit.length ? hit[0].point.y : -50;
            }

            alignTankToGround(group){
                // 计算履带/底座假定基准：我们将 group 的局部原点视为底座中心高度 (approx hull center -2.5)
                // 使用射线获得真实地面，然后设置 group.position.y 使底面离地面略微“悬空” 0.4
                const gY = this.getGroundHeight(group.position.x, group.position.z);
                // 由于 hull.position.y = -50 + 2.5 (在构造中)，group.position.y 初始为 0 时 hull 底部在 -50
                // 因此当 group.position.y 偏移 d 时，底部 = -50 + d
                // 我们希望底部 = gY + 4.0 （抬离地面 4 单位）
                const desiredBottom = gY + 4.0;
                const d = desiredBottom - (-50);
                group.position.y = d;
            }
            createTanks(count=10){
                for (let i=0;i<count;i++) {
                    const x = (Math.random()-0.5)*7000;
                    const z = (Math.random()-0.5)*7000;
                    // 避免离玩家出生点太近
                    if (Math.hypot(x, z) < 400) { i--; continue; }
                    const tank = this.createTank(x, z);
                    this.tanks.push(tank);
                }
                // 创建后统一对齐一次（冗余安全）
                this.tanks.forEach(t=> this.alignTankToGround(t.mesh));
            }

            createTank(x,z){
                const group = new THREE.Group();
                const palette = [0x4d5a34,0x556b2f,0x6e5b2e,0x5c6133];
                const baseColor = palette[Math.floor(Math.random()*palette.length)];
                const baseMat = new THREE.MeshStandardMaterial({ color: baseColor, metalness:0.25, roughness:0.75 });

                // === 矩形底座 (narrower & taller) ===
                const hullWidth = 24; // narrower (was 30)
                const hullHeight = 8; // taller (was 5)
                const hullLength = 46;
                const hull = new THREE.Mesh(new THREE.BoxGeometry(hullWidth, hullHeight, hullLength), baseMat);
                hull.position.y = -50 + hullHeight/2;
                hull.castShadow = true; hull.receiveShadow = true;
                group.add(hull);

                // === 履带与5个负重轮（每侧） ===
                const trackMat = new THREE.MeshStandardMaterial({ color:0x1d1d1d, roughness:0.95 });
                for (let side of [-1,1]){
                    const track = new THREE.Mesh(new THREE.BoxGeometry(4, hullHeight-1.8, hullLength), trackMat);
                    track.position.set(side*(hullWidth/2+3.2), -50 + (hullHeight-1.8)/2, 0);
                    track.castShadow = true; group.add(track);
                }
                const wheelGeo = new THREE.CylinderGeometry(2.4,2.4,1.4,18);
                const wheelMat = new THREE.MeshStandardMaterial({ color:0x3a3a3a, metalness:0.4, roughness:0.6 });
                const wheelZs = [-14,-7,0,7,14];
                for (let side of [-1,1]){
                    wheelZs.forEach(zv=>{
                        const w = new THREE.Mesh(wheelGeo, wheelMat);
                        w.rotation.z = Math.PI/2;
                        w.position.set(side*(hullWidth/2+3.2), -50 + 1.6, zv);
                        group.add(w);
                    });
                }

                // === 圆柱炮塔 ===
                const turretHeight = 9; // 增高炮塔 (原 4 -> 7 -> 9)
                const turret = new THREE.Mesh(new THREE.CylinderGeometry(10,10,turretHeight,24), baseMat);
                const turretY = -50 + 2.5 + 2.5 + turretHeight/2; // 底座顶面 + 炮塔一半高度 (仍使用旧底盘高度逻辑)
                turret.position.set(0, turretY, 0);
                turret.castShadow = true; turret.receiveShadow = true;
                group.add(turret);
                // === 顶部舱门（圆形圆柱，高度2 半径2） ===
                const hatchGeo = new THREE.CylinderGeometry(2,2,2,24);
                const hatchMat = new THREE.MeshStandardMaterial({ color: baseColor });
                const hatch = new THREE.Mesh(hatchGeo, hatchMat);
                hatch.position.set(0, turretY + turretHeight/2 + 1, 0); // 放在炮塔顶部正中
                hatch.castShadow = true; hatch.receiveShadow = true;
                group.add(hatch);

                // === 主武器或防空机枪配置 ===
                const aaVariant = Math.random() < 0.30; // 30% 防空坦克
                if (!aaVariant) {
                    // 常规炮管（从炮塔中心 35° 抬起）
                    const gunPivot = new THREE.Group();
                    gunPivot.position.set(0, turretY, 0);
                    group.add(gunPivot);
                    const barrelMat = new THREE.MeshStandardMaterial({ color:0x2d2d2d, metalness:0.6, roughness:0.45 });
                    const barrelLength = 26;
                    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.85,barrelLength,18), barrelMat);
                    barrel.rotation.x = Math.PI/2;
                    barrel.position.z = barrelLength/2 + 2;
                    gunPivot.add(barrel);
                    const inner = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,2,12), new THREE.MeshStandardMaterial({ color:0x050505, metalness:0.3, roughness:0.9 }));
                    inner.rotation.x = Math.PI/2;
                    inner.position.z = barrelLength + 2;
                    gunPivot.add(inner);
                    gunPivot.rotation.x = -THREE.MathUtils.degToRad(35);
                } else {
                    // 防空型：四联机枪塔
                    const mgGroup = new THREE.Group();
                    mgGroup.position.set(0, turretY + turretHeight/2 * 0.2, 0);
                    const mount = new THREE.Mesh(new THREE.CylinderGeometry(2.4,2.6,2.2,16), new THREE.MeshStandardMaterial({ color: baseColor*0.9, metalness:0.4, roughness:0.6 }));
                    mount.castShadow = true; mgGroup.add(mount);
                    const gunMat = new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.55, roughness:0.35 });
                    const tubeGeo = new THREE.CylinderGeometry(0.35,0.35,17,10); // 加长3
                    const muzzleGeo = new THREE.CylinderGeometry(0.18,0.18,0.9,10);
                    const offsets = [ [-0.9,0.5], [0.9,0.5], [-0.9,-0.5], [0.9,-0.5] ];
                    offsets.forEach(([ox,oy])=>{
                        const tube = new THREE.Mesh(tubeGeo, gunMat);
                        tube.rotation.x = Math.PI/2;
                        tube.position.set(ox, oy, 6.5 + 1.5); // 前移以保持后端位置近似不变
                        tube.castShadow = true;
                        mgGroup.add(tube);
                        const muzzle = new THREE.Mesh(muzzleGeo, gunMat);
                        muzzle.rotation.x = Math.PI/2;
                        muzzle.position.set(ox, oy, 13.2 + 1.5); // 与机枪加长匹配
                        mgGroup.add(muzzle);
                    });
                    // 轻微仰角
                    mgGroup.rotation.x = -THREE.MathUtils.degToRad(10);
                    group.add(mgGroup);
                    group.userData.aa = true; // 标记防空
                }

                // === 红色高亮指示箭头（保持） ===
                const arrowGroup = new THREE.Group();
                const arrowMat = new THREE.MeshBasicMaterial({ color:0xff2222 });
                const cone = new THREE.Mesh(new THREE.ConeGeometry(3.2,9,18), arrowMat);
                cone.rotation.x = Math.PI; // 指向下
                arrowGroup.add(cone);
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,4.5,12), arrowMat);
                stem.position.y = -6.5;
                arrowGroup.add(stem);
                arrowGroup.position.set(0, turretY + 12, 0);
                arrowGroup.userData = { pulsePhase: Math.random()*Math.PI*2 };
                group.add(arrowGroup);

                group.position.set(x,0,z);
                // 贴合地面高度
                this.alignTankToGround(group);
                this.scene.add(group);
                return { mesh: group, alive: true, radius: 16, indicator: arrowGroup };
            }

            updateTankIndicators(delta){
                const t = performance.now()*0.001;
                // Tanks
                if(this.tanks){
                    this.tanks.forEach(tank=>{
                        if(!tank.alive) { if(tank.indicator) tank.indicator.visible=false; return; }
                        if(tank.indicator){
                            tank.indicator.visible = true;
                            tank.indicator.lookAt(this.camera.position);
                            const phase = t*4 + (tank.indicator.userData.pulsePhase||0);
                            const s = 1 + Math.sin(phase)*0.25;
                            tank.indicator.scale.set(s,s,s);
                        }
                    });
                }
                // Warships
                if(this.warships){
                    this.warships.forEach(ship=>{
                        if(!ship.alive) { if(ship.indicator) ship.indicator.visible=false; return; }
                        if(ship.indicator){
                            ship.indicator.visible = true;
                            ship.indicator.lookAt(this.camera.position);
                            const phase = t*4 + (ship.indicator.userData.pulsePhase||0);
                            const s = 1 + Math.sin(phase)*0.25;
                            ship.indicator.scale.set(s,s,s);
                        }
                    });
                }
            }

            createExplosion(position){
                const group = new THREE.Group();
                group.position.copy(position);
                this.scene.add(group);
                // 静态火花 + 原地燃烧火焰
                const flameCount = 26;
                for (let i=0;i<flameCount;i++) {
                    const size = 0.9 + Math.random()*1.4;
                    const geo = new THREE.SphereGeometry(size, 6, 6);
                    const col = 0xffa533;
                    const mat = new THREE.MeshBasicMaterial({ color: col, transparent:true, opacity:1 });
                    const p = new THREE.Mesh(geo, mat);
                    // 静止：dir = 0
                    p.userData = { dir: new THREE.Vector3(0,0,0), life: 0.65 + Math.random()*0.5, age:0, flame:true };
                    // 随机分布在爆心轻微半径内
                    const ang = Math.random()*Math.PI*2; const rad = Math.random()*3.2;
                    p.position.set(Math.cos(ang)*rad, Math.random()*2, Math.sin(ang)*rad);
                    group.add(p);
                }
                // 轻烟向上（很慢，几乎原地）
                for (let i=0;i<12;i++) {
                    const geo = new THREE.SphereGeometry(2+Math.random()*2.5, 8,6);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x2b2b2b, transparent:true, opacity:0.55 });
                    const s = new THREE.Mesh(geo, mat);
                    s.userData = { dir: new THREE.Vector3(0, (0.15+Math.random()*0.25), 0), life: 2.2 + Math.random()*0.8, age:0, smoke:true };
                    const ang = Math.random()*Math.PI*2; const rad = Math.random()*2.5;
                    s.position.set(Math.cos(ang)*rad, 0.4+Math.random()*1.2, Math.sin(ang)*rad);
                    group.add(s);
                }
                const animate = () => {
                    const dt = 0.016;
                    group.children.forEach(c=>{
                        if (!c.userData) return;
                        c.userData.age += dt;
                        const ratio = c.userData.age / c.userData.life;
                        // 仅烟缓慢上升
                        if (c.userData.smoke) c.position.add(c.userData.dir.clone().multiplyScalar(dt));
                        if (c.material) {
                            if (c.userData.flame) {
                                c.material.opacity = Math.max(0, 1 - ratio*1.2);
                                c.scale.multiplyScalar(1 + dt*0.8);
                            } else if (c.userData.smoke) {
                                c.material.opacity = Math.max(0, 0.55 * (1 - ratio));
                                c.scale.multiplyScalar(1 + dt*0.35);
                            }
                        }
                    });
                    // 清理
                    for (let i=group.children.length-1;i>=0;i--) {
                        const ch = group.children[i];
                        if (ch.userData && ch.userData.age >= ch.userData.life) {
                            group.remove(ch); ch.geometry.dispose(); ch.material.dispose();
                        }
                    }
                    if (group.children.length>0) requestAnimationFrame(animate); else this.scene.remove(group);
                };
                animate();
            }

            createScorchMark(x,z){
                const r = 18 + Math.random()*6;
                const geo = new THREE.CircleGeometry(r, 20);
                const mat = new THREE.MeshBasicMaterial({ color: 0x1d1b1a, transparent:true, opacity:0.55, side:THREE.DoubleSide });
                const m = new THREE.Mesh(geo, mat);
                m.rotation.x = -Math.PI/2;
                m.position.set(x, -49.8, z);
                this.scene.add(m);
                // 渐隐
                const start = performance.now();
                const fade = () => {
                    const t = (performance.now()-start)/8000;
                    if (t<1) {
                        mat.opacity = 0.55*(1-t);
                        requestAnimationFrame(fade);
                    } else {
                        this.scene.remove(m); geo.dispose(); mat.dispose();
                    }
                };
                requestAnimationFrame(fade);
            }

            // （公路系统已移除）

            createBuildings() {
                // 创建城镇区域
                this.createTownArea(-800, -800, 600, 600); // 主城区
                this.createTownArea(1200, 800, 400, 400);  // 小镇1
                this.createTownArea(-1500, 1000, 300, 300); // 小镇2
                
                // 创建一些独立建筑
                for (let i = 0; i < 50; i++) {
                    const x = (Math.random() - 0.5) * 6000;
                    const z = (Math.random() - 0.5) * 6000;
                    this.createRandomBuilding(x, z);
                }
            }

            createTownArea(centerX, centerZ, width, depth) {
                const buildingsPerRow = 6;
                const spacing = Math.min(width, depth) / buildingsPerRow;
                
                for (let i = 0; i < buildingsPerRow; i++) {
                    for (let j = 0; j < buildingsPerRow; j++) {
                        const x = centerX + (i - buildingsPerRow/2) * spacing + (Math.random() - 0.5) * 20;
                        const z = centerZ + (j - buildingsPerRow/2) * spacing + (Math.random() - 0.5) * 20;
                        this.createRandomBuilding(x, z, true); // 城镇建筑更大
                    }
                }
            }

            createRandomBuilding(x, z, isTown = false) {
                const buildingGroup = new THREE.Group();
                
                // 建筑尺寸
                const width = isTown ? 20 + Math.random() * 30 : 10 + Math.random() * 15;
                const depth = isTown ? 20 + Math.random() * 30 : 10 + Math.random() * 15;
                const height = isTown ? 30 + Math.random() * 80 : 15 + Math.random() * 25;
                
                // 主建筑
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingColors = [0x8B7355, 0xA0522D, 0x696969, 0x778899, 0xDC143C]; // 各种建筑颜色
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)]
                });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.y = height / 2 - 50;
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);
                
                // 屋顶
                const roofGeometry = new THREE.ConeGeometry(
                    Math.max(width, depth) * 0.7, 
                    height * 0.3, 
                    4
                );
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B0000 // 红色屋顶
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = height - 50 + height * 0.15;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                buildingGroup.add(roof);
                
                // 随机添加窗户（简单的黄色方块）
                if (isTown) {
                    for (let i = 0; i < 8; i++) {
                        const windowGeometry = new THREE.PlaneGeometry(3, 4);
                        const windowMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00, // 黄色窗户（灯光）
                            transparent: true,
                            opacity: 0.8
                        });
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            (Math.random() - 0.5) * width * 0.8,
                            (Math.random() - 0.3) * height - 50,
                            width / 2 + 0.1
                        );
                        buildingGroup.add(window);
                    }
                }
                
                buildingGroup.position.set(x, 0, z);
                this.scene.add(buildingGroup);
            }

            showAnimationControls() {
                if (!this.modelAnimations || this.modelAnimations.length === 0) return;
                
                // 创建动画控制面板
                const controlPanel = document.createElement('div');
                controlPanel.id = 'animationControls';
                controlPanel.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 15px;
                    border-radius: 10px;
                    font-family: monospace;
                    z-index: 1000;
                    max-width: 250px;
                `;
                
                controlPanel.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #00ff00;">✈️ Animation Controls</h4>
                    <div id="animationList"></div>
                    <button id="playAllAnimations" style="margin-top: 10px; width: 100%;">▶️ Play All</button>
                    <button id="stopAllAnimations" style="margin-top: 5px; width: 100%;">⏹️ Stop All</button>
                `;
                
                const animationList = controlPanel.querySelector('#animationList');
                
                // 为每个动画创建控制按钮
                this.modelAnimations.forEach((clip, index) => {
                    const animDiv = document.createElement('div');
                    animDiv.style.cssText = 'margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                    
                    animDiv.innerHTML = `
                        <div style="font-size: 12px; color: #00ffff;">${clip.name || `Animation ${index + 1}`}</div>
                        <div style="font-size: 10px; color: #888;">Duration: ${clip.duration.toFixed(1)}s</div>
                        <button class="playAnim" data-index="${index}" style="font-size: 10px; margin-top: 3px;">▶️ Play</button>
                        <button class="pauseAnim" data-index="${index}" style="font-size: 10px; margin-left: 5px;">⏸️ Pause</button>
                    `;
                    
                    animationList.appendChild(animDiv);
                });
                
                // 添加事件监听器
                controlPanel.querySelector('#playAllAnimations').addEventListener('click', () => {
                    this.activeAnimations.forEach(action => action.play());
                });
                
                controlPanel.querySelector('#stopAllAnimations').addEventListener('click', () => {
                    this.activeAnimations.forEach(action => action.stop());
                });
                
                // 单个动画控制
                controlPanel.querySelectorAll('.playAnim').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (this.activeAnimations[index]) {
                            this.activeAnimations[index].play();
                        }
                    });
                });
                
                controlPanel.querySelectorAll('.pauseAnim').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (this.activeAnimations[index]) {
                            this.activeAnimations[index].paused = !this.activeAnimations[index].paused;
                        }
                    });
                });
                
                document.body.appendChild(controlPanel);
                
                // 3秒后自动淡化控制面板
                setTimeout(() => {
                    if (controlPanel.parentNode) {
                        controlPanel.style.opacity = '0.3';
                    }
                }, 3000);
            }

            setupFileUpload() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('glbUpload');
                
                // File input change
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        this.loadGLBModel(file);
                    }
                });
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#4CAF50';
                    uploadArea.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                });
                
                uploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '';
                    uploadArea.style.backgroundColor = '';
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '';
                    uploadArea.style.backgroundColor = '';
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        if (file.name.toLowerCase().endsWith('.glb') || file.name.toLowerCase().endsWith('.gltf')) {
                            this.loadGLBModel(file);
                        } else {
                            this.showNotification('Please drop a GLB or GLTF file', 'error');
                        }
                    }
                });
            }

            loadGLBModel(file) {
                this.showNotification('Loading aircraft model...', 'success');
                
                const loader = new GLTFLoader();
                const url = URL.createObjectURL(file);
                
                loader.load(url, (gltf) => {
                    // Remove existing aircraft if loaded model exists
                    if (this.loadedModel) {
                        this.scene.remove(this.loadedModel);
                        // 清理旧的动画混合器
                        if (this.modelAnimationMixer) {
                            this.modelAnimationMixer.stopAllAction();
                            this.modelAnimationMixer = null;
                        }
                    } else if (this.aircraft) {
                        this.scene.remove(this.aircraft);
                    }
                    
                    const model = gltf.scene;
                    
                    // === 动画系统设置 ===
                    this.modelAnimations = gltf.animations; // 存储动画数据
                    this.modelAnimationMixer = null;
                    this.activeAnimations = []; // 存储当前播放的动画
                    
                    // 如果模型包含动画，创建动画混合器
                    if (gltf.animations && gltf.animations.length > 0) {
                        this.modelAnimationMixer = new THREE.AnimationMixer(model);
                        
                        console.log(`Found ${gltf.animations.length} animations:`, gltf.animations.map(anim => anim.name));
                        
                        // 自动播放所有动画（通常用于螺旋桨、引擎等循环动画）
                        gltf.animations.forEach((clip, index) => {
                            const action = this.modelAnimationMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            action.clampWhenFinished = false;
                            
                            // 自动识别动画类型
                            const animName = clip.name.toLowerCase();
                            if (animName.includes('propeller') || 
                                animName.includes('rotor') || 
                                animName.includes('engine') ||
                                animName.includes('fan') ||
                                animName.includes('spin')) {
                                // 快速循环动画（螺旋桨等）
                                action.timeScale = 2.0; // 2倍速度
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing fast animation: ${clip.name}`);
                            } else if (animName.includes('idle') || 
                                      animName.includes('loop') ||
                                      clip.duration > 10) {
                                // 慢速循环动画
                                action.timeScale = 1.0;
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing slow animation: ${clip.name}`);
                            } else {
                                // 其他动画默认也播放
                                action.timeScale = 1.0;
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing animation: ${clip.name}`);
                            }
                        });
                        
                        this.showNotification(`Aircraft loaded with ${gltf.animations.length} animations!`, 'success');
                    } else {
                        this.showNotification('Aircraft loaded (no animations found)', 'success');
                    }
                    
                    // Calculate model bounding box to determine appropriate scale
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    
                    // Target size should be similar to default aircraft (wingspan ~18, length ~14)
                    const targetSize = 18; // Target wingspan/length
                    const currentMaxSize = Math.max(size.x, size.y, size.z);
                    const scaleRatio = targetSize / currentMaxSize;
                    
                    // Apply calculated scale (minimum 15x for very small models) and additional 1.5x multiplier
                    const finalScale = Math.max(scaleRatio, 15) * 1.5;
                    model.scale.set(finalScale, finalScale, finalScale);
                    
                    // Enhance materials for better lighting
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        this.enhanceMaterial(mat);
                                    });
                                } else {
                                    this.enhanceMaterial(child.material);
                                }
                            }
                        }
                    });
                    
                    model.position.copy(this.playerPosition);
                    this.loadedModel = model;
                    this.aircraft = model;
                    this.scene.add(model);
                    
                    // 显示动画控制面板（如果有动画）
                    if (gltf.animations && gltf.animations.length > 0) {
                        // 移除旧的控制面板
                        const oldPanel = document.getElementById('animationControls');
                        if (oldPanel) oldPanel.remove();
                        
                        // 显示新的动画控制面板
                        setTimeout(() => this.showAnimationControls(), 500);
                    }
                    
                    URL.revokeObjectURL(url);
                    
                }, undefined, (error) => {
                    console.error('Error loading GLB model:', error);
                    this.showNotification('Failed to load aircraft model', 'error');
                    URL.revokeObjectURL(url);
                });
            }

            enhanceMaterial(material) {
                // === 轻微增亮过暗材质 ===
                if (material.color && material.color.r + material.color.g + material.color.b < 0.3) {
                    material.color.multiplyScalar(1.5); // 降低到1.5倍，避免过曝
                }
                
                // === 适度优化PBR材质属性 ===
                if (material.metalness !== undefined) {
                    material.metalness = Math.min(material.metalness + 0.2, 0.6); // 适度增加金属度
                }
                if (material.roughness !== undefined) {
                    material.roughness = Math.max(material.roughness - 0.1, 0.4); // 适度降低粗糙度
                }
                
                // === 移除自发光效果 ===
                // 不添加自发光，使用自然光照
                
                // === 适度环境光响应 ===
                if (material.envMapIntensity !== undefined) {
                    material.envMapIntensity = 1.0; // 降低到1.0，自然反射
                }
                
                // === 确保材质响应光照 ===
                material.needsUpdate = true;
                
                // === 适度提升极暗材质 ===
                if (material.color && material.color.getHSL({}).l < 0.15) {
                    // 仅对极暗材质进行轻微调整
                    const hsl = material.color.getHSL({});
                    material.color.setHSL(hsl.h, hsl.s, Math.max(hsl.l, 0.2)); // 最低20%亮度
                }
            }

            setupKeyboardControls() {
                document.addEventListener('keydown', (event) => {
                    this.inputState.keys.add(event.code);
                });
                
                document.addEventListener('keyup', (event) => {
                    this.inputState.keys.delete(event.code);
                });
            }

            updateInputFromKeyboard(deltaTime) {
                const keys = this.inputState.keys;
                const turnSpeed = 1.5; // radians per second
                const pitchSpeed = 1.0; // radians per second  
                const speedChangeRate = 0.8; // speed change per second

                // Yaw controls (left/right turns)
                if (keys.has('KeyA') || keys.has('ArrowLeft')) {
                    this.inputState.yaw += turnSpeed * deltaTime;
                }
                if (keys.has('KeyD') || keys.has('ArrowRight')) {
                    this.inputState.yaw -= turnSpeed * deltaTime;
                }

                // Pitch controls (nose up/down)
                if (keys.has('KeyW') || keys.has('ArrowUp')) {
                    this.inputState.pitch = Math.min(this.inputState.pitch + pitchSpeed * deltaTime, Math.PI / 4);
                }
                if (keys.has('KeyS') || keys.has('ArrowDown')) {
                    this.inputState.pitch = Math.max(this.inputState.pitch - pitchSpeed * deltaTime, -Math.PI / 4);
                }

                // Roll controls (banking) - 允许360度翻转
                if (keys.has('KeyQ')) {
                    this.inputState.roll -= turnSpeed * deltaTime; // 移除限制，允许无限翻转
                } else if (keys.has('KeyE')) {
                    this.inputState.roll += turnSpeed * deltaTime; // 移除限制，允许无限翻转
                } else {
                    // Auto-level roll - 仅在接近水平时自动调平
                    const levelingSpeed = 2.0;
                    // 计算到最近的水平位置的距离
                    const normalizedRoll = ((this.inputState.roll % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                    let targetRoll = 0;
                    if (normalizedRoll > Math.PI) {
                        targetRoll = Math.PI * 2;
                    }
                    const rollDiff = Math.abs(normalizedRoll - targetRoll);
                    
                    // 只有在接近水平位置时才自动调平
                    if (rollDiff < Math.PI / 6) { // 30度范围内
                        if (Math.abs(this.inputState.roll) > 0.01) {
                            this.inputState.roll = THREE.MathUtils.lerp(this.inputState.roll, Math.round(this.inputState.roll / (Math.PI * 2)) * Math.PI * 2, deltaTime * levelingSpeed);
                        } else {
                            this.inputState.roll = Math.round(this.inputState.roll / (Math.PI * 2)) * Math.PI * 2;
                        }
                    }
                }

                // Speed controls
                if (keys.has('ShiftLeft') || keys.has('ShiftRight') || keys.has('Space')) {
                    this.inputState.speed = Math.min(this.inputState.speed + speedChangeRate * deltaTime, 1.0);
                }
                if (keys.has('ControlLeft') || keys.has('ControlRight') || keys.has('KeyX')) {
                    this.inputState.speed = Math.max(this.inputState.speed - speedChangeRate * deltaTime, 0.2);
                }

                // Auto-level pitch when no input
                if (!keys.has('KeyW') && !keys.has('KeyS') && 
                    !keys.has('ArrowUp') && !keys.has('ArrowDown')) {
                    const levelingSpeed = 2.0;
                    if (Math.abs(this.inputState.pitch) > 0.01) {
                        this.inputState.pitch = THREE.MathUtils.lerp(this.inputState.pitch, 0, deltaTime * levelingSpeed);
                    } else {
                        this.inputState.pitch = 0;
                    }
                }

                // Weather toggle
                if (keys.has('KeyR')) {
                    if (!this.rKeyPressed) {
                        this.toggleWeather();
                        this.rKeyPressed = true;
                    }
                } else {
                    this.rKeyPressed = false;
                }
            }

            updatePlayer(deltaTime) {
                if (!this.aircraft) return;

                // Update input from keyboard
                this.updateInputFromKeyboard(deltaTime);

                // Update speed based on input
                const maxSpeed = 120; // Maximum speed
                const targetSpeed = Math.max(this.inputState.speed * maxSpeed, 30); // Minimum 30 for flight
                this.playerSpeed = THREE.MathUtils.lerp(this.playerSpeed, targetSpeed, deltaTime * 2);

                // Calculate forward direction based on pitch and yaw
                const forward = new THREE.Vector3(0, 0, 1); // +Z is forward for our aircraft
                const rotation = new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll);
                forward.applyEuler(rotation);

                // Apply constant thrust in forward direction (this ensures the plane always moves forward)
                const thrust = forward.clone().multiplyScalar(this.playerSpeed);
                this.playerVelocity.copy(thrust); // Set velocity directly to thrust direction and speed

                // Apply lift when flying forward (simple aerodynamics)
                if (this.playerSpeed > 40) {
                    const liftStrength = Math.min(this.playerSpeed / 80, 1.0);
                    const liftDirection = new THREE.Vector3(0, 1, 0); // Upward
                    const lift = liftDirection.multiplyScalar(liftStrength * 25 * deltaTime);
                    this.playerVelocity.add(lift);
                }

                // Apply gravity
                const gravity = new THREE.Vector3(0, -30, 0);
                this.playerVelocity.add(gravity.multiplyScalar(deltaTime));

                // Light air resistance (much reduced)
                this.playerVelocity.multiplyScalar(1 - 0.1 * deltaTime);

                // Update position
                this.playerPosition.add(this.playerVelocity.clone().multiplyScalar(deltaTime));

                // === INFINITE LOOPING WORLD SYSTEM ===
                const worldBoundary = 4000; // 8000x8000地形的边界（从中心到边缘4000单位）
                let worldWrapped = false;
                
                // X轴边界检查
                if (this.playerPosition.x > worldBoundary) {
                    this.playerPosition.x = -worldBoundary + 1;
                    worldWrapped = true;
                } else if (this.playerPosition.x < -worldBoundary) {
                    this.playerPosition.x = worldBoundary - 1;
                    worldWrapped = true;
                }
                
                // Z轴边界检查
                if (this.playerPosition.z > worldBoundary) {
                    this.playerPosition.z = -worldBoundary + 1;
                    worldWrapped = true;
                } else if (this.playerPosition.z < -worldBoundary) {
                    this.playerPosition.z = worldBoundary - 1;
                    worldWrapped = true;
                }
                
                // 显示循环世界提示消息
                if (worldWrapped) {
                    this.showWrapMessage();
                }

                // Keep aircraft above ground
                if (this.playerPosition.y < 10) {
                    this.playerPosition.y = 10;
                    this.playerVelocity.y = Math.max(this.playerVelocity.y, 0);
                    this.playerVelocity.multiplyScalar(0.7); // Bounce damping
                }

                // Update aircraft position and rotation
                this.aircraft.position.copy(this.playerPosition);
                
                // Set aircraft rotation based on flight controls
                this.aircraft.rotation.set(
                    this.inputState.pitch,
                    this.inputState.yaw, 
                    this.inputState.roll
                );

                // === 移除动态光照跟踪，使用自然光照 ===
                // 不再需要专用光源跟随飞机

                // Update propeller animation
                this.updatePropeller(deltaTime);
                // bird flocks removed
            }

            updateCamera() {
                if (!this.aircraft) return;
                
                // Third-person camera following aircraft
                const distance = 80;
                const height = 30;
                
                // Calculate aircraft forward direction
                const forward = new THREE.Vector3(0, 0, 1);
                const rotation = new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll);
                forward.applyEuler(rotation);
                
                // Position camera behind and above aircraft
                const cameraOffset = forward.clone().multiplyScalar(-distance);
                cameraOffset.y += height;
                
                const targetPosition = this.playerPosition.clone().add(cameraOffset);
                
                // Smooth camera movement
                this.camera.position.lerp(targetPosition, 0.1);
                this.camera.lookAt(this.playerPosition);
            }

            updateClouds(deltaTime) {
                // Slowly move clouds
                this.clouds.forEach(cloud => {
                    cloud.position.x += Math.sin(Date.now() * 0.0001) * 0.1;
                    cloud.rotation.y += deltaTime * 0.1;
                });
            }

            hideLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                const progressFill = document.getElementById('progressFill');
                
                // Simulate loading progress
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 20;
                    if (progress >= 100) {
                        progress = 100;
                        progressFill.style.width = '100%';
                        
                        setTimeout(() => {
                            loadingScreen.style.opacity = '0';
                            loadingScreen.style.transition = 'opacity 1s ease';
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                            }, 1000);
                        }, 500);
                        
                        clearInterval(progressInterval);
                    }
                    progressFill.style.width = progress + '%';
                }, 100);
            }

            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification-${type}`;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }

            // === 场景切换 UI ===
            setupSceneSwitcher(){
                const id = 'sceneSwitcher';
                if (document.getElementById(id)) return; // 已存在
                const panel = document.createElement('div');
                panel.id = id;
                const scenes = [
                    { key:'default', label:'默认' },
                    { key:'snow', label:'雪地' },
                    { key:'desert', label:'沙漠' },
                    { key:'ocean', label:'海洋' }
                ];
                scenes.forEach(s => {
                    const btn = document.createElement('button');
                    btn.textContent = s.label;
                    if (this.sceneType === s.key) btn.classList.add('active');
                    btn.addEventListener('click', ()=>{
                        if (this.sceneType === s.key) return;
                        // 更新 URL hash 但不强制刷新
                        if (s.key==='default') {
                            history.replaceState(null,'', window.location.pathname + window.location.search);
                        } else {
                            history.replaceState(null,'', '#'+s.key);
                        }
                        this.switchSceneType(s.key);
                        // 更新按钮状态
                        panel.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
                        btn.classList.add('active');
                        this.showNotification('切换到场景: '+s.label, 'success');
                    });
                    panel.appendChild(btn);
                });
                document.body.appendChild(panel);
            }

            // 动态切换场景（不刷新页面 / 不显示蓝色加载）
            switchSceneType(newType){
                if (!['default','snow','desert','ocean'].includes(newType)) return;
                if (this.sceneType === newType) return;
                const prevScene = this.scene;
                this.sceneType = newType;
                // 保存飞机与相机状态
                const aircraft = this.aircraft;
                const playerPos = this.playerPosition.clone();
                const playerVel = this.playerVelocity.clone();
                // === 清理旧子节点（保留 renderer/camera/aircraft 引用即可） ===
                this.disposeOldScene(prevScene, aircraft);
                // 创建新场景
                const fogColors = { default:0x87CEEB, snow:0xdbe9f5, desert:0xe2c27b, ocean:0x6fb2ff };
                this.scene = new THREE.Scene();
                const fogColor = fogColors[this.sceneType] || 0x87CEEB;
                this.scene.fog = new THREE.Fog(fogColor, 100, 2000);
                this.renderer.setClearColor(fogColor,1);
                // 重新添加飞机
                if (aircraft) {
                    this.aircraft = aircraft;
                    this.aircraft.position.copy(playerPos);
                    this.scene.add(this.aircraft);
                }
                // 重置容器引用
                this.tanks = []; this.bullets = []; this.muzzleFlashes = [];
                // 保留触发结构，清空后会通过 createNoseCannons 重建
                this.gunBarrels = [];
                // 重建光照与地形
                this.setupLighting();
                this.environmentConfig = this.getEnvironmentConfig(this.sceneType);
                this.createTerrain();
                if (this.sceneType !== 'ocean') this.createClouds();
                // 重新添加机炮（若丢失）
                this.createNoseCannons();
                // 如果切换过程中按住鼠标仍保持射击状态
                if (this.isFiring) {
                    // 立即尝试一次发射以验证恢复
                    this.lastShotTime = 0; // 重置计时器允许马上开火
                }
                // 恢复玩家运动状态
                this.playerPosition.copy(playerPos);
                this.playerVelocity.copy(playerVel);
            }

            disposeOldScene(oldScene, aircraftKeep){
                if (!oldScene) return;
                oldScene.traverse(obj=>{
                    if (aircraftKeep && (obj===aircraftKeep || aircraftKeep.children.includes(obj))) return;
                    if (obj.isMesh) {
                        if (obj.geometry) obj.geometry.dispose();
                        if (Array.isArray(obj.material)) obj.material.forEach(m=>m && m.dispose && m.dispose());
                        else if (obj.material) obj.material.dispose();
                    }
                });
            }

            gameLoop() {
                const deltaTime = 0.016; // Approximately 60 FPS
                
                this.updatePlayer(deltaTime);
                this.updateCamera();
                this.updateClouds(deltaTime);
                this.updatePropeller(deltaTime);
                // Weapon updates
                this.tryFireGuns(deltaTime);
                this.updateBullets(deltaTime);
                this.updateTankIndicators(deltaTime);
                
                // === 更新GLB模型动画 ===
                if (this.modelAnimationMixer) {
                    const animationDelta = this.animationClock.getDelta();
                    this.modelAnimationMixer.update(animationDelta);
                }
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.gameLoop());
            }

            updatePropeller(deltaTime) {
                // Animate propeller spinning
                if (this.propeller) {
                    this.propeller.rotation.z += 30 * deltaTime; // Fast spinning around Z axis (forward motion)
                }
            }

            showWrapMessage() {
                // 防止消息过于频繁显示
                const currentTime = Date.now();
                if (currentTime - this.lastWrapMessageTime < 3000) return; // 3秒间隔
                
                this.lastWrapMessageTime = currentTime;
                
                // 创建提示消息
                const messages = [
                    "🌍 穿越至新的区域...",
                    "✈️ 飞向了星球的另一边",
                    "🗺️ 世界边缘传送中...",
                    "🌌 循环世界让你能无限探索"
                ];
                
                const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                
                // 显示临时消息
                const messageElement = document.createElement('div');
                messageElement.textContent = randomMessage;
                messageElement.style.cssText = `
                    position: fixed;
                    top: 20%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #00ff00;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-size: 18px;
                    font-family: 'Courier New', monospace;
                    z-index: 1000;
                    pointer-events: none;
                    animation: fadeInOut 3s ease-in-out;
                `;
                
                // 添加CSS动画
                if (!document.querySelector('#wrapMessageStyle')) {
                    const style = document.createElement('style');
                    style.id = 'wrapMessageStyle';
                    style.textContent = `
                        @keyframes fadeInOut {
                            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                            20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(messageElement);
                
                // 3秒后移除消息
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.parentNode.removeChild(messageElement);
                    }
                }, 3000);
            }
        }

        // Start the game
        const game = new SkyWarriors();
    </script>
</body>
</html>
