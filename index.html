<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Warriors - GLB Flight Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .loading-text {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar {
            width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        #glbUpload {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 14px;
        }

        #fileInput {
            margin-top: 10px;
            padding: 8px;
            border: 2px dashed #4CAF50;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
        }

        #fileInput:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 12px;
            max-width: 300px;
        }

        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            color: white;
            font-size: 16px;
            display: none;
            text-align: center;
        }

        .notification-success {
            border-left: 4px solid #4CAF50;
        }

        .notification-error {
            border-left: 4px solid #f44336;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loadingScreen">
            <div class="loading-text">SKY WARRIORS</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p style="margin-top: 20px; opacity: 0.8;">Loading 3D Environment...</p>
        </div>

        <div id="glbUpload">
            <h3>Load Your Aircraft</h3>
            <p>Drop a GLB file here or click to browse:</p>
            <input type="file" id="fileInput" accept=".glb,.gltf" />
        </div>

        <div id="instructions">
            <h4>Flight Controls:</h4>
            <p><strong>WASD / Arrow Keys:</strong> Pitch (W/S) and Yaw (A/D) controls</p>
            <p><strong>Q / E:</strong> Roll left/right (360° barrel rolls available!)</p>
            <p><strong>Shift / Space:</strong> Increase throttle</p>
            <p><strong>Ctrl / X:</strong> Decrease throttle</p>
            <p><strong>R:</strong> Toggle weather (Rain/Sunny)</p>
        </div>

        <div id="notification"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        class SkyWarriors {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.aircraft = null;
                this.loadedModel = null;
                
                // Player state
                this.playerPosition = new THREE.Vector3(0, 50, 0);
                this.playerVelocity = new THREE.Vector3(0, 0, 0);
                this.playerSpeed = 60; // Current speed in units/sec
                
                // Flight control state
                this.inputState = {
                    pitch: 0,    // Nose up/down rotation (-π/4 to π/4)
                    yaw: 0,      // Left/right turn rotation  
                    roll: 0,     // Banking rotation
                    speed: 0.6,  // Speed multiplier (0.2 to 1.0)
                    keys: new Set() // Currently pressed keys
                };

                // World wrapping system
                this.lastWrapMessageTime = 0;
                
                // === GLB动画系统 ===
                this.modelAnimationMixer = null;      // 动画混合器
                this.modelAnimations = [];            // 动画片段数组
                this.activeAnimations = [];           // 当前播放的动画
                this.animationClock = new THREE.Clock(); // 动画时钟
                
                // Terrain and environment
                this.terrain = [];
                this.clouds = [];
                // === Environment configuration ===
                this.environmentConfig = {
                    treeDensityMultiplier: 2.8, // increased density
                    rockCount: 0,               // removed rocks
                    grassPatchCount: 180,
                    bushClusterCount: 70,
                    birdFlocks: 0,              // removed bird flocks
                    soilPatchCount: 120
                };
                // === Combat targets ===
                this.tanks = []; // 静态坦克目标 { mesh, alive, radius }
                // Raycaster for ground height sampling
                this.raycaster = new THREE.Raycaster();
                // --- Weapon system state (nose cannons) ---
                this.isFiring = false;          // 是否按住射击
                this.lastShotTime = 0;          // 上次发射时间 (s)
                this.fireInterval = 0.08;       // 射速间隔 ~12.5发/秒
                this.bullets = [];              // 活跃子弹
                this.muzzleFlashes = [];        // 枪口火光
                this.gunBarrels = [];           // 炮口引用
                this.tempVec = new THREE.Vector3();
                this.forwardVec = new THREE.Vector3(0,0,1);
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupLighting();
                this.createTerrain();
                this.createClouds();
                this.createDefaultAircraft();
                this.createNoseCannons(); // 机头机炮
                this.setupFileUpload();
                this.setupKeyboardControls();
                this.setupMouseControls(); // 鼠标射击
                this.hideLoadingScreen();
                this.gameLoop();
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 2000);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.camera.position.set(0, 100, 200);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB, 1);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupLighting() {
                // === 自然环境光 - 模拟晴天柔和光照 ===
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // 降低到0.6，自然柔和
                this.scene.add(ambientLight);
                
                // === 自然太阳光 - 模拟真实晴天阳光 ===
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // 降低到1.0，自然强度
                directionalLight.position.set(100, 300, 100); // 保持自然角度
                directionalLight.castShadow = true;
                
                // 优化阴影质量
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 2000;
                directionalLight.shadow.camera.left = -1000;
                directionalLight.shadow.camera.right = 1000;
                directionalLight.shadow.camera.top = 1000;
                directionalLight.shadow.camera.bottom = -1000;
                directionalLight.shadow.bias = -0.0001;
                this.scene.add(directionalLight);
                
                // === 自然天空光 - 模拟天空散射光 ===
                const skyLight = new THREE.HemisphereLight(
                    0x87CEEB,  // 天空蓝色
                    0x5D8A3A,  // 地面绿色
                    0.4        // 降低到0.4，柔和天空光
                );
                skyLight.position.set(0, 500, 0);
                this.scene.add(skyLight);
                
                // === 移除过强的飞机专用聚光灯 ===
                // 不再添加专用聚光灯，使用自然光照
                
                // === 轻微补光系统 - 仅用于消除过暗阴影 ===
                const fillLights = [
                    { pos: [200, 100, 0], intensity: 0.2 },    // 右侧轻微补光
                    { pos: [-200, 100, 0], intensity: 0.2 },   // 左侧轻微补光
                    { pos: [0, 100, 200], intensity: 0.15 },   // 前方轻微补光
                    { pos: [0, 100, -200], intensity: 0.15 }   // 后方轻微补光
                ];
                
                fillLights.forEach(light => {
                    const fillLight = new THREE.DirectionalLight(0xffffff, light.intensity);
                    fillLight.position.set(light.pos[0], light.pos[1], light.pos[2]);
                    fillLight.castShadow = false; // 补光不产生阴影
                    this.scene.add(fillLight);
                });
                
                // === 移除GLB专用增强光 ===
                // 不再添加专用增强光，使用自然光照
            }

            createTerrain() {
                // Ground plane - 更绿更真实的草地颜色
                const groundGeometry = new THREE.PlaneGeometry(8000, 8000, 150, 150);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x5D8A3A, // 更鲜艳的草绿色，符合自然环境
                    wireframe: false
                });
                
                // Add some height variation to the ground
                const vertices = groundGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.random() * 15 - 7; // 减少地面起伏，更平坦
                }
                groundGeometry.attributes.position.needsUpdate = true;
                groundGeometry.computeVertexNormals();
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -50;
                ground.receiveShadow = true;
                this.scene.add(ground);
                // 保存地面引用用于高度采样
                this.ground = ground;
                
                // 创建多样化美丽的山脉系统
                this.createMountainRanges();

                // 创建自然环境元素
                this.createTrees();
                // 改为创建湖泊系统（移除河流和公路）
                this.createLakes();
                // 裸露土地斑块
                this.createSoilPatches(this.environmentConfig.soilPatchCount);
                // 岩石 / 草丛 / 灌木 / 鸟群
                if (this.environmentConfig.rockCount > 0) this.createRocks(this.environmentConfig.rockCount);
                this.createGrassPatches(this.environmentConfig.grassPatchCount);
                for (let i=0;i<this.environmentConfig.bushClusterCount;i++) {
                    this.createBushCluster((Math.random()-0.5)*6500,(Math.random()-0.5)*6500,6+Math.random()*8);
                }
                if (this.environmentConfig.birdFlocks > 0) {
                    for (let i=0;i<this.environmentConfig.birdFlocks;i++) this.createBirdFlock();
                }
                // 放置静态坦克目标（数量增加）
                this.createTanks(30);
            }

            createMountainRanges() {
                // 1. 雄伟的高山脉
                this.createMountainRange(-3000, -2000, 8, 'high', 0x8b7355);
                this.createMountainRange(2500, 2200, 6, 'high', 0x696969);
                
                // 2. 中等山丘
                this.createMountainRange(-1500, 2800, 5, 'medium', 0xA0522D);
                this.createMountainRange(3200, -1200, 7, 'medium', 0x8b7355);
                
                // 3. 低矮丘陵
                this.createMountainRange(0, 3500, 4, 'low', 0x9ACD32);
                this.createMountainRange(-2800, 1000, 5, 'low', 0x228B22);
                
                // 4. 独立山峰
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 7000;
                    const z = (Math.random() - 0.5) * 7000;
                    this.createSingleMountain(x, z, 'random');
                }
            }

            createMountainRange(centerX, centerZ, count, type, color) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = 200 + Math.random() * 300;
                    const x = centerX + Math.cos(angle) * radius;
                    const z = centerZ + Math.sin(angle) * radius;
                    this.createSingleMountain(x, z, type, color);
                }
            }

            createSingleMountain(x, z, type, color) {
                let height, baseRadius, shape, mountainColor;
                switch(type) {
                    case 'high':
                        height = 120 + Math.random()*110;
                        baseRadius = 50 + Math.random()*40;
                        shape = Math.random()<0.2 ? 'ridge' : (Math.random()<0.4 ? 'mesa' : 'cone');
                        mountainColor = color || 0x7a6550; break;
                    case 'medium':
                        height = 70 + Math.random()*60;
                        baseRadius = 40 + Math.random()*30;
                        shape = Math.random()<0.3 ? 'pyramid' : (Math.random()<0.55 ? 'dome' : 'cone');
                        mountainColor = color || 0x9c6233; break;
                    case 'low':
                        height = 30 + Math.random()*45;
                        baseRadius = 32 + Math.random()*22;
                        shape = Math.random()<0.5 ? 'dome' : 'ridge';
                        mountainColor = color || 0x6fae3b; break;
                    default:
                        return this.createSingleMountain(x, z, ['high','medium','low'][Math.floor(Math.random()*3)]);
                }
                if (Math.random()<0.08) shape = 'crater';
                let mountainGeometry;
                switch(shape) {
                    case 'cone':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 10 + Math.floor(Math.random()*5)); break;
                    case 'pyramid':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 4); break;
                    case 'dome':
                        mountainGeometry = new THREE.SphereGeometry(baseRadius, 12, 8,0,Math.PI*2,0,Math.PI/2); mountainGeometry.scale(1,height/baseRadius,1); break;
                    case 'mesa': {
                        const base = new THREE.CylinderGeometry(baseRadius*0.8, baseRadius, height*0.65, 10);
                        const top = new THREE.CylinderGeometry(baseRadius*0.55, baseRadius*0.6, height*0.15, 10); top.translate(0,height*0.4,0);
                        mountainGeometry = BufferGeometryUtils ? BufferGeometryUtils.mergeGeometries([base, top]) : base; break;
                    }
                    case 'ridge':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 6); mountainGeometry.scale(1.8,1,0.6); break;
                    case 'crater':
                        mountainGeometry = new THREE.CylinderGeometry(baseRadius*1.3, baseRadius*1.4, height*0.5, 24,1,true); break;
                }
                const posAttr = mountainGeometry.attributes.position;
                for (let i=0;i<posAttr.count;i++) {
                    const vx = posAttr.getX(i), vy = posAttr.getY(i), vz = posAttr.getZ(i);
                    const noise = (Math.sin(vx*0.15)+Math.sin(vz*0.18))*0.6 + (Math.random()-0.5)*0.9;
                    posAttr.setY(i, vy + noise*2);
                    posAttr.setX(i, vx + (Math.random()-0.5)*0.8);
                    posAttr.setZ(i, vz + (Math.random()-0.5)*0.8);
                }
                posAttr.needsUpdate = true;
                mountainGeometry.computeVertexNormals();
                const hFactor = THREE.MathUtils.clamp((height-40)/140,0,1);
                const baseColor = new THREE.Color(mountainColor);
                const tint = new THREE.Color().setHSL(0.08 + 0.1*hFactor, 0.35, 0.25 + 0.25*hFactor);
                baseColor.lerp(tint,0.4);
                // === 对齐到地面防止悬浮 ===
                mountainGeometry.computeBoundingBox();
                const bbox = mountainGeometry.boundingBox;
                const GROUND_Y = -50;
                // 计算将几何底部贴到地面的中心 Y
                const placeY = GROUND_Y - bbox.min.y; // 使 (placeY + bbox.min.y) == GROUND_Y
                const mountainMaterial = new THREE.MeshLambertMaterial({ color: baseColor });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(x, placeY, z);
                mountain.rotation.y = Math.random()*Math.PI*2;
                mountain.castShadow = true; mountain.receiveShadow = true;
                mountain.userData.type = 'mountain';
                this.scene.add(mountain);
                // 雪顶重新基于实际最高点放置
                if (height > 110) {
                    const snowHeight = height*0.25;
                    const snow = new THREE.Mesh(new THREE.ConeGeometry(baseRadius*0.35, snowHeight, 10), new THREE.MeshLambertMaterial({ color: 0xf5f7f8 }));
                    const topY = mountain.position.y + bbox.max.y; // 山体最高点
                    // 放在最高点稍低一点，保持贴合
                    snow.position.set(x, topY - height*0.12, z);
                    snow.castShadow = false; snow.receiveShadow = true;
                    this.scene.add(snow);
                }
            }

            // === createTerrain 函数结束 ===

            createClouds() {
                // 增加云朵数量并扩大分布范围到新的8000x8000地形
                for (let i = 0; i < 60; i++) { // Increased from 30 to 60
                    const cloudGeometry = new THREE.SphereGeometry(20 + Math.random() * 30, 8, 6);
                    const cloudMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.7
                    });
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    
                    cloud.position.set(
                        (Math.random() - 0.5) * 6000,  // 从 2000 扩大到 6000
                        100 + Math.random() * 200,
                        (Math.random() - 0.5) * 6000   // 从 2000 扩大到 6000
                    );
                    
                    cloud.scale.set(
                        1 + Math.random() * 0.5,
                        0.3 + Math.random() * 0.3,
                        1 + Math.random() * 0.5
                    );
                    
                    this.clouds.push(cloud);
                    this.scene.add(cloud);
                }
            }

            createDefaultAircraft() {
                // Create enhanced P-51 Mustang style fighter aircraft with premium materials
                const planeGroup = new THREE.Group();
                
                // === PREMIUM MATERIALS ===
                const fuselageMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xD3D3D3, // 新机身浅灰
                    metalness: 0.9,
                    roughness: 0.35,
                    envMapIntensity: 1.0
                });
                
                // Wing material switched to wood-like (low metalness, higher roughness) while keeping original color
                const wingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xE14A32, // 颜色保持不变
                    metalness: 0.05,
                    roughness: 0.85
                });
                
                const glassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.25,
                    metalness: 0.0,
                    roughness: 0.0,
                    transmission: 0.9,
                    ior: 1.5
                });
                
                const darkMetalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x5E5E5E, // 机头 / 整流罩用色
                    metalness: 0.95,
                    roughness: 0.4
                });
                
                // === ENHANCED FUSELAGE (机身) ===
                const fuselageGeometry = new THREE.CylinderGeometry(1.4, 0.7, 16, 16);
                const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                fuselage.rotation.x = Math.PI / 2;
                fuselage.position.set(0, 0, 0);
                fuselage.castShadow = true;
                fuselage.receiveShadow = true;
                planeGroup.add(fuselage);
                
                // === DETAILED NOSE CONE (机鼻) ===
                // Nose shortened by 25% (height 4 -> 3)
                const noseGeometry = new THREE.ConeGeometry(1.4, 3, 16);
                const nose = new THREE.Mesh(noseGeometry, fuselageMaterial);
                nose.position.set(0, 0, 10); // center unchanged; tip moves back 0.5
                nose.rotation.x = Math.PI / 2;
                nose.castShadow = true;
                nose.receiveShadow = true;
                planeGroup.add(nose);
                
                // === ENGINE COWLING (发动机整流罩) ===
                const cowlingGeometry = new THREE.CylinderGeometry(1.6, 1.4, 3, 12);
                const cowling = new THREE.Mesh(cowlingGeometry, darkMetalMaterial);
                cowling.rotation.x = Math.PI / 2;
                cowling.position.set(0, 0, 6.5);
                cowling.castShadow = true;
                planeGroup.add(cowling);
                
                // === REALISTIC WINGS (真实机翼) ===
                // Wing root section
                const wingRootGeometry = new THREE.BoxGeometry(4, 0.8, 4);
                const wingRoot = new THREE.Mesh(wingRootGeometry, wingMaterial);
                wingRoot.position.set(0, -0.2, -1);
                wingRoot.castShadow = true;
                planeGroup.add(wingRoot);
                
                // Tapered wing sections for realistic shape
                for (let side = -1; side <= 1; side += 2) {
                    for (let section = 1; section <= 6; section++) {
                        const width = 4 - (section * 0.4);
                        const thickness = 0.8 - (section * 0.08);
                        const wingGeometry = new THREE.BoxGeometry(width, thickness, 3);
                        const wingSection = new THREE.Mesh(wingGeometry, wingMaterial);
                        wingSection.position.set(side * section * 1.8, -0.2 - (section * 0.02), -1);
                        wingSection.castShadow = true;
                        planeGroup.add(wingSection);
                    }
                }
                
                // === CLEAN WING TIPS (简洁翼尖) ===
                // 移除奇怪的半球形翼尖，改为简洁的椭圆翼尖
                const wingTipGeometry = new THREE.BoxGeometry(1, 0.4, 2);
                for (let side = -1; side <= 1; side += 2) {
                    const wingTip = new THREE.Mesh(wingTipGeometry, wingMaterial);
                    wingTip.position.set(side * 10.8, -0.3, -1);
                    wingTip.castShadow = true;
                    planeGroup.add(wingTip);
                }
                
                // === TAIL SECTION (尾翼) ===
                const tailGeometry = new THREE.CylinderGeometry(0.6, 0.4, 4, 8);
                const tail = new THREE.Mesh(tailGeometry, fuselageMaterial);
                tail.rotation.x = Math.PI / 2;
                tail.position.set(0, 0, -8);
                tail.castShadow = true;
                planeGroup.add(tail);
                
                // === HORIZONTAL STABILIZER (水平尾翼) REWORK: 分段渐缩与主翼风格一致 ===
                const tailWingGroup = new THREE.Group();
                const tailSections = 4;               // 分段数量（每侧）
                const tailSpanHalf = 4.3;             // 半翼展 ≈ 主翼半翼展(≈10.8) 的40%
                const baseChord = 2.2;                // 根部弦长
                const tipChord = 1.2;                 // 翼尖弦长
                const baseThickness = 0.55;           // 根部厚度
                const tipThickness = 0.22;            // 尖部厚度
                const segmentSpan = tailSpanHalf / tailSections; // 每段跨度
                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < tailSections; i++) {
                        const t = i / (tailSections - 1);
                        const chord = THREE.MathUtils.lerp(baseChord, tipChord, t);
                        const thickness = THREE.MathUtils.lerp(baseThickness, tipThickness, t);
                        const spanWidth = segmentSpan * 0.95; // 略收以减少重叠
                        const geo = new THREE.BoxGeometry(spanWidth, thickness, chord);
                        const seg = new THREE.Mesh(geo, wingMaterial);
                        const spanOffset = (i + 0.5) * segmentSpan; // 直接使用真实跨度
                        seg.position.set(side * spanOffset, 0, -10);
                        // 轻微上反角 + 扭转
                        seg.rotation.z = side * THREE.MathUtils.degToRad(3 + t * 1.5);
                        seg.rotation.y = side * THREE.MathUtils.degToRad(1.0 + t * 1.5);
                        seg.castShadow = true;
                        tailWingGroup.add(seg);
                    }
                    // 翼尖（圆润收束）
                    const tipGeo = new THREE.CapsuleGeometry(0.32, 0.6, 4, 8);
                    const tip = new THREE.Mesh(tipGeo, wingMaterial);
                    tip.rotation.z = Math.PI / 2;
                    tip.scale.set(1, 0.5, 0.75);
                    tip.position.set(side * (tailSpanHalf + 0.3), 0, -10);
                    tip.castShadow = true;
                    tailWingGroup.add(tip);
                }
                planeGroup.add(tailWingGroup);
                
                // === VERTICAL STABILIZER (垂直尾翼) REWORK: 正确右角三角形，短边贴机身，斜边朝前 ===
                (function(){
                    const base = 3.0;        // 前向（+Z）基底长度
                    const height = 4.2;      // 垂直高度 (+Y)
                    const r = 0.32;          // 圆角半径
                    const thickness = 0.18;   // 厚度 (X)
                    // 在二维平面 (x=前向Z, y=高度Y) 上构建右角三角形，右角在根部 (0,0)
                    const shape = new THREE.Shape();
                    // 从根部稍右 (r,0) 开始，顺时针绕行
                    shape.moveTo(r,0);
                    shape.lineTo(base - r,0);                                // 底边
                    shape.quadraticCurveTo(base,0, base, r);                 // 前下角圆角
                    shape.lineTo(r, height - r);                             // 斜边到近顶点
                    shape.quadraticCurveTo(0,height, 0, height - r);         // 顶角圆角（根部上）
                    shape.lineTo(0, r);                                      // 回到前缘根部
                    shape.quadraticCurveTo(0,0, r,0);                         // 根部下角圆角
                    shape.closePath();
                    // 挤出 (depth 沿 +Z，之后旋转使其厚度沿 X)
                    const extrudeGeo = new THREE.ExtrudeGeometry(shape,{ depth: thickness, bevelEnabled:false });
                    // 旋转：将局部 Z(厚度) -> X，全局前向使用局部 X
                    extrudeGeo.rotateY(Math.PI / 2);
                    // 重新计算包围盒并对齐：根部垂直边 (x≈0) 贴机身，底部 y=0
                    extrudeGeo.computeBoundingBox();
                    let bb = extrudeGeo.boundingBox;
                    // 将底部移到 y=0
                    extrudeGeo.translate(0, -bb.min.y, 0);
                    extrudeGeo.computeBoundingBox();
                    bb = extrudeGeo.boundingBox;
                    // 将根部前缘 (z 最小) 移到 z=0
                    if (Math.abs(bb.min.z) > 1e-5) extrudeGeo.translate(0,0,-bb.min.z);
                    // 厚度中心化 (X 居中)
                    extrudeGeo.computeBoundingBox();
                    bb = extrudeGeo.boundingBox;
                    const xCenter = -(bb.min.x + bb.max.x)/2;
                    extrudeGeo.translate(xCenter,0,0);
                    // 创建 Mesh 并放置在尾部基准 z=-10
                    const fin = new THREE.Mesh(extrudeGeo, wingMaterial);
                    fin.position.set(0,0,-10);
                    fin.castShadow = true;
                    planeGroup.add(fin);
                })();
                
                // === ENHANCED PROPELLER ASSEMBLY ===
                // Propeller spinner
                const spinnerGeometry = new THREE.ConeGeometry(0.8, 1.5, 12);
                const spinnerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // 螺旋桨锥 黑色
                    metalness: 0.95, 
                    roughness: 0.25 
                });
                const spinner = new THREE.Mesh(spinnerGeometry, spinnerMaterial);
                spinner.position.set(0, 0, 12.0); // moved back to match shorter nose
                spinner.rotation.x = Math.PI / 2;
                spinner.castShadow = true;
                planeGroup.add(spinner);
                
                // Propeller hub
                const hubGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.6, 12);
                const hub = new THREE.Mesh(hubGeometry, spinnerMaterial); // 黑色金属
                hub.position.set(0, 0, 11.0); // adjusted with shorter nose
                hub.rotation.x = Math.PI / 2;
                hub.castShadow = true;
                planeGroup.add(hub);
                
                // Enhanced propeller blades
                const propGroup = new THREE.Group();
                const bladeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // 螺旋桨叶黑色金属
                    metalness: 0.9,
                    roughness: 0.35
                });
                
                for (let i = 0; i < 3; i++) {
                    // Realistic blade shape with taper
                    const bladeGeometry = new THREE.BoxGeometry(0.3, 8, 0.15);
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.rotation.z = (i * 2 * Math.PI) / 3;
                    blade.castShadow = true;
                    propGroup.add(blade);
                    
                    // Blade tips
                    const tipGeometry = new THREE.SphereGeometry(0.2, 8, 4);
                    const tip = new THREE.Mesh(tipGeometry, bladeMaterial);
                    tip.position.set(0, 4, 0);
                    tip.rotation.z = (i * 2 * Math.PI) / 3;
                    blade.add(tip);
                }
                
                propGroup.position.set(0, 0, 11.3); // adjusted forward group anchor
                planeGroup.add(propGroup);
                this.propeller = propGroup;
                
                // === DETAILED LANDING GEAR (起落架) ===
                const gearMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x404040,
                    metalness: 0.8,
                    roughness: 0.3
                });
                
                // Main gear struts with hydraulics
                for (let side = -1; side <= 1; side += 2) {
                    const strutGeometry = new THREE.CylinderGeometry(0.08, 0.12, 3.5, 8);
                    const strut = new THREE.Mesh(strutGeometry, gearMaterial);
                    strut.position.set(side * 2, -2.2, 0);
                    strut.castShadow = true;
                    planeGroup.add(strut);
                    
                    // Wheels with detailed rims
                    const wheelGeometry = new THREE.CylinderGeometry(0.9, 0.9, 0.4, 16);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a,
                        roughness: 0.9
                    });
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(side * 2, -3.8, 0);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.castShadow = true;
                    planeGroup.add(wheel);
                    
                    // Wheel rims
                    const rimGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.45, 16);
                    const rim = new THREE.Mesh(rimGeometry, gearMaterial);
                    rim.position.set(side * 2, -3.8, 0);
                    rim.rotation.z = Math.PI / 2;
                    rim.castShadow = true;
                    planeGroup.add(rim);
                }
                
                // Tail wheel
                const tailWheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12);
                const tailWheel = new THREE.Mesh(tailWheelGeometry, new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, 
                    roughness: 0.9 
                }));
                tailWheel.position.set(0, -1.5, -9);
                tailWheel.rotation.x = Math.PI / 2;
                tailWheel.castShadow = true;
                planeGroup.add(tailWheel);
                
                // === REALISTIC ELLIPTICAL COCKPIT CANOPY (椭圆形驾驶舱座舱盖) ===
                // 创建椭圆形座舱盖，与机身完美贴合
                const canopyGeometry = new THREE.SphereGeometry(1, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                // 将球体压扁成椭圆形，符合真实战斗机设计
                canopyGeometry.scale(2.4, 0.6, 1.8); // 前后拉长（Z轴），上下压扁（Y轴），左右适中（X轴）
                
                const canopy = new THREE.Mesh(canopyGeometry, glassMaterial);
                canopy.position.set(0, 0.9, 0.5); // 降低高度，更好贴合机身
                canopy.rotation.z = Math.PI / 2; // 沿Z轴旋转90度
                canopy.castShadow = true;
                canopy.receiveShadow = true;
                planeGroup.add(canopy);
                
                // === CANOPY FRAME (座舱盖框架) ===
                // 添加座舱盖的金属框架，增加真实感
                const frameGeometry = new THREE.TorusGeometry(1.4, 0.06, 4, 12);
                frameGeometry.scale(1.7, 0.8, 1.3); // 匹配座舱盖的椭圆形状：前后拉长，左右适中
                const frameMaterial = new THREE.MeshStandardMaterial({
                    color: 0x404040,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.set(0, 0.9, 0.5);
                frame.rotation.x = Math.PI / 2;
                frame.rotation.z = Math.PI / 2; // 沿Z轴旋转90度，与座舱盖保持一致
                frame.castShadow = true;
                planeGroup.add(frame);
                
                // === COCKPIT INTERIOR (驾驶舱内部) - 调整位置 ===
                const seatGeometry = new THREE.BoxGeometry(0.8, 0.4, 1.2);
                const seatMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a4a4a, 
                    roughness: 0.8 
                });
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(0, 0.1, 0.5); // 稍微降低座椅位置
                seat.castShadow = true;
                planeGroup.add(seat);
                
                // Control stick (操纵杆)
                const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
                const stick = new THREE.Mesh(stickGeometry, darkMetalMaterial);
                stick.position.set(0, 0.4, 1.0); // 调整操纵杆位置
                stick.castShadow = true;
                planeGroup.add(stick);
                
                // Instrument panel (仪表板)
                const panelGeometry = new THREE.BoxGeometry(1.4, 0.6, 0.08);
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a, 
                    roughness: 0.6,
                    metalness: 0.3
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(0, 0.5, 2.0); // 调整仪表板位置
                panel.rotation.x = -Math.PI / 6; // 向后倾斜15度
                panel.castShadow = true;
                planeGroup.add(panel);
                
                // === NAVIGATION LIGHTS (导航灯) ===
                // Wing tip lights with proper aviation colors
                for (let side = -1; side <= 1; side += 2) {
                    const lightGeometry = new THREE.SphereGeometry(0.12, 8, 6);
                    const lightMaterial = new THREE.MeshStandardMaterial({ 
                        color: side > 0 ? 0x00ff00 : 0xff0000, // Green right, red left
                        emissive: side > 0 ? 0x004400 : 0x440000,
                        emissiveIntensity: 0.5,
                        metalness: 0.1,
                        roughness: 0.2
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(side * 11, 0, -1);
                    planeGroup.add(light);
                }
                
                // Tail navigation light
                const tailLightGeometry = new THREE.SphereGeometry(0.08, 8, 6);
                const tailLightMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0x222222,
                    emissiveIntensity: 0.3,
                    metalness: 0.1,
                    roughness: 0.2
                });
                const tailLight = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
                tailLight.position.set(0, 1, -12);
                planeGroup.add(tailLight);
                
                // === ENHANCED ENGINE EXHAUST STACKS (排气管) ===
                for (let i = 0; i < 6; i++) {
                    const exhaustGeometry = new THREE.CylinderGeometry(0.12, 0.18, 1.2, 8);
                    const exhaustMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2a2a2a,
                        metalness: 0.6,
                        roughness: 0.7,
                        emissive: 0x221100,
                        emissiveIntensity: 0.1
                    });
                    const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 1.2;
                    exhaust.position.set(
                        Math.cos(angle) * radius, 
                        Math.sin(angle) * radius, 
                        5
                    );
                    exhaust.rotation.x = Math.PI / 2;
                    exhaust.castShadow = true;
                    planeGroup.add(exhaust);
                }
                
                // === FINAL ASSEMBLY ===
                planeGroup.position.copy(this.playerPosition);
                planeGroup.scale.set(1.44, 1.44, 1.44); // 放大1.2倍（在原1.2基础）
                
                // Store references
                this.aircraft = planeGroup;
                this.scene.add(this.aircraft);
                // 如果默认飞机创建成功后添加机炮（若未在init里）
                if (this.gunBarrels.length === 0) this.createNoseCannons();
            }

            // ================= Nose Cannon System =================
            createNoseCannons() {
                if (!this.aircraft) return;
                // 避免重复添加
                if (this.aircraft.getObjectByName('NoseCannons')) return;
                const barrelsGroup = new THREE.Group();
                barrelsGroup.name = 'NoseCannons';
                const barrelMat = new THREE.MeshStandardMaterial({
                    color: 0x2c2c2c,
                    metalness: 0.85,
                    roughness: 0.25
                });
                const barrelGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.6, 12);
                this.gunBarrels = [];
                for (let s of [-1,1]) {
                    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                    barrel.rotation.x = Math.PI/2;
                    barrel.position.set(s*0.6, -0.15, 7.2);
                    barrel.castShadow = true;
                    barrelsGroup.add(barrel);
                    this.gunBarrels.push(barrel);
                }
                // 装饰基座环
                const ringGeo = new THREE.TorusGeometry(0.28, 0.045, 6, 16);
                for (let s of [-1,1]) {
                    const ring = new THREE.Mesh(ringGeo, new THREE.MeshStandardMaterial({
                        color: 0x555555,
                        metalness: 0.6,
                        roughness: 0.4
                    }));
                    ring.rotation.x = Math.PI/2;
                    ring.position.set(s*0.6, -0.15, 6.45);
                    barrelsGroup.add(ring);
                }
                this.aircraft.add(barrelsGroup);
            }

            setupMouseControls() {
                const canvas = this.renderer.domElement;
                canvas.addEventListener('mousedown', (e)=>{ if (e.button===0) this.isFiring = true; });
                window.addEventListener('mouseup', (e)=>{ if (e.button===0) this.isFiring = false; });
            }

            tryFireGuns(deltaTime) {
                if (!this.isFiring || !this.aircraft || this.gunBarrels.length===0) return;
                const now = performance.now()/1000;
                if (now - this.lastShotTime < this.fireInterval) return;
                this.lastShotTime = now;
                // 前向方向
                this.forwardVec.set(0,0,1).applyEuler(new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll)).normalize();
                // 炮口射击
                this.gunBarrels.forEach(barrel=>{
                    barrel.getWorldPosition(this.tempVec);
                    this.spawnBullet(this.tempVec, this.forwardVec);
                    this.spawnMuzzleFlash(barrel);
                });
            }

            spawnBullet(origin, forward) {
                const geo = new THREE.SphereGeometry(0.45, 10, 10);
                const mat = new THREE.MeshBasicMaterial({ color: 0xfff066 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(origin);
                this.scene.add(mesh);
                const speed = 450;
                this.bullets.push({ mesh, velocity: forward.clone().multiplyScalar(speed), life: 2, age: 0 });
            }

            spawnMuzzleFlash(barrel) {
                const flashGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const flashMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                barrel.getWorldPosition(flash.position);
                this.scene.add(flash);
                this.muzzleFlashes.push({ mesh: flash, age: 0, life: 0.12 });
            }

            updateBullets(deltaTime) {
                // 子弹移动 & 淡出
                for (let i = this.bullets.length-1; i>=0; i--) {
                    const b = this.bullets[i];
                    b.age += deltaTime;
                    b.mesh.position.addScaledVector(b.velocity, deltaTime);
                    // 伸长视觉（沿局部Z用scale模拟）
                    b.mesh.scale.z = 1 + b.age*4;
                    const t = b.age / b.life;
                    if (t > 0.6) {
                        b.mesh.material.transparent = true;
                        b.mesh.material.opacity = 1 - (t-0.6)/0.4;
                    }
                    // ==== 碰撞检测：子弹 vs 坦克 ====
                    if (this.tanks && this.tanks.length>0) {
                        for (let ti = 0; ti < this.tanks.length; ti++) {
                            const tank = this.tanks[ti];
                            if (!tank.alive) continue;
                            const dist = b.mesh.position.distanceTo(tank.mesh.position);
                            if (dist < tank.radius) {
                                // 命中
                                tank.alive = false;
                                this.createExplosion(tank.mesh.position.clone());
                                this.scene.remove(tank.mesh);
                                // 生成残骸/焦黑贴花
                                this.createScorchMark(tank.mesh.position.x, tank.mesh.position.z);
                                // 移除子弹
                                this.scene.remove(b.mesh);
                                b.mesh.geometry.dispose();
                                b.mesh.material.dispose();
                                this.bullets.splice(i,1);
                                break; // 跳出坦克循环
                            }
                        }
                    }
                    if (b.age >= b.life) {
                        this.scene.remove(b.mesh);
                        b.mesh.geometry.dispose();
                        b.mesh.material.dispose();
                        this.bullets.splice(i,1);
                    }
                }
                // 枪口火光
                for (let i = this.muzzleFlashes.length-1; i>=0; i--) {
                    const f = this.muzzleFlashes[i];
                    f.age += deltaTime;
                    const p = f.age / f.life;
                    f.mesh.scale.setScalar(1 + p*5);
                    f.mesh.material.transparent = true;
                    f.mesh.material.opacity = 1 - p;
                    if (f.age >= f.life) {
                        this.scene.remove(f.mesh);
                        f.mesh.geometry.dispose();
                        f.mesh.material.dispose();
                        this.muzzleFlashes.splice(i,1);
                    }
                }
            }

            // === 环境系统函数 ===
            
            createTrees() {
                const m = this.environmentConfig.treeDensityMultiplier;
                this.createDenseForest(-2500, -2000, 800, 600, 'pine', Math.round(80*m));
                this.createDenseForest(1800, 1500, 700, 500, 'oak', Math.round(70*m));
                this.createMediumForest(-1000, 2200, 900, 700, 'mixed', Math.round(45*m));
                this.createMediumForest(2200, -800, 600, 800, 'birch', Math.round(40*m));
                this.createSparseForest(-3000, 0, 1200, 800, 'oak', Math.round(25*m));
                this.createSparseForest(0, -2800, 1000, 600, 'pine', Math.round(20*m));
                this.createSparseForest(1000, 3000, 800, 600, 'palm', Math.round(15*m));
                for (let i = 0; i < Math.round(100*m); i++) {
                    const x = (Math.random()-0.5)*7000;
                    const z = (Math.random()-0.5)*7000;
                    const treeType = ['pine','oak','birch','palm'][Math.floor(Math.random()*4)];
                    this.createTree(x,z,treeType);
                }
            }

            // 密集森林 - 树木紧密排列
            createDenseForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    // 使用聚集分布，模拟真实森林
                    const clusterX = centerX + (Math.random() - 0.5) * width * 0.8;
                    const clusterZ = centerZ + (Math.random() - 0.5) * depth * 0.8;
                    
                    // 在聚集点周围随机分布
                    const offsetX = (Math.random() - 0.5) * 50;
                    const offsetZ = (Math.random() - 0.5) * 50;
                    
                    this.createTree(clusterX + offsetX, clusterZ + offsetZ, forestType);
                }
            }

            // 中等密度森林
            createMediumForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    const x = centerX + (Math.random() - 0.5) * width;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // 随机跳过一些位置，创造空隙
                    if (Math.random() > 0.3) {
                        this.createTree(x, z, forestType);
                    }
                }
            }

            // 稀疏森林
            createSparseForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    const x = centerX + (Math.random() - 0.5) * width;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // 稀疏分布，更多空旷区域
                    if (Math.random() > 0.6) {
                        this.createTree(x, z, forestType);
                    }
                }
            }

            // === 湖泊系统（替换原先的河流系统） ===
            createLakes() {
                // 创建多个不同大小与形状的湖泊
                const lakeConfigs = [
                    { x: -1500, z: -1200, radius: 350, color: 0x3A87BD }, // 大湖
                    { x: 1200, z: 800, radius: 250, color: 0x357EBA },   // 中型湖
                    { x: 400, z: -1400, radius: 180, color: 0x2F6FAF },  // 中小湖
                    { x: -800, z: 1600, radius: 200, color: 0x337BB5 },  // 森林湖
                    { x: 1800, z: -600, radius: 150, color: 0x2E75AA }   // 丘陵湖
                ];

                lakeConfigs.forEach(cfg => this.createLake(cfg.x, cfg.z, cfg.radius, cfg.color));

                // 生成一些随机小湖/池塘
                for (let i = 0; i < 6; i++) {
                    const x = (Math.random() - 0.5) * 6000;
                    const z = (Math.random() - 0.5) * 6000;
                    const r = 80 + Math.random() * 140;
                    this.createLake(x, z, r, 0x2F6FAF);
                }
            }

            createLake(centerX, centerZ, radius, color) {
                // 使用细分圆形并随机扰动顶点制造自然外形
                const segments = 48;
                const geometry = new THREE.CircleGeometry(radius, segments);
                const pos = geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    if (i === 0) continue; // 跳过中心点
                    const vx = pos.getX(i);
                    const vy = pos.getY(i);
                    const r = Math.sqrt(vx * vx + vy * vy);
                    const deform = 1 + (Math.random() - 0.5) * 0.15; // 轻微形变
                    pos.setX(i, vx * deform);
                    pos.setY(i, vy * deform);
                }
                pos.needsUpdate = true;

                // 添加轻微波浪法线效果（顶点抖动可选）
                geometry.computeVertexNormals();

                const material = new THREE.MeshLambertMaterial({
                    color,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });

                const lake = new THREE.Mesh(geometry, material);
                lake.rotation.x = -Math.PI / 2;
                lake.position.set(centerX, -46, centerZ); // 与地面稍微凹陷一点
                lake.receiveShadow = true;
                this.scene.add(lake);

                // 环湖植被：在湖泊外圈随机生成树木和灌木
                const ringCount = Math.floor(radius / 20);
                for (let i = 0; i < ringCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = radius + 30 + Math.random() * 120;
                    const x = centerX + Math.cos(angle) * dist;
                    const z = centerZ + Math.sin(angle) * dist;
                    const types = ['birch', 'oak', 'pine'];
                    this.createTree(x, z, types[Math.floor(Math.random() * types.length)]);
                }
            }

            createTree(x, z, treeType = 'oak') {
                const treeGroup = new THREE.Group();
                
                let trunkHeight, trunkRadius;
                
                switch(treeType) {
                    case 'pine': // 优美的松树
                        trunkHeight = 15 + Math.random() * 10;
                        trunkRadius = 0.6 + Math.random() * 0.3;
                        
                        // 松树树干 - 自然棕色
                        const pineTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.7, trunkRadius * 1.2, trunkHeight, 8
                        );
                        const pineTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B4513 // 温暖的棕色
                        });
                        const pineTrunk = new THREE.Mesh(pineTrunkGeometry, pineTrunkMaterial);
                        pineTrunk.position.y = trunkHeight / 2 - 50;
                        pineTrunk.castShadow = true;
                        treeGroup.add(pineTrunk);
                        
                        // 松树层状树冠 - 深绿到浅绿渐变
                        const greenShades = [0x0F4F0F, 0x228B22, 0x32CD32, 0x90EE90];
                        for (let layer = 0; layer < 5; layer++) {
                            const layerRadius = 5 - layer * 0.7;
                            const layerHeight = 3.5 + Math.random() * 0.5;
                            const crownGeometry = new THREE.ConeGeometry(layerRadius, layerHeight, 8);
                            const crownMaterial = new THREE.MeshLambertMaterial({ 
                                color: greenShades[Math.min(layer, 3)]
                            });
                            const crownLayer = new THREE.Mesh(crownGeometry, crownMaterial);
                            crownLayer.position.y = trunkHeight - 50 + layer * 2.8;
                            crownLayer.castShadow = true;
                            treeGroup.add(crownLayer);
                        }
                        break;
                        
                    case 'oak': // 雄伟的橡树
                        trunkHeight = 10 + Math.random() * 8;
                        trunkRadius = 1.2 + Math.random() * 0.6;
                        
                        // 橡树粗壮树干 - 深棕色
                        const oakTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.8, trunkRadius * 1.4, trunkHeight, 8
                        );
                        const oakTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x654321 // 深棕色
                        });
                        const oakTrunk = new THREE.Mesh(oakTrunkGeometry, oakTrunkMaterial);
                        oakTrunk.position.y = trunkHeight / 2 - 50;
                        oakTrunk.castShadow = true;
                        treeGroup.add(oakTrunk);
                        
                        // 橡树茂密树冠 - 多层结构
                        const mainCrownGeometry = new THREE.SphereGeometry(6 + Math.random() * 2, 10, 8);
                        mainCrownGeometry.scale(1.4, 0.9, 1.4); // 压扁的宽阔树冠
                        const mainCrownMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22 // 森林绿
                        });
                        const mainCrown = new THREE.Mesh(mainCrownGeometry, mainCrownMaterial);
                        mainCrown.position.y = trunkHeight - 50 + 4;
                        mainCrown.castShadow = true;
                        treeGroup.add(mainCrown);
                        
                        // 额外的小树冠增加层次感
                        for (let i = 0; i < 3; i++) {
                            const smallCrownGeometry = new THREE.SphereGeometry(2 + Math.random(), 8, 6);
                            const smallCrownMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x32CD32 // 较亮的绿色
                            });
                            const smallCrown = new THREE.Mesh(smallCrownGeometry, smallCrownMaterial);
                            smallCrown.position.set(
                                (Math.random() - 0.5) * 8,
                                trunkHeight - 50 + 3 + Math.random() * 3,
                                (Math.random() - 0.5) * 8
                            );
                            smallCrown.castShadow = true;
                            treeGroup.add(smallCrown);
                        }
                        break;
                        
                    case 'birch': // 优雅的桦树
                        trunkHeight = 12 + Math.random() * 6;
                        trunkRadius = 0.4 + Math.random() * 0.2;
                        
                        // 桦树细长白色树干
                        const birchTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.9, trunkRadius * 1.1, trunkHeight, 8
                        );
                        const birchTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xF5F5DC // 优雅的米色白
                        });
                        const birchTrunk = new THREE.Mesh(birchTrunkGeometry, birchTrunkMaterial);
                        birchTrunk.position.y = trunkHeight / 2 - 50;
                        birchTrunk.castShadow = true;
                        treeGroup.add(birchTrunk);
                        
                        // 桦树垂柳状树冠
                        const birchCrownGeometry = new THREE.SphereGeometry(4 + Math.random() * 1.5, 8, 6);
                        birchCrownGeometry.scale(1.2, 1.4, 1.2); // 稍微拉长
                        const birchCrownMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x9ACD32 // 黄绿色
                        });
                        const birchCrown = new THREE.Mesh(birchCrownGeometry, birchCrownMaterial);
                        birchCrown.position.y = trunkHeight - 50 + 3;
                        birchCrown.castShadow = true;
                        treeGroup.add(birchCrown);
                        break;
                        
                    case 'palm': // 热带棕榈树
                        trunkHeight = 14 + Math.random() * 8;
                        trunkRadius = 0.8;
                        
                        // 棕榈树弯曲树干
                        const palmTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.6, trunkRadius, trunkHeight, 8
                        );
                        const palmTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xD2691E // 温暖的橙棕色
                        });
                        const palmTrunk = new THREE.Mesh(palmTrunkGeometry, palmTrunkMaterial);
                        palmTrunk.position.y = trunkHeight / 2 - 50;
                        palmTrunk.rotation.z = (Math.random() - 0.5) * 0.4; // 轻微倾斜
                        palmTrunk.castShadow = true;
                        treeGroup.add(palmTrunk);
                        
                        // 棕榈叶 - 更真实的造型
                        for (let leaf = 0; leaf < 12; leaf++) {
                            const leafGeometry = new THREE.CylinderGeometry(0.1, 0.4, 7, 4);
                            const leafMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x228B22 // 热带绿
                            });
                            const palmLeaf = new THREE.Mesh(leafGeometry, leafMaterial);
                            const angle = (leaf / 12) * Math.PI * 2;
                            const radius = 2.5 + Math.random() * 0.5;
                            palmLeaf.position.set(
                                Math.cos(angle) * radius,
                                trunkHeight - 50 + 3,
                                Math.sin(angle) * radius
                            );
                            palmLeaf.rotation.z = angle + Math.PI / 2.5; // 向外弯曲
                            palmLeaf.rotation.x = (Math.random() - 0.5) * 0.3; // 随机倾斜
                            palmLeaf.castShadow = true;
                            treeGroup.add(palmLeaf);
                        }
                        break;
                        
                    case 'mixed':
                        // 混合林中随机选择树种
                        const mixedTypes = ['pine', 'oak', 'birch'];
                        return this.createTree(x, z, mixedTypes[Math.floor(Math.random() * mixedTypes.length)]);
                }
                
                // 添加轻微随机旋转，增加自然感
                treeGroup.rotation.y = Math.random() * Math.PI * 2;
                treeGroup.position.set(x, 0, z);
                this.scene.add(treeGroup);
            }

            // === Extra Environment Helpers ===
            createBushCluster(x,z,count=8){
                for (let i=0;i<count;i++){
                    const r = 2 + Math.random()*2.5;
                    const g = new THREE.SphereGeometry(r, 8, 6);
                    const c = new THREE.Color().setHSL(0.28 + Math.random()*0.08, 0.6, 0.35+Math.random()*0.2);
                    const m = new THREE.MeshLambertMaterial({ color: c });
                    const bush = new THREE.Mesh(g,m);
                    const ang = Math.random()*Math.PI*2;
                    const dist = Math.random()*8;
                    bush.position.set(x + Math.cos(ang)*dist, -50 + r*0.5, z + Math.sin(ang)*dist);
                    bush.castShadow = true;
                    this.scene.add(bush);
                }
            }

            createRocks(count){
                for (let i=0;i<count;i++){
                    const s = 3 + Math.random()*10;
                    const g = new THREE.DodecahedronGeometry(s, 0);
                    const col = new THREE.Color().setHSL(0.08 + Math.random()*0.05, 0.2, 0.25 + Math.random()*0.2);
                    const m = new THREE.MeshLambertMaterial({ color: col });
                    const rock = new THREE.Mesh(g,m);
                    rock.position.set((Math.random()-0.5)*7600, -50 + s*0.5, (Math.random()-0.5)*7600);
                    rock.rotation.y = Math.random()*Math.PI*2;
                    rock.castShadow = true;
                    this.scene.add(rock);
                }
            }

            createGrassPatches(count){
                for (let i=0;i<count;i++){
                    const blades = new THREE.Group();
                    const baseX = (Math.random()-0.5)*7600;
                    const baseZ = (Math.random()-0.5)*7600;
                    const bladeCount = 4 + Math.random()*6;
                    for (let b=0;b<bladeCount;b++){
                        const h = 4 + Math.random()*6;
                        const geo = new THREE.CylinderGeometry(0.05,0.25,h,4,1);
                        const mat = new THREE.MeshLambertMaterial({ color: 0x3c8d1e });
                        const blade = new THREE.Mesh(geo,mat);
                        blade.position.set((Math.random()-0.5)*3, -50 + h/2, (Math.random()-0.5)*3);
                        blade.rotation.x = (Math.random()-0.5)*0.4;
                        blade.rotation.z = (Math.random()-0.5)*0.4;
                        blades.add(blade);
                    }
                    blades.position.set(baseX,0,baseZ);
                    this.scene.add(blades);
                }
            }

            createBirdFlock(){
                const flock = new THREE.Group();
                const count = 12 + Math.floor(Math.random()*8);
                for (let i=0;i<count;i++){
                    const geo = new THREE.ConeGeometry(1.2,3,4);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                    const bird = new THREE.Mesh(geo,mat);
                    bird.rotation.x = Math.PI/2;
                    bird.position.set((Math.random()-0.5)*30,(Math.random()-0.5)*10,(Math.random()-0.5)*30);
                    flock.add(bird);
                }
                flock.position.set((Math.random()-0.5)*6000,150 + Math.random()*250,(Math.random()-0.5)*6000);
                flock.userData = { speed: 20 + Math.random()*15, dir: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize() };
                this.scene.add(flock);
                if(!this.flocks) this.flocks=[];
                this.flocks.push(flock);
            }

            updateFlocks(delta){
                if(!this.flocks) return;
                this.flocks.forEach(f=>{
                    f.position.addScaledVector(f.userData.dir, f.userData.speed*delta);
                    f.position.y += Math.sin(Date.now()*0.001 + f.position.x*0.01)*0.2;
                    const limit = 4000;
                    if (f.position.x > limit) f.position.x = -limit;
                    if (f.position.x < -limit) f.position.x = limit;
                    if (f.position.z > limit) f.position.z = -limit;
                    if (f.position.z < -limit) f.position.z = limit;
                });
            }

            createSoilPatches(count){
                for (let i=0;i<count;i++){
                    const r = 40 + Math.random()*120;
                    const geo = new THREE.CircleGeometry(r, 24);
                    const posAttr = geo.attributes.position;
                    for (let v=0; v<posAttr.count; v++) { // 轻微扰动边缘
                        if (v===0) continue;
                        const x = posAttr.getX(v); const y = posAttr.getY(v);
                        const dist = Math.hypot(x,y);
                        const factor = 1 + (Math.random()-0.5)*0.25;
                        posAttr.setX(v, x * factor);
                        posAttr.setY(v, y * factor);
                    }
                    posAttr.needsUpdate = true;
                    const colors = [0x7b5e31,0x6b4a1f,0xa07547,0x8a6235];
                    const mat = new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random()*colors.length)], side: THREE.DoubleSide, opacity: 0.92, transparent: true });
                    const patch = new THREE.Mesh(geo, mat);
                    patch.rotation.x = -Math.PI/2;
                    patch.position.set((Math.random()-0.5)*7600, -49.9, (Math.random()-0.5)*7600);
                    patch.receiveShadow = true;
                    this.scene.add(patch);
                }
            }

            // ================= Tanks =================
            getGroundHeight(x,z){
                if(!this.ground) return -50;
                this.raycaster.set(new THREE.Vector3(x, 500, z), new THREE.Vector3(0,-1,0));
                const hit = this.raycaster.intersectObject(this.ground, false);
                return hit.length ? hit[0].point.y : -50;
            }

            alignTankToGround(group){
                // 计算履带/底座假定基准：我们将 group 的局部原点视为底座中心高度 (approx hull center -2.5)
                // 使用射线获得真实地面，然后设置 group.position.y 使底面离地面略微“悬空” 0.4
                const gY = this.getGroundHeight(group.position.x, group.position.z);
                // 由于 hull.position.y = -50 + 2.5 (在构造中)，group.position.y 初始为 0 时 hull 底部在 -50
                // 因此当 group.position.y 偏移 d 时，底部 = -50 + d
                // 我们希望底部 = gY + 1.0 （抬离地面更高）
                const desiredBottom = gY + 1.0;
                const d = desiredBottom - (-50);
                group.position.y = d;
            }
            createTanks(count=10){
                for (let i=0;i<count;i++) {
                    const x = (Math.random()-0.5)*7000;
                    const z = (Math.random()-0.5)*7000;
                    // 避免离玩家出生点太近
                    if (Math.hypot(x, z) < 400) { i--; continue; }
                    const tank = this.createTank(x, z);
                    this.tanks.push(tank);
                }
                // 创建后统一对齐一次（冗余安全）
                this.tanks.forEach(t=> this.alignTankToGround(t.mesh));
            }

            createTank(x,z){
                const group = new THREE.Group();
                const palette = [0x4d5a34,0x556b2f,0x6e5b2e,0x5c6133];
                const baseColor = palette[Math.floor(Math.random()*palette.length)];
                const baseMat = new THREE.MeshStandardMaterial({ color: baseColor, metalness:0.25, roughness:0.75 });

                // === 矩形底座 ===
                const hull = new THREE.Mesh(new THREE.BoxGeometry(30,5,46), baseMat);
                hull.position.y = -50 + 2.5;
                hull.castShadow = true; hull.receiveShadow = true;
                group.add(hull);

                // === 履带与5个负重轮（每侧） ===
                const trackMat = new THREE.MeshStandardMaterial({ color:0x1d1d1d, roughness:0.95 });
                for (let side of [-1,1]){
                    const track = new THREE.Mesh(new THREE.BoxGeometry(4,3.2,46), trackMat);
                    track.position.set(side*(30/2+3), -50+1.6, 0);
                    track.castShadow = true; group.add(track);
                }
                const wheelGeo = new THREE.CylinderGeometry(2.2,2.2,1.4,18);
                const wheelMat = new THREE.MeshStandardMaterial({ color:0x3a3a3a, metalness:0.4, roughness:0.6 });
                const wheelZs = [-14,-7,0,7,14];
                for (let side of [-1,1]){
                    wheelZs.forEach(zv=>{
                        const w = new THREE.Mesh(wheelGeo, wheelMat);
                        w.rotation.z = Math.PI/2;
                        w.position.set(side*(30/2+3), -50+1.2, zv);
                        group.add(w);
                    });
                }

                // === 圆柱炮塔 ===
                const turretHeight = 4;
                const turret = new THREE.Mesh(new THREE.CylinderGeometry(10,10,turretHeight,24), baseMat);
                const turretY = -50 + 2.5 + 2.5 + turretHeight/2; // 底座顶面 + 炮塔一半高度
                turret.position.set(0, turretY, 0); // 竖直放置（不再旋转）
                turret.castShadow = true; turret.receiveShadow = true;
                group.add(turret);

                // === 炮管（从炮塔中心 35° 抬起） ===
                const gunPivot = new THREE.Group();
                gunPivot.position.set(0, turretY, 0);
                group.add(gunPivot);
                const barrelMat = new THREE.MeshStandardMaterial({ color:0x2d2d2d, metalness:0.6, roughness:0.45 });
                const barrelLength = 26;
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.85,barrelLength,18), barrelMat);
                // 先让轴沿 Z
                barrel.rotation.x = Math.PI/2; // Y -> Z
                barrel.position.z = barrelLength/2 + 2; // 从塔中心向前
                gunPivot.add(barrel);
                // 炮口内膛
                const inner = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,2,12), new THREE.MeshStandardMaterial({ color:0x050505, metalness:0.3, roughness:0.9 }));
                inner.rotation.x = Math.PI/2;
                inner.position.z = barrelLength + 2;
                gunPivot.add(inner);
                // 抬升角度（负号使其朝上）
                gunPivot.rotation.x = -THREE.MathUtils.degToRad(35);

                // === 红色高亮指示箭头（保持） ===
                const arrowGroup = new THREE.Group();
                const arrowMat = new THREE.MeshBasicMaterial({ color:0xff2222 });
                const cone = new THREE.Mesh(new THREE.ConeGeometry(3.2,9,18), arrowMat);
                cone.rotation.x = Math.PI; // 指向下
                arrowGroup.add(cone);
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,4.5,12), arrowMat);
                stem.position.y = -6.5;
                arrowGroup.add(stem);
                arrowGroup.position.set(0, turretY + 12, 0);
                arrowGroup.userData = { pulsePhase: Math.random()*Math.PI*2 };
                group.add(arrowGroup);

                group.position.set(x,0,z);
                // 贴合地面高度
                this.alignTankToGround(group);
                this.scene.add(group);
                return { mesh: group, alive: true, radius: 16, indicator: arrowGroup };
            }

            updateTankIndicators(delta){
                if(!this.tanks) return;
                const t = performance.now()*0.001;
                this.tanks.forEach(tank=>{
                    if(!tank.alive) {
                        if(tank.indicator) tank.indicator.visible=false;
                        return;
                    }
                    if(tank.indicator){
                        tank.indicator.visible = true;
                        tank.indicator.lookAt(this.camera.position);
                        const phase = t*4 + (tank.indicator.userData.pulsePhase||0);
                        const s = 1 + Math.sin(phase)*0.25;
                        tank.indicator.scale.set(s,s,s);
                    }
                });
            }

            createExplosion(position){
                const group = new THREE.Group();
                group.position.copy(position);
                this.scene.add(group);
                // 静态火花 + 原地燃烧火焰
                const flameCount = 26;
                for (let i=0;i<flameCount;i++) {
                    const size = 0.9 + Math.random()*1.4;
                    const geo = new THREE.SphereGeometry(size, 6, 6);
                    const col = 0xffa533;
                    const mat = new THREE.MeshBasicMaterial({ color: col, transparent:true, opacity:1 });
                    const p = new THREE.Mesh(geo, mat);
                    // 静止：dir = 0
                    p.userData = { dir: new THREE.Vector3(0,0,0), life: 0.65 + Math.random()*0.5, age:0, flame:true };
                    // 随机分布在爆心轻微半径内
                    const ang = Math.random()*Math.PI*2; const rad = Math.random()*3.2;
                    p.position.set(Math.cos(ang)*rad, Math.random()*2, Math.sin(ang)*rad);
                    group.add(p);
                }
                // 轻烟向上（很慢，几乎原地）
                for (let i=0;i<12;i++) {
                    const geo = new THREE.SphereGeometry(2+Math.random()*2.5, 8,6);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x2b2b2b, transparent:true, opacity:0.55 });
                    const s = new THREE.Mesh(geo, mat);
                    s.userData = { dir: new THREE.Vector3(0, (0.15+Math.random()*0.25), 0), life: 2.2 + Math.random()*0.8, age:0, smoke:true };
                    const ang = Math.random()*Math.PI*2; const rad = Math.random()*2.5;
                    s.position.set(Math.cos(ang)*rad, 0.4+Math.random()*1.2, Math.sin(ang)*rad);
                    group.add(s);
                }
                const animate = () => {
                    const dt = 0.016;
                    group.children.forEach(c=>{
                        if (!c.userData) return;
                        c.userData.age += dt;
                        const ratio = c.userData.age / c.userData.life;
                        // 仅烟缓慢上升
                        if (c.userData.smoke) c.position.add(c.userData.dir.clone().multiplyScalar(dt));
                        if (c.material) {
                            if (c.userData.flame) {
                                c.material.opacity = Math.max(0, 1 - ratio*1.2);
                                c.scale.multiplyScalar(1 + dt*0.8);
                            } else if (c.userData.smoke) {
                                c.material.opacity = Math.max(0, 0.55 * (1 - ratio));
                                c.scale.multiplyScalar(1 + dt*0.35);
                            }
                        }
                    });
                    // 清理
                    for (let i=group.children.length-1;i>=0;i--) {
                        const ch = group.children[i];
                        if (ch.userData && ch.userData.age >= ch.userData.life) {
                            group.remove(ch); ch.geometry.dispose(); ch.material.dispose();
                        }
                    }
                    if (group.children.length>0) requestAnimationFrame(animate); else this.scene.remove(group);
                };
                animate();
            }

            createScorchMark(x,z){
                const r = 18 + Math.random()*6;
                const geo = new THREE.CircleGeometry(r, 20);
                const mat = new THREE.MeshBasicMaterial({ color: 0x1d1b1a, transparent:true, opacity:0.55, side:THREE.DoubleSide });
                const m = new THREE.Mesh(geo, mat);
                m.rotation.x = -Math.PI/2;
                m.position.set(x, -49.8, z);
                this.scene.add(m);
                // 渐隐
                const start = performance.now();
                const fade = () => {
                    const t = (performance.now()-start)/8000;
                    if (t<1) {
                        mat.opacity = 0.55*(1-t);
                        requestAnimationFrame(fade);
                    } else {
                        this.scene.remove(m); geo.dispose(); mat.dispose();
                    }
                };
                requestAnimationFrame(fade);
            }

            // （公路系统已移除）

            createBuildings() {
                // 创建城镇区域
                this.createTownArea(-800, -800, 600, 600); // 主城区
                this.createTownArea(1200, 800, 400, 400);  // 小镇1
                this.createTownArea(-1500, 1000, 300, 300); // 小镇2
                
                // 创建一些独立建筑
                for (let i = 0; i < 50; i++) {
                    const x = (Math.random() - 0.5) * 6000;
                    const z = (Math.random() - 0.5) * 6000;
                    this.createRandomBuilding(x, z);
                }
            }

            createTownArea(centerX, centerZ, width, depth) {
                const buildingsPerRow = 6;
                const spacing = Math.min(width, depth) / buildingsPerRow;
                
                for (let i = 0; i < buildingsPerRow; i++) {
                    for (let j = 0; j < buildingsPerRow; j++) {
                        const x = centerX + (i - buildingsPerRow/2) * spacing + (Math.random() - 0.5) * 20;
                        const z = centerZ + (j - buildingsPerRow/2) * spacing + (Math.random() - 0.5) * 20;
                        this.createRandomBuilding(x, z, true); // 城镇建筑更大
                    }
                }
            }

            createRandomBuilding(x, z, isTown = false) {
                const buildingGroup = new THREE.Group();
                
                // 建筑尺寸
                const width = isTown ? 20 + Math.random() * 30 : 10 + Math.random() * 15;
                const depth = isTown ? 20 + Math.random() * 30 : 10 + Math.random() * 15;
                const height = isTown ? 30 + Math.random() * 80 : 15 + Math.random() * 25;
                
                // 主建筑
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingColors = [0x8B7355, 0xA0522D, 0x696969, 0x778899, 0xDC143C]; // 各种建筑颜色
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)]
                });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.y = height / 2 - 50;
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);
                
                // 屋顶
                const roofGeometry = new THREE.ConeGeometry(
                    Math.max(width, depth) * 0.7, 
                    height * 0.3, 
                    4
                );
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B0000 // 红色屋顶
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = height - 50 + height * 0.15;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                buildingGroup.add(roof);
                
                // 随机添加窗户（简单的黄色方块）
                if (isTown) {
                    for (let i = 0; i < 8; i++) {
                        const windowGeometry = new THREE.PlaneGeometry(3, 4);
                        const windowMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00, // 黄色窗户（灯光）
                            transparent: true,
                            opacity: 0.8
                        });
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            (Math.random() - 0.5) * width * 0.8,
                            (Math.random() - 0.3) * height - 50,
                            width / 2 + 0.1
                        );
                        buildingGroup.add(window);
                    }
                }
                
                buildingGroup.position.set(x, 0, z);
                this.scene.add(buildingGroup);
            }

            showAnimationControls() {
                if (!this.modelAnimations || this.modelAnimations.length === 0) return;
                
                // 创建动画控制面板
                const controlPanel = document.createElement('div');
                controlPanel.id = 'animationControls';
                controlPanel.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 15px;
                    border-radius: 10px;
                    font-family: monospace;
                    z-index: 1000;
                    max-width: 250px;
                `;
                
                controlPanel.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #00ff00;">✈️ Animation Controls</h4>
                    <div id="animationList"></div>
                    <button id="playAllAnimations" style="margin-top: 10px; width: 100%;">▶️ Play All</button>
                    <button id="stopAllAnimations" style="margin-top: 5px; width: 100%;">⏹️ Stop All</button>
                `;
                
                const animationList = controlPanel.querySelector('#animationList');
                
                // 为每个动画创建控制按钮
                this.modelAnimations.forEach((clip, index) => {
                    const animDiv = document.createElement('div');
                    animDiv.style.cssText = 'margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                    
                    animDiv.innerHTML = `
                        <div style="font-size: 12px; color: #00ffff;">${clip.name || `Animation ${index + 1}`}</div>
                        <div style="font-size: 10px; color: #888;">Duration: ${clip.duration.toFixed(1)}s</div>
                        <button class="playAnim" data-index="${index}" style="font-size: 10px; margin-top: 3px;">▶️ Play</button>
                        <button class="pauseAnim" data-index="${index}" style="font-size: 10px; margin-left: 5px;">⏸️ Pause</button>
                    `;
                    
                    animationList.appendChild(animDiv);
                });
                
                // 添加事件监听器
                controlPanel.querySelector('#playAllAnimations').addEventListener('click', () => {
                    this.activeAnimations.forEach(action => action.play());
                });
                
                controlPanel.querySelector('#stopAllAnimations').addEventListener('click', () => {
                    this.activeAnimations.forEach(action => action.stop());
                });
                
                // 单个动画控制
                controlPanel.querySelectorAll('.playAnim').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (this.activeAnimations[index]) {
                            this.activeAnimations[index].play();
                        }
                    });
                });
                
                controlPanel.querySelectorAll('.pauseAnim').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (this.activeAnimations[index]) {
                            this.activeAnimations[index].paused = !this.activeAnimations[index].paused;
                        }
                    });
                });
                
                document.body.appendChild(controlPanel);
                
                // 3秒后自动淡化控制面板
                setTimeout(() => {
                    if (controlPanel.parentNode) {
                        controlPanel.style.opacity = '0.3';
                    }
                }, 3000);
            }

            setupFileUpload() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('glbUpload');
                
                // File input change
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        this.loadGLBModel(file);
                    }
                });
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#4CAF50';
                    uploadArea.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                });
                
                uploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '';
                    uploadArea.style.backgroundColor = '';
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '';
                    uploadArea.style.backgroundColor = '';
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        if (file.name.toLowerCase().endsWith('.glb') || file.name.toLowerCase().endsWith('.gltf')) {
                            this.loadGLBModel(file);
                        } else {
                            this.showNotification('Please drop a GLB or GLTF file', 'error');
                        }
                    }
                });
            }

            loadGLBModel(file) {
                this.showNotification('Loading aircraft model...', 'success');
                
                const loader = new GLTFLoader();
                const url = URL.createObjectURL(file);
                
                loader.load(url, (gltf) => {
                    // Remove existing aircraft if loaded model exists
                    if (this.loadedModel) {
                        this.scene.remove(this.loadedModel);
                        // 清理旧的动画混合器
                        if (this.modelAnimationMixer) {
                            this.modelAnimationMixer.stopAllAction();
                            this.modelAnimationMixer = null;
                        }
                    } else if (this.aircraft) {
                        this.scene.remove(this.aircraft);
                    }
                    
                    const model = gltf.scene;
                    
                    // === 动画系统设置 ===
                    this.modelAnimations = gltf.animations; // 存储动画数据
                    this.modelAnimationMixer = null;
                    this.activeAnimations = []; // 存储当前播放的动画
                    
                    // 如果模型包含动画，创建动画混合器
                    if (gltf.animations && gltf.animations.length > 0) {
                        this.modelAnimationMixer = new THREE.AnimationMixer(model);
                        
                        console.log(`Found ${gltf.animations.length} animations:`, gltf.animations.map(anim => anim.name));
                        
                        // 自动播放所有动画（通常用于螺旋桨、引擎等循环动画）
                        gltf.animations.forEach((clip, index) => {
                            const action = this.modelAnimationMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            action.clampWhenFinished = false;
                            
                            // 自动识别动画类型
                            const animName = clip.name.toLowerCase();
                            if (animName.includes('propeller') || 
                                animName.includes('rotor') || 
                                animName.includes('engine') ||
                                animName.includes('fan') ||
                                animName.includes('spin')) {
                                // 快速循环动画（螺旋桨等）
                                action.timeScale = 2.0; // 2倍速度
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing fast animation: ${clip.name}`);
                            } else if (animName.includes('idle') || 
                                      animName.includes('loop') ||
                                      clip.duration > 10) {
                                // 慢速循环动画
                                action.timeScale = 1.0;
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing slow animation: ${clip.name}`);
                            } else {
                                // 其他动画默认也播放
                                action.timeScale = 1.0;
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing animation: ${clip.name}`);
                            }
                        });
                        
                        this.showNotification(`Aircraft loaded with ${gltf.animations.length} animations!`, 'success');
                    } else {
                        this.showNotification('Aircraft loaded (no animations found)', 'success');
                    }
                    
                    // Calculate model bounding box to determine appropriate scale
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    
                    // Target size should be similar to default aircraft (wingspan ~18, length ~14)
                    const targetSize = 18; // Target wingspan/length
                    const currentMaxSize = Math.max(size.x, size.y, size.z);
                    const scaleRatio = targetSize / currentMaxSize;
                    
                    // Apply calculated scale (minimum 15x for very small models) and additional 1.5x multiplier
                    const finalScale = Math.max(scaleRatio, 15) * 1.5;
                    model.scale.set(finalScale, finalScale, finalScale);
                    
                    // Enhance materials for better lighting
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        this.enhanceMaterial(mat);
                                    });
                                } else {
                                    this.enhanceMaterial(child.material);
                                }
                            }
                        }
                    });
                    
                    model.position.copy(this.playerPosition);
                    this.loadedModel = model;
                    this.aircraft = model;
                    this.scene.add(model);
                    
                    // 显示动画控制面板（如果有动画）
                    if (gltf.animations && gltf.animations.length > 0) {
                        // 移除旧的控制面板
                        const oldPanel = document.getElementById('animationControls');
                        if (oldPanel) oldPanel.remove();
                        
                        // 显示新的动画控制面板
                        setTimeout(() => this.showAnimationControls(), 500);
                    }
                    
                    URL.revokeObjectURL(url);
                    
                }, undefined, (error) => {
                    console.error('Error loading GLB model:', error);
                    this.showNotification('Failed to load aircraft model', 'error');
                    URL.revokeObjectURL(url);
                });
            }

            enhanceMaterial(material) {
                // === 轻微增亮过暗材质 ===
                if (material.color && material.color.r + material.color.g + material.color.b < 0.3) {
                    material.color.multiplyScalar(1.5); // 降低到1.5倍，避免过曝
                }
                
                // === 适度优化PBR材质属性 ===
                if (material.metalness !== undefined) {
                    material.metalness = Math.min(material.metalness + 0.2, 0.6); // 适度增加金属度
                }
                if (material.roughness !== undefined) {
                    material.roughness = Math.max(material.roughness - 0.1, 0.4); // 适度降低粗糙度
                }
                
                // === 移除自发光效果 ===
                // 不添加自发光，使用自然光照
                
                // === 适度环境光响应 ===
                if (material.envMapIntensity !== undefined) {
                    material.envMapIntensity = 1.0; // 降低到1.0，自然反射
                }
                
                // === 确保材质响应光照 ===
                material.needsUpdate = true;
                
                // === 适度提升极暗材质 ===
                if (material.color && material.color.getHSL({}).l < 0.15) {
                    // 仅对极暗材质进行轻微调整
                    const hsl = material.color.getHSL({});
                    material.color.setHSL(hsl.h, hsl.s, Math.max(hsl.l, 0.2)); // 最低20%亮度
                }
            }

            setupKeyboardControls() {
                document.addEventListener('keydown', (event) => {
                    this.inputState.keys.add(event.code);
                });
                
                document.addEventListener('keyup', (event) => {
                    this.inputState.keys.delete(event.code);
                });
            }

            updateInputFromKeyboard(deltaTime) {
                const keys = this.inputState.keys;
                const turnSpeed = 1.5; // radians per second
                const pitchSpeed = 1.0; // radians per second  
                const speedChangeRate = 0.8; // speed change per second

                // Yaw controls (left/right turns)
                if (keys.has('KeyA') || keys.has('ArrowLeft')) {
                    this.inputState.yaw += turnSpeed * deltaTime;
                }
                if (keys.has('KeyD') || keys.has('ArrowRight')) {
                    this.inputState.yaw -= turnSpeed * deltaTime;
                }

                // Pitch controls (nose up/down)
                if (keys.has('KeyW') || keys.has('ArrowUp')) {
                    this.inputState.pitch = Math.min(this.inputState.pitch + pitchSpeed * deltaTime, Math.PI / 4);
                }
                if (keys.has('KeyS') || keys.has('ArrowDown')) {
                    this.inputState.pitch = Math.max(this.inputState.pitch - pitchSpeed * deltaTime, -Math.PI / 4);
                }

                // Roll controls (banking) - 允许360度翻转
                if (keys.has('KeyQ')) {
                    this.inputState.roll -= turnSpeed * deltaTime; // 移除限制，允许无限翻转
                } else if (keys.has('KeyE')) {
                    this.inputState.roll += turnSpeed * deltaTime; // 移除限制，允许无限翻转
                } else {
                    // Auto-level roll - 仅在接近水平时自动调平
                    const levelingSpeed = 2.0;
                    // 计算到最近的水平位置的距离
                    const normalizedRoll = ((this.inputState.roll % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                    let targetRoll = 0;
                    if (normalizedRoll > Math.PI) {
                        targetRoll = Math.PI * 2;
                    }
                    const rollDiff = Math.abs(normalizedRoll - targetRoll);
                    
                    // 只有在接近水平位置时才自动调平
                    if (rollDiff < Math.PI / 6) { // 30度范围内
                        if (Math.abs(this.inputState.roll) > 0.01) {
                            this.inputState.roll = THREE.MathUtils.lerp(this.inputState.roll, Math.round(this.inputState.roll / (Math.PI * 2)) * Math.PI * 2, deltaTime * levelingSpeed);
                        } else {
                            this.inputState.roll = Math.round(this.inputState.roll / (Math.PI * 2)) * Math.PI * 2;
                        }
                    }
                }

                // Speed controls
                if (keys.has('ShiftLeft') || keys.has('ShiftRight') || keys.has('Space')) {
                    this.inputState.speed = Math.min(this.inputState.speed + speedChangeRate * deltaTime, 1.0);
                }
                if (keys.has('ControlLeft') || keys.has('ControlRight') || keys.has('KeyX')) {
                    this.inputState.speed = Math.max(this.inputState.speed - speedChangeRate * deltaTime, 0.2);
                }

                // Auto-level pitch when no input
                if (!keys.has('KeyW') && !keys.has('KeyS') && 
                    !keys.has('ArrowUp') && !keys.has('ArrowDown')) {
                    const levelingSpeed = 2.0;
                    if (Math.abs(this.inputState.pitch) > 0.01) {
                        this.inputState.pitch = THREE.MathUtils.lerp(this.inputState.pitch, 0, deltaTime * levelingSpeed);
                    } else {
                        this.inputState.pitch = 0;
                    }
                }

                // Weather toggle
                if (keys.has('KeyR')) {
                    if (!this.rKeyPressed) {
                        this.toggleWeather();
                        this.rKeyPressed = true;
                    }
                } else {
                    this.rKeyPressed = false;
                }
            }

            updatePlayer(deltaTime) {
                if (!this.aircraft) return;

                // Update input from keyboard
                this.updateInputFromKeyboard(deltaTime);

                // Update speed based on input
                const maxSpeed = 120; // Maximum speed
                const targetSpeed = Math.max(this.inputState.speed * maxSpeed, 30); // Minimum 30 for flight
                this.playerSpeed = THREE.MathUtils.lerp(this.playerSpeed, targetSpeed, deltaTime * 2);

                // Calculate forward direction based on pitch and yaw
                const forward = new THREE.Vector3(0, 0, 1); // +Z is forward for our aircraft
                const rotation = new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll);
                forward.applyEuler(rotation);

                // Apply constant thrust in forward direction (this ensures the plane always moves forward)
                const thrust = forward.clone().multiplyScalar(this.playerSpeed);
                this.playerVelocity.copy(thrust); // Set velocity directly to thrust direction and speed

                // Apply lift when flying forward (simple aerodynamics)
                if (this.playerSpeed > 40) {
                    const liftStrength = Math.min(this.playerSpeed / 80, 1.0);
                    const liftDirection = new THREE.Vector3(0, 1, 0); // Upward
                    const lift = liftDirection.multiplyScalar(liftStrength * 25 * deltaTime);
                    this.playerVelocity.add(lift);
                }

                // Apply gravity
                const gravity = new THREE.Vector3(0, -30, 0);
                this.playerVelocity.add(gravity.multiplyScalar(deltaTime));

                // Light air resistance (much reduced)
                this.playerVelocity.multiplyScalar(1 - 0.1 * deltaTime);

                // Update position
                this.playerPosition.add(this.playerVelocity.clone().multiplyScalar(deltaTime));

                // === INFINITE LOOPING WORLD SYSTEM ===
                const worldBoundary = 4000; // 8000x8000地形的边界（从中心到边缘4000单位）
                let worldWrapped = false;
                
                // X轴边界检查
                if (this.playerPosition.x > worldBoundary) {
                    this.playerPosition.x = -worldBoundary + 1;
                    worldWrapped = true;
                } else if (this.playerPosition.x < -worldBoundary) {
                    this.playerPosition.x = worldBoundary - 1;
                    worldWrapped = true;
                }
                
                // Z轴边界检查
                if (this.playerPosition.z > worldBoundary) {
                    this.playerPosition.z = -worldBoundary + 1;
                    worldWrapped = true;
                } else if (this.playerPosition.z < -worldBoundary) {
                    this.playerPosition.z = worldBoundary - 1;
                    worldWrapped = true;
                }
                
                // 显示循环世界提示消息
                if (worldWrapped) {
                    this.showWrapMessage();
                }

                // Keep aircraft above ground
                if (this.playerPosition.y < 10) {
                    this.playerPosition.y = 10;
                    this.playerVelocity.y = Math.max(this.playerVelocity.y, 0);
                    this.playerVelocity.multiplyScalar(0.7); // Bounce damping
                }

                // Update aircraft position and rotation
                this.aircraft.position.copy(this.playerPosition);
                
                // Set aircraft rotation based on flight controls
                this.aircraft.rotation.set(
                    this.inputState.pitch,
                    this.inputState.yaw, 
                    this.inputState.roll
                );

                // === 移除动态光照跟踪，使用自然光照 ===
                // 不再需要专用光源跟随飞机

                // Update propeller animation
                this.updatePropeller(deltaTime);
                // bird flocks removed
            }

            updateCamera() {
                if (!this.aircraft) return;
                
                // Third-person camera following aircraft
                const distance = 80;
                const height = 30;
                
                // Calculate aircraft forward direction
                const forward = new THREE.Vector3(0, 0, 1);
                const rotation = new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll);
                forward.applyEuler(rotation);
                
                // Position camera behind and above aircraft
                const cameraOffset = forward.clone().multiplyScalar(-distance);
                cameraOffset.y += height;
                
                const targetPosition = this.playerPosition.clone().add(cameraOffset);
                
                // Smooth camera movement
                this.camera.position.lerp(targetPosition, 0.1);
                this.camera.lookAt(this.playerPosition);
            }

            updateClouds(deltaTime) {
                // Slowly move clouds
                this.clouds.forEach(cloud => {
                    cloud.position.x += Math.sin(Date.now() * 0.0001) * 0.1;
                    cloud.rotation.y += deltaTime * 0.1;
                });
            }

            hideLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                const progressFill = document.getElementById('progressFill');
                
                // Simulate loading progress
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 20;
                    if (progress >= 100) {
                        progress = 100;
                        progressFill.style.width = '100%';
                        
                        setTimeout(() => {
                            loadingScreen.style.opacity = '0';
                            loadingScreen.style.transition = 'opacity 1s ease';
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                            }, 1000);
                        }, 500);
                        
                        clearInterval(progressInterval);
                    }
                    progressFill.style.width = progress + '%';
                }, 100);
            }

            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification-${type}`;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }

            gameLoop() {
                const deltaTime = 0.016; // Approximately 60 FPS
                
                this.updatePlayer(deltaTime);
                this.updateCamera();
                this.updateClouds(deltaTime);
                this.updatePropeller(deltaTime);
                // Weapon updates
                this.tryFireGuns(deltaTime);
                this.updateBullets(deltaTime);
                this.updateTankIndicators(deltaTime);
                
                // === 更新GLB模型动画 ===
                if (this.modelAnimationMixer) {
                    const animationDelta = this.animationClock.getDelta();
                    this.modelAnimationMixer.update(animationDelta);
                }
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.gameLoop());
            }

            updatePropeller(deltaTime) {
                // Animate propeller spinning
                if (this.propeller) {
                    this.propeller.rotation.z += 30 * deltaTime; // Fast spinning around Z axis (forward motion)
                }
            }

            showWrapMessage() {
                // 防止消息过于频繁显示
                const currentTime = Date.now();
                if (currentTime - this.lastWrapMessageTime < 3000) return; // 3秒间隔
                
                this.lastWrapMessageTime = currentTime;
                
                // 创建提示消息
                const messages = [
                    "🌍 穿越至新的区域...",
                    "✈️ 飞向了星球的另一边",
                    "🗺️ 世界边缘传送中...",
                    "🌌 循环世界让你能无限探索"
                ];
                
                const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                
                // 显示临时消息
                const messageElement = document.createElement('div');
                messageElement.textContent = randomMessage;
                messageElement.style.cssText = `
                    position: fixed;
                    top: 20%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #00ff00;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-size: 18px;
                    font-family: 'Courier New', monospace;
                    z-index: 1000;
                    pointer-events: none;
                    animation: fadeInOut 3s ease-in-out;
                `;
                
                // 添加CSS动画
                if (!document.querySelector('#wrapMessageStyle')) {
                    const style = document.createElement('style');
                    style.id = 'wrapMessageStyle';
                    style.textContent = `
                        @keyframes fadeInOut {
                            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                            20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(messageElement);
                
                // 3秒后移除消息
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.parentNode.removeChild(messageElement);
                    }
                }, 3000);
            }
        }

        // Start the game
        const game = new SkyWarriors();
    </script>
</body>
</html>
