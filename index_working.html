<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Warriors - GLB Flight Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            overflow: hidden;
        }

        #backgroundVideo {
            position: absolute;
            top: 50%;
            left: 50%;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            transform: translate(-50%, -50%);
            z-index: -2;
            object-fit: cover;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: -1;
        }

        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            border-radius: 24px;
            background: rgba(0, 0, 0, 0.40);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .game-thumbnail {
            width: 120px;
            height: 80px;
            object-fit: cover;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .loading-text {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: pulse 2s infinite;
            font-weight: 600;
            letter-spacing: 2px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-status {
            font-size: 14px;
            opacity: 0.8;
            text-align: center;
            font-weight: 400;
        }

        #glbUpload {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 14px;
        }

        #fileInput {
            margin-top: 10px;
            padding: 8px;
            border: 2px dashed #4CAF50;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
        }

        #fileInput:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 12px;
            max-width: 300px;
        }

        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            color: white;
            font-size: 16px;
            display: none;
            text-align: center;
        }

        .notification-success {
            border-left: 4px solid #4CAF50;
        }

        .notification-error {
            border-left: 4px solid #f44336;
        }

        /* Scene Switcher Panel */
        #sceneSwitcher {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1200;
            background: rgba(0,0,0,0.65);
            padding: 10px 12px;
            border-radius: 10px;
            display: flex;
            gap: 6px;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 8px rgba(0,0,0,0.4);
        }
        #sceneSwitcher button {
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            color: #fff;
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 6px;
            letter-spacing: 1px;
            transition: background .25s, transform .15s, border-color .25s;
        }
        #sceneSwitcher button:hover { background: rgba(255,255,255,0.18); }
        #sceneSwitcher button:active { transform: scale(.9); }
        #sceneSwitcher button.active { background: linear-gradient(135deg,#3fa9ff,#1e62d0); border-color:#6fc3ff; }

        /* ===== Health Bars ===== */
        .health-bar-container {
            position: absolute;
            transform: translateX(-50%);
            z-index: 100;
            pointer-events: none;
        }
        
        .health-bar-bg {
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            margin-bottom: 2px;
        }
        
        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa00 50%, #44ff44 100%);
            border-radius: 2px;
            transition: width 0.3s ease, background-position 0.3s ease;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
        }
        
        .health-bar-text {
            font-size: 10px;
            color: white;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-weight: bold;
        }

        /* ===== Scoreboard & Name Prompt ===== */
        #scoreboardPanel {
            position: fixed; top: 10px; right: 10px; z-index: 1000;
            background: rgba(0,0,0,0.55); backdrop-filter: blur(6px);
            padding: 10px 14px; border:1px solid rgba(255,255,255,0.15); border-radius:10px; color:#fff;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen;
            width: 240px; max-height: 420px; overflow:auto; box-shadow:0 4px 14px rgba(0,0,0,0.4);
        }
        #scoreboardPanel h3 { margin:0 0 6px; font-size:15px; letter-spacing:0.5px; display:flex; align-items:center; justify-content:space-between; }
        #scoreboardPanel table { width:100%; border-collapse: collapse; font-size:12px; }
        #scoreboardPanel th, #scoreboardPanel td { text-align:left; padding:2px 4px; }
        #scoreboardPanel th { position: sticky; top:0; background: rgba(255,255,255,0.12); backdrop-filter: blur(2px); }
        #scoreboardPanel tr.highlight { background: rgba(255,255,255,0.15); }
        #scoreboardPanel .exportBtn { margin-top:6px; width:100%; background:#2d6be8; border:none; color:#fff; padding:6px 0; border-radius:6px; cursor:pointer; font-size:12px; }
        #scoreboardPanel .exportBtn:hover { background:#4782f5; }
        #playerNameDisplay { font-size:12px; margin-top:4px; color:#8fd1ff; }
        #namePromptOverlay { position:fixed; inset:0; background:rgba(0,0,0,0.72); display:flex; align-items:center; justify-content:center; z-index:2000; }
        #namePromptBox { background:#12161c; padding:26px 32px 32px; border-radius:14px; border:1px solid #2c343d; width:340px; color:#f0f4f8; box-shadow:0 10px 40px -8px rgba(0,0,0,0.7); font-family: system-ui; }
        #namePromptBox h2 { margin:0 0 14px; font-size:18px; letter-spacing:0.5px; }
        #namePromptBox input { width:100%; padding:10px 12px; background:#1d242c; border:1px solid #3a4652; border-radius:8px; color:#fff; font-size:14px; outline:none; }
        #namePromptBox input:focus { border-color:#5d9dff; box-shadow:0 0 0 2px rgba(93,157,255,0.25); }
        #namePromptBox button { margin-top:16px; width:100%; background:linear-gradient(135deg,#3498ff,#006bff); color:#fff; border:none; padding:11px 0; border-radius:9px; font-size:14px; cursor:pointer; font-weight:600; letter-spacing:0.5px; }
        #namePromptBox button:hover { filter:brightness(1.1); }
        #namePromptBox .note { font-size:12px; opacity:0.7; margin-top:10px; line-height:1.5; }
        /* Session real-time stats HUD */
        #hudStats {
            position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.45); padding:6px 14px; border:1px solid rgba(255,255,255,0.18);
            border-radius: 14px; color:#fff; font-size:13px; font-family: system-ui, Arial;
            letter-spacing: .5px; display:flex; gap:16px; align-items:center; z-index:1300;
            backdrop-filter: blur(4px);
        }
        #hudStats span.label { opacity:0.7; margin-right:4px; font-size:11px; text-transform:uppercase; }
        #hudStats .value { font-weight:600; color:#ffd560; }
        #hudStats .total { color:#7dff91; }
        
        /* Player Health Display */
        #playerHealthDisplay {
            position: fixed; top: 80px; right: 20px; z-index: 1200;
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(8px);
            padding: 12px 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 16px; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        #playerHealthDisplay.low-health {
            background: rgba(255, 50, 50, 0.8);
            border-color: rgba(255, 100, 100, 0.5);
            animation: healthWarning 1s ease-in-out infinite alternate;
        }
        
        @keyframes healthWarning {
            from { opacity: 0.8; }
            to { opacity: 1.0; }
        }
        
        @keyframes slideInFade {
            from { 
                opacity: 0; 
                transform: translateX(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hudStats" style="display:none;">
            <div><span class="label">Tanks</span><span id="hudTankKills" class="value">0</span></div>
            <div><span class="label">Ships</span><span id="hudShipKills" class="value">0</span></div>
            <div><span class="label">Total</span><span id="hudTotalKills" class="value total">0</span></div>
        </div>
        <div id="playerHealthDisplay" style="display:none;">
            Health: <span id="playerHealthValue">30</span>/30
        </div>
        <div id="loadingScreen">
            <video id="backgroundVideo" autoplay muted loop>
                <source src="loading-assets/background-video.mp4" type="video/mp4">
            </video>
            <div class="loading-overlay"></div>
            <div class="loading-content">
                <img src="loading-assets/plane.png" alt="Game Thumbnail" class="game-thumbnail">
                <div class="loading-text">SKY WARRIORS</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p class="loading-status">Loading 3D Environment...</p>
            </div>
        </div>

        <div id="glbUpload">
            <h3>Load Your Aircraft</h3>
            <p>Drop a GLB file here or click to browse:</p>
            <input type="file" id="fileInput" accept=".glb,.gltf" />
        </div>

        <div id="instructions">
            <h4>Flight Controls:</h4>
            <p><strong>WASD / Arrow Keys:</strong> Pitch (W/S) and Yaw (A/D) controls</p>
            <p><strong>Q / E:</strong> Roll left/right (360¬∞ barrel rolls available!)</p>
            <p><strong>Shift / Space:</strong> Increase throttle</p>
            <p><strong>Ctrl / X:</strong> Decrease throttle</p>
            <p><strong>C:</strong> Switch camera view (4 different angles)</p>
            <p><strong>R:</strong> Toggle weather (Rain/Sunny)</p>
            
            <h4 style="margin-top: 15px; color: #ffaa44;">Combat Guide:</h4>
            <p><strong>Left Click:</strong> Fire weapons to destroy tanks</p>
            <p><strong style="color: #ff6666;">‚ö†Ô∏è Watch out for AA tanks - destroy them quickly!</strong></p>
        </div>

        <div id="notification"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        class SkyWarriors {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.aircraft = null;
                this.loadedModel = null;
                
                // Player state
                this.playerPosition = new THREE.Vector3(0, 50, 0);
                this.playerVelocity = new THREE.Vector3(0, 0, 0);
                this.playerSpeed = 60; // Current speed in units/sec
                this.playerHealth = 30; // Player health (simple difficulty)
                this.playerMaxHealth = 30; // Maximum player health
                
                // Camera view system
                this.currentViewIndex = 0;
                this.viewModes = [
                    {
                        name: 'Chase View',
                        offset: new THREE.Vector3(0, 30, -80), // Behind and above
                        description: 'Default chase camera'
                    },
                    {
                        name: 'Northeast View', 
                        offset: new THREE.Vector3(100, 60, 100), // Northeast isometric
                        description: 'Northeast isometric view'
                    },
                    {
                        name: 'Northwest View',
                        offset: new THREE.Vector3(-100, 60, 100), // Northwest isometric  
                        description: 'Northwest isometric view'
                    },
                    {
                        name: 'Tactical View',
                        offset: new THREE.Vector3(0, 200, -50), // High above, slightly behind
                        description: 'Top-down tactical view'
                    }
                ];
                
                // Flight control state
                this.inputState = {
                    pitch: 0,    // Nose up/down rotation (-œÄ/4 to œÄ/4)
                    yaw: 0,      // Left/right turn rotation  
                    roll: 0,     // Banking rotation
                    speed: 0.6,  // Speed multiplier (0.2 to 1.0)
                    keys: new Set() // Currently pressed keys
                };

                // World wrapping system
                this.lastWrapMessageTime = 0;
                
                // === GLBÂä®ÁîªÁ≥ªÁªü ===
                this.modelAnimationMixer = null;      // Âä®ÁîªÊ∑∑ÂêàÂô®
                this.modelAnimations = [];            // Âä®ÁîªÁâáÊÆµÊï∞ÁªÑ
                this.activeAnimations = [];           // ÂΩìÂâçÊí≠ÊîæÁöÑÂä®Áîª
                this.animationClock = new THREE.Clock(); // Âä®ÁîªÊó∂Èíü
                
                // Terrain and environment
                this.terrain = [];
                this.clouds = [];
                // === Environment configuration ===
                // === Scene variant system ===
                // Supported: 'grassland' | 'snow' | 'desert' | 'ocean'
                this.sceneType = 'grassland';
                // Try read hash (#snow / #desert / #ocean / #grassland) for quick switching
                const hash = window.location.hash.replace('#','').toLowerCase();
                if(['snow','desert','ocean','grassland','default'].includes(hash)) {
                    // Backward compatibility: legacy 'default' maps to 'grassland'
                    this.sceneType = (hash === 'default') ? 'grassland' : (hash || 'grassland');
                }
                this.environmentConfig = this.getEnvironmentConfig(this.sceneType);
                // === Combat targets ===
                this.tanks = []; // ÈùôÊÄÅÂù¶ÂÖãÁõÆÊ†á { mesh, alive, radius }
                this.warships = []; // Êµ∑‰∏äÊàòËà∞ { mesh, alive, radius }
                // Raycaster for ground height sampling
                this.raycaster = new THREE.Raycaster();
                // --- Weapon system state (nose cannons) ---
                this.isFiring = false;          // ÊòØÂê¶Êåâ‰ΩèÂ∞ÑÂáª
                this.lastShotTime = 0;          // ‰∏äÊ¨°ÂèëÂ∞ÑÊó∂Èó¥ (s)
                this.fireInterval = 0.08;       // Â∞ÑÈÄüÈó¥Èöî ~12.5Âèë/Áßí
                this.bullets = [];              // Ê¥ªË∑ÉÂ≠êÂºπ
                this.enemyBullets = [];         // ÊïåÊñπÂ≠êÂºπ (AA tanks & warships)
                this.muzzleFlashes = [];        // Êû™Âè£ÁÅ´ÂÖâ
                this.gunBarrels = [];           // ÁÇÆÂè£ÂºïÁî®
                this.tempVec = new THREE.Vector3();
                this.forwardVec = new THREE.Vector3(0,0,1);
                
                // === Optimized smoke particle system ===
                // Removed complex continuous smoke system for performance
                // Using simple one-time explosion smoke instead
                
                
                // === Scoreboard & player identity ===
                this.playerName = null;
                this.scoreData = { players: {} }; // { name: { tank:0, ship:0, total:0, last:timestamp } }
                this.localStorageKey = 'skywarriors_scores_v1';
                // Session real-time counters (not persisted across reload)
                this.sessionKills = { tank:0, ship:0 };
                this.ensurePlayerName();
                this.loadScores();
                this.registerPlayerIfNeeded();
                this.updateScoreboardUI();
                
                this.init();
            }
            
            updatePlayerHealthDisplay() {
                const healthDisplay = document.getElementById('playerHealthDisplay');
                const healthValue = document.getElementById('playerHealthValue');
                
                if (healthDisplay && healthValue) {
                    healthDisplay.style.display = 'block';
                    healthValue.textContent = Math.max(0, Math.round(this.playerHealth));
                    
                    // Change color and add warning animation when health is low
                    if (this.playerHealth <= 10) {
                        healthDisplay.classList.add('low-health');
                    } else {
                        healthDisplay.classList.remove('low-health');
                    }
                }
            }

            init() {
                this.setupScene();
                this.setupLighting();
                this.createTerrain();
                this.createClouds();
                this.createDefaultAircraft();
                this.createNoseCannons(); // Êú∫Â§¥Êú∫ÁÇÆ
                this.setupFileUpload();
                this.setupKeyboardControls();
                this.setupMouseControls(); // Èº†Ê†áÂ∞ÑÂáª
                this.setupSceneSwitcher(); // Scene switching UI
                this.hideLoadingScreen();
                this.gameLoop();
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                // Fog / background by scene type
                const fogColors = {
                    default: 0x87CEEB,
                    snow: 0xdbe9f5,
                    desert: 0xe2c27b,
                    ocean: 0x6fb2ff
                };
                const fogColor = fogColors[this.sceneType] || 0x87CEEB;
                this.scene.fog = new THREE.Fog(fogColor, 100, 2000);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.camera.position.set(0, 100, 200);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(fogColor, 1);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupLighting() {
                // === Ëá™ÁÑ∂ÁéØÂ¢ÉÂÖâ - Ê®°ÊãüÊô¥Â§©ÊüîÂíåÂÖâÁÖß ===
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Èôç‰ΩéÂà∞0.6ÔºåËá™ÁÑ∂ÊüîÂíå
                this.scene.add(ambientLight);
                
                // === Ëá™ÁÑ∂Â§™Èò≥ÂÖâ - Ê®°ÊãüÁúüÂÆûÊô¥Â§©Èò≥ÂÖâ ===
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Èôç‰ΩéÂà∞1.0ÔºåËá™ÁÑ∂Âº∫Â∫¶
                directionalLight.position.set(100, 300, 100); // ‰øùÊåÅËá™ÁÑ∂ËßíÂ∫¶
                directionalLight.castShadow = true;
                
                // ‰ºòÂåñÈò¥ÂΩ±Ë¥®Èáè
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 2000;
                directionalLight.shadow.camera.left = -1000;
                directionalLight.shadow.camera.right = 1000;
                directionalLight.shadow.camera.top = 1000;
                directionalLight.shadow.camera.bottom = -1000;
                directionalLight.shadow.bias = -0.0001;
                this.scene.add(directionalLight);
                
                // === Ëá™ÁÑ∂Â§©Á©∫ÂÖâ - Ê®°ÊãüÂ§©Á©∫Êï£Â∞ÑÂÖâ ===
                const skyLight = new THREE.HemisphereLight(
                    0x87CEEB,  // Â§©Á©∫ËìùËâ≤
                    0x5D8A3A,  // Âú∞Èù¢ÁªøËâ≤
                    0.4        // Èôç‰ΩéÂà∞0.4ÔºåÊüîÂíåÂ§©Á©∫ÂÖâ
                );
                skyLight.position.set(0, 500, 0);
                this.scene.add(skyLight);
                
                // === ÁßªÈô§ËøáÂº∫ÁöÑÈ£ûÊú∫‰∏ìÁî®ËÅöÂÖâÁÅØ ===
                // ‰∏çÂÜçÊ∑ªÂä†‰∏ìÁî®ËÅöÂÖâÁÅØÔºå‰ΩøÁî®Ëá™ÁÑ∂ÂÖâÁÖß
                
                // === ËΩªÂæÆË°•ÂÖâÁ≥ªÁªü - ‰ªÖÁî®‰∫éÊ∂àÈô§ËøáÊöóÈò¥ÂΩ± ===
                const fillLights = [
                    { pos: [200, 100, 0], intensity: 0.2 },    // Âè≥‰æßËΩªÂæÆË°•ÂÖâ
                    { pos: [-200, 100, 0], intensity: 0.2 },   // Â∑¶‰æßËΩªÂæÆË°•ÂÖâ
                    { pos: [0, 100, 200], intensity: 0.15 },   // ÂâçÊñπËΩªÂæÆË°•ÂÖâ
                    { pos: [0, 100, -200], intensity: 0.15 }   // ÂêéÊñπËΩªÂæÆË°•ÂÖâ
                ];
                
                fillLights.forEach(light => {
                    const fillLight = new THREE.DirectionalLight(0xffffff, light.intensity);
                    fillLight.position.set(light.pos[0], light.pos[1], light.pos[2]);
                    fillLight.castShadow = false; // Ë°•ÂÖâ‰∏ç‰∫ßÁîüÈò¥ÂΩ±
                    this.scene.add(fillLight);
                });
                
                // === ÁßªÈô§GLB‰∏ìÁî®Â¢ûÂº∫ÂÖâ ===
                // ‰∏çÂÜçÊ∑ªÂä†‰∏ìÁî®Â¢ûÂº∫ÂÖâÔºå‰ΩøÁî®Ëá™ÁÑ∂ÂÖâÁÖß
            }

            createTerrain() {
                // Ground plane base
                const groundGeometry = new THREE.PlaneGeometry(8000, 8000, 150, 150);
                let groundColor = 0x5D8A3A; // default grass
                if (this.sceneType === 'snow') groundColor = 0xF2F6F9;
                else if (this.sceneType === 'desert') groundColor = 0xD9C190;
                else if (this.sceneType === 'ocean') groundColor = 0x1b4f8a; // seabed (deep)
                const groundMaterial = new THREE.MeshLambertMaterial({ color: groundColor, wireframe: false });
                
                // Add some height variation to the ground
                const vertices = groundGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.random() * 15 - 7; // ÂáèÂ∞ëÂú∞Èù¢Ëµ∑‰ºèÔºåÊõ¥Âπ≥Âù¶
                }
                groundGeometry.attributes.position.needsUpdate = true;
                groundGeometry.computeVertexNormals();
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -50;
                ground.receiveShadow = true;
                this.scene.add(ground);
                // ‰øùÂ≠òÂú∞Èù¢ÂºïÁî®Áî®‰∫éÈ´òÂ∫¶ÈááÊ†∑
                this.ground = ground;
                
                if (this.sceneType === 'snow') {
                    this.createSnowMountains();
                    this.createConiferForests();
                    // Frozen lakes (reuse lakes with pale blue)
                    this.createLakes(0xbdd9f2, true);
                } else if (this.sceneType === 'desert') {
                    this.createDesertDunes();
                    this.createPyramids();
                    this.createDesertPlants();
                } else if (this.sceneType === 'ocean') {
                    this.createOceanSurface();
                    this.createSmallIslands();
                    this.createWarships(6);
                } else { // grassland (formerly 'default')
                    this.createMountainRanges();
                    this.createTrees();
                    this.createLakes();
                    this.createSoilPatches(this.environmentConfig.soilPatchCount);
                    if (this.environmentConfig.rockCount > 0) this.createRocks(this.environmentConfig.rockCount);
                    this.createGrassPatches(this.environmentConfig.grassPatchCount);
                    for (let i=0;i<this.environmentConfig.bushClusterCount;i++) {
                        this.createBushCluster((Math.random()-0.5)*6500,(Math.random()-0.5)*6500,6+Math.random()*8);
                    }
                    if (this.environmentConfig.birdFlocks > 0) {
                        for (let i=0;i<this.environmentConfig.birdFlocks;i++) this.createBirdFlock();
                    }
                }
                // Tanks only in non-ocean scene; warships already handled in ocean branch
                if (this.sceneType !== 'ocean') this.createTanks(30);
            }

            getEnvironmentConfig(type){
                // Map legacy 'default' to new canonical 'grassland'
                if (type === 'default') type = 'grassland';
                switch(type){
                    case 'snow':
                        return { treeDensityMultiplier: 1.8, rockCount: 10, grassPatchCount: 40, bushClusterCount: 20, birdFlocks:0, soilPatchCount:20 };
                    case 'desert':
                        return { treeDensityMultiplier: 0.4, rockCount: 5, grassPatchCount: 0, bushClusterCount: 5, birdFlocks:0, soilPatchCount:10 };
                    case 'ocean':
                        return { treeDensityMultiplier: 0, rockCount: 0, grassPatchCount: 0, bushClusterCount: 0, birdFlocks:0, soilPatchCount:0 };
                    case 'grassland':
                    default:
                        return { treeDensityMultiplier: 2.8, rockCount: 0, grassPatchCount: 180, bushClusterCount: 70, birdFlocks:0, soilPatchCount:120 };
                }
            }

            // ===== Snow Scene Helpers =====
            createSnowMountains(){
                this.createMountainRange(-2500,-1500,7,'high',0xd8dfe6);
                this.createMountainRange(2600,2100,6,'high',0xcfd8de);
                for(let i=0;i<20;i++) this.createSingleMountain((Math.random()-0.5)*7000,(Math.random()-0.5)*7000,'random',0xe0e7ec);
            }
            createConiferForests(){
                for(let i=0;i<140;i++) this.createTree((Math.random()-0.5)*6500,(Math.random()-0.5)*6500,'pine');
            }

            // ===== Desert Scene Helpers =====
            createDesertDunes(){
                // gentle height noise already added; add some dune ridges as low hills
                for(let i=0;i<40;i++){
                    const geo = new THREE.ConeGeometry(120+Math.random()*180, 30+Math.random()*25, 12);
                    geo.scale(2.5,0.4,1.2);
                    const mat = new THREE.MeshLambertMaterial({ color: 0xE3D2A1 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set((Math.random()-0.5)*7000,-35,(Math.random()-0.5)*7000);
                    m.rotation.y = Math.random()*Math.PI;
                    m.castShadow = true; m.receiveShadow = true;
                    this.scene.add(m);
                }
            }
            createPyramids(){
                const pyramidMat = new THREE.MeshLambertMaterial({ color: 0xC9B065 });
                for(let i=0;i<5;i++){
                    const size = 200 + Math.random()*160;
                    const geo = new THREE.ConeGeometry(size/2, size/1.2, 4);
                    const p = new THREE.Mesh(geo, pyramidMat);
                    p.rotation.y = Math.PI/4;
                    p.position.set((Math.random()-0.5)*6000, -50 + size/2.4, (Math.random()-0.5)*6000);
                    p.castShadow = true; p.receiveShadow = true;
                    this.scene.add(p);
                }
            }
            createDesertPlants(){
                // Populus euphratica (ËÉ°Êù®) simplified tall trunk + sparse crown
                for(let i=0;i<60;i++){
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.7,18,6), new THREE.MeshLambertMaterial({ color:0x8b5a2b }));
                    const crown = new THREE.Mesh(new THREE.SphereGeometry(5,8,6), new THREE.MeshLambertMaterial({ color:0xd4c98a }));
                    crown.position.y = 10;
                    const g = new THREE.Group(); g.add(trunk); g.add(crown);
                    g.position.set((Math.random()-0.5)*7000,-50,(Math.random()-0.5)*7000);
                    this.scene.add(g);
                }
                // Cactus
                for(let i=0;i<120;i++){
                    const h = 6 + Math.random()*10;
                    const main = new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.9,h,6), new THREE.MeshLambertMaterial({ color:0x2f6f3b }));
                    const group = new THREE.Group(); group.add(main);
                    if(Math.random()>0.5){
                        const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5, h*0.5,6), main.material);
                        arm.position.y = h*0.4; arm.position.x = 0.9; arm.rotation.z = Math.PI/10;
                        group.add(arm);
                    }
                    group.position.set((Math.random()-0.5)*7000,-50,(Math.random()-0.5)*7000);
                    this.scene.add(group);
                }
                // Sea-buckthorn (Ê≤ôÊ£ò) as low orange shrubs
                for(let i=0;i<160;i++){
                    const r = 1.5 + Math.random()*2.5;
                    const shrub = new THREE.Mesh(new THREE.SphereGeometry(r,8,6), new THREE.MeshLambertMaterial({ color:0xd9922e }));
                    shrub.position.set((Math.random()-0.5)*7200,-50 + r*0.4,(Math.random()-0.5)*7200);
                    shrub.castShadow = true; this.scene.add(shrub);
                }
            }

            // ===== Ocean Scene Helpers =====
            createOceanSurface(){
                // Add reflective water-like plane (simple material placeholder)
                const water = new THREE.Mesh(new THREE.PlaneGeometry(8000,8000,50,50), new THREE.MeshLambertMaterial({ color:0x2f7dd1, transparent:true, opacity:0.95 }));
                water.rotation.x = -Math.PI/2; water.position.y = -40; water.receiveShadow = true;
                this.scene.add(water);
            }
            createSmallIslands(){
                for(let i=0;i<18;i++){
                    const rad = 120 + Math.random()*140;
                    const geo = new THREE.CircleGeometry(rad, 24);
                    const mat = new THREE.MeshLambertMaterial({ color:0xc8c087 });
                    const isl = new THREE.Mesh(geo, mat);
                    isl.rotation.x = -Math.PI/2;
                    isl.position.set((Math.random()-0.5)*6000,-49.5,(Math.random()-0.5)*6000);
                    this.scene.add(isl);
                    // palm or pine few trees reused
                    for(let t=0;t<5;t++) this.createTree(isl.position.x + (Math.random()-0.5)*rad, isl.position.z + (Math.random()-0.5)*rad, 'palm');
                }
            }

            createMountainRanges() {
                // 1. ÈõÑ‰ºüÁöÑÈ´òÂ±±ËÑâ
                this.createMountainRange(-3000, -2000, 8, 'high', 0x8b7355);
                this.createMountainRange(2500, 2200, 6, 'high', 0x696969);
                
                // 2. ‰∏≠Á≠âÂ±±‰∏ò
                this.createMountainRange(-1500, 2800, 5, 'medium', 0xA0522D);
                this.createMountainRange(3200, -1200, 7, 'medium', 0x8b7355);
                
                // 3. ‰ΩéÁüÆ‰∏òÈôµ
                this.createMountainRange(0, 3500, 4, 'low', 0x9ACD32);
                this.createMountainRange(-2800, 1000, 5, 'low', 0x228B22);
                
                // 4. Áã¨Á´ãÂ±±Â≥∞
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 7000;
                    const z = (Math.random() - 0.5) * 7000;
                    this.createSingleMountain(x, z, 'random');
                }
            }

            createMountainRange(centerX, centerZ, count, type, color) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = 200 + Math.random() * 300;
                    const x = centerX + Math.cos(angle) * radius;
                    const z = centerZ + Math.sin(angle) * radius;
                    this.createSingleMountain(x, z, type, color);
                }
            }

            createSingleMountain(x, z, type, color) {
                let height, baseRadius, shape, mountainColor;
                switch(type) {
                    case 'high':
                        height = 120 + Math.random()*110;
                        baseRadius = 50 + Math.random()*40;
                        shape = Math.random()<0.2 ? 'ridge' : (Math.random()<0.4 ? 'mesa' : 'cone');
                        mountainColor = color || 0x7a6550; break;
                    case 'medium':
                        height = 70 + Math.random()*60;
                        baseRadius = 40 + Math.random()*30;
                        shape = Math.random()<0.3 ? 'pyramid' : (Math.random()<0.55 ? 'dome' : 'cone');
                        mountainColor = color || 0x9c6233; break;
                    case 'low':
                        height = 30 + Math.random()*45;
                        baseRadius = 32 + Math.random()*22;
                        shape = Math.random()<0.5 ? 'dome' : 'ridge';
                        mountainColor = color || 0x6fae3b; break;
                    default:
                        return this.createSingleMountain(x, z, ['high','medium','low'][Math.floor(Math.random()*3)]);
                }
                if (Math.random()<0.08) shape = 'crater';
                let mountainGeometry;
                switch(shape) {
                    case 'cone':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 10 + Math.floor(Math.random()*5)); break;
                    case 'pyramid':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 4); break;
                    case 'dome':
                        mountainGeometry = new THREE.SphereGeometry(baseRadius, 12, 8,0,Math.PI*2,0,Math.PI/2); mountainGeometry.scale(1,height/baseRadius,1); break;
                    case 'mesa': {
                        const base = new THREE.CylinderGeometry(baseRadius*0.8, baseRadius, height*0.65, 10);
                        const top = new THREE.CylinderGeometry(baseRadius*0.55, baseRadius*0.6, height*0.15, 10); top.translate(0,height*0.4,0);
                        mountainGeometry = BufferGeometryUtils ? BufferGeometryUtils.mergeGeometries([base, top]) : base; break;
                    }
                    case 'ridge':
                        mountainGeometry = new THREE.ConeGeometry(baseRadius, height, 6); mountainGeometry.scale(1.8,1,0.6); break;
                    case 'crater':
                        mountainGeometry = new THREE.CylinderGeometry(baseRadius*1.3, baseRadius*1.4, height*0.5, 24,1,true); break;
                }
                const posAttr = mountainGeometry.attributes.position;
                for (let i=0;i<posAttr.count;i++) {
                    const vx = posAttr.getX(i), vy = posAttr.getY(i), vz = posAttr.getZ(i);
                    const noise = (Math.sin(vx*0.15)+Math.sin(vz*0.18))*0.6 + (Math.random()-0.5)*0.9;
                    posAttr.setY(i, vy + noise*2);
                    posAttr.setX(i, vx + (Math.random()-0.5)*0.8);
                    posAttr.setZ(i, vz + (Math.random()-0.5)*0.8);
                }
                posAttr.needsUpdate = true;
                mountainGeometry.computeVertexNormals();
                const hFactor = THREE.MathUtils.clamp((height-40)/140,0,1);
                const baseColor = new THREE.Color(mountainColor);
                const tint = new THREE.Color().setHSL(0.08 + 0.1*hFactor, 0.35, 0.25 + 0.25*hFactor);
                baseColor.lerp(tint,0.4);
                // === ÂØπÈΩêÂà∞Âú∞Èù¢Èò≤Ê≠¢ÊÇ¨ÊµÆ ===
                mountainGeometry.computeBoundingBox();
                const bbox = mountainGeometry.boundingBox;
                const GROUND_Y = -50;
                // ËÆ°ÁÆóÂ∞ÜÂá†‰ΩïÂ∫ïÈÉ®Ë¥¥Âà∞Âú∞Èù¢ÁöÑ‰∏≠ÂøÉ Y
                const placeY = GROUND_Y - bbox.min.y; // ‰Ωø (placeY + bbox.min.y) == GROUND_Y
                const mountainMaterial = new THREE.MeshLambertMaterial({ color: baseColor });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(x, placeY, z);
                mountain.rotation.y = Math.random()*Math.PI*2;
                mountain.castShadow = true; mountain.receiveShadow = true;
                mountain.userData.type = 'mountain';
                this.scene.add(mountain);
                // Èõ™È°∂ÈáçÊñ∞Âü∫‰∫éÂÆûÈôÖÊúÄÈ´òÁÇπÊîæÁΩÆ
                if (height > 110) {
                    const snowHeight = height*0.25;
                    const snow = new THREE.Mesh(new THREE.ConeGeometry(baseRadius*0.35, snowHeight, 10), new THREE.MeshLambertMaterial({ color: 0xf5f7f8 }));
                    const topY = mountain.position.y + bbox.max.y; // Â±±‰ΩìÊúÄÈ´òÁÇπ
                    // ÊîæÂú®ÊúÄÈ´òÁÇπÁ®ç‰Ωé‰∏ÄÁÇπÔºå‰øùÊåÅË¥¥Âêà
                    snow.position.set(x, topY - height*0.12, z);
                    snow.castShadow = false; snow.receiveShadow = true;
                    this.scene.add(snow);
                }
            }

            // === createTerrain ÂáΩÊï∞ÁªìÊùü ===

            createClouds() {
                // Â¢ûÂä†‰∫ëÊúµÊï∞ÈáèÂπ∂Êâ©Â§ßÂàÜÂ∏ÉËåÉÂõ¥Âà∞Êñ∞ÁöÑ8000x8000Âú∞ÂΩ¢
                for (let i = 0; i < 60; i++) { // Increased from 30 to 60
                    const cloudGeometry = new THREE.SphereGeometry(20 + Math.random() * 30, 8, 6);
                    const cloudMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.7
                    });
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    
                    cloud.position.set(
                        (Math.random() - 0.5) * 6000,  // ‰ªé 2000 Êâ©Â§ßÂà∞ 6000
                        100 + Math.random() * 200,
                        (Math.random() - 0.5) * 6000   // ‰ªé 2000 Êâ©Â§ßÂà∞ 6000
                    );
                    
                    cloud.scale.set(
                        1 + Math.random() * 0.5,
                        0.3 + Math.random() * 0.3,
                        1 + Math.random() * 0.5
                    );
                    
                    this.clouds.push(cloud);
                    this.scene.add(cloud);
                }
            }

            createDefaultAircraft() {
                console.log('Attempting to load red-plane.glb...');
                
                // Direct GLTFLoader approach with proper HTTP path
                const loader = new GLTFLoader();
                const modelPath = 'red-plane.glb';
                console.log('Loading from path:', modelPath);
                
                loader.load(modelPath, (gltf) => {
                    console.log('‚úÖ Successfully loaded red-plane.glb');
                    const model = gltf.scene;
                    
                    // Scale the aircraft to be similar size as tanks (around 46 units)
                    const targetSize = 46; // Similar to tank length
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const currentMaxSize = Math.max(size.x, size.y, size.z);
                    const scaleRatio = targetSize / currentMaxSize;
                    
                    model.scale.set(scaleRatio, scaleRatio, scaleRatio);
                    console.log(`Red plane scaled: ${currentMaxSize.toFixed(2)} ‚Üí ${targetSize} units (${scaleRatio.toFixed(3)}x)`);
                    
                    // === Âä®ÁîªÁ≥ªÁªüËÆæÁΩÆ ===
                    this.modelAnimations = gltf.animations; // Â≠òÂÇ®Âä®ÁîªÊï∞ÊçÆ
                    this.modelAnimationMixer = null;
                    this.activeAnimations = []; // Â≠òÂÇ®ÂΩìÂâçÊí≠ÊîæÁöÑÂä®Áîª
                    
                    // Â¶ÇÊûúÊ®°ÂûãÂåÖÂê´Âä®ÁîªÔºåÂàõÂª∫Âä®ÁîªÊ∑∑ÂêàÂô®
                    if (gltf.animations && gltf.animations.length > 0) {
                        this.modelAnimationMixer = new THREE.AnimationMixer(model);
                        
                        console.log(`Red plane: Found ${gltf.animations.length} animations:`, gltf.animations.map(anim => anim.name));
                        
                        // Ëá™Âä®Êí≠ÊîæÊâÄÊúâÂä®ÁîªÔºàÈÄöÂ∏∏Áî®‰∫éËû∫ÊóãÊ°®„ÄÅÂºïÊìéÁ≠âÂæ™ÁéØÂä®ÁîªÔºâ
                        gltf.animations.forEach((clip, index) => {
                            const action = this.modelAnimationMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            action.clampWhenFinished = false;
                            
                            // Ëá™Âä®ËØÜÂà´Âä®ÁîªÁ±ªÂûã
                            const animName = clip.name.toLowerCase();
                            if (animName.includes('propeller') || 
                                animName.includes('rotor') || 
                                animName.includes('engine') ||
                                animName.includes('fan') ||
                                animName.includes('spin')) {
                                // Âø´ÈÄüÂæ™ÁéØÂä®ÁîªÔºàËû∫ÊóãÊ°®Á≠âÔºâ
                                action.timeScale = 2.0; // 2ÂÄçÈÄüÂ∫¶
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing fast animation: ${clip.name}`);
                            } else {
                                // ÂÖ∂‰ªñÂä®ÁîªÈªòËÆ§‰πüÊí≠Êîæ
                                action.timeScale = 1.0;
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing animation: ${clip.name}`);
                            }
                        });
                    }
                    
                    // Enhance materials for better lighting
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        this.enhanceMaterial(mat);
                                    });
                                } else {
                                    this.enhanceMaterial(child.material);
                                }
                            }
                        }
                    });
                    
                    model.position.copy(this.playerPosition);
                    this.loadedModel = model;
                    this.aircraft = model;
                    model.userData.aircraftType = 'red-plane-glb'; // Ê†áËÆ∞‰∏∫GLBÈ£ûÊú∫
                    this.scene.add(model);
                    
                    console.log('‚úÖ RED PLANE GLB ADDED TO SCENE at position:', model.position);
                    console.log('‚úÖ Aircraft type set to:', model.userData.aircraftType);
                    
                    // Create nose cannons
                    this.createNoseCannons();
                    
                    console.log('Red plane loaded as default aircraft');
                }, undefined, (error) => {
                    console.error('‚ùå GLTFLoader error:', error);
                    console.log('üîÑ Falling back to built-in aircraft');
                    this.createBuiltInAircraft();
                });
            }
            
            createBuiltInAircraft() {
                // Create enhanced P-51 Mustang style fighter aircraft with premium materials
                const planeGroup = new THREE.Group();
                
                // === PREMIUM MATERIALS ===
                const fuselageMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xD3D3D3, // Êñ∞Êú∫Ë∫´ÊµÖÁÅ∞
                    metalness: 0.9,
                    roughness: 0.35,
                    envMapIntensity: 1.0
                });
                
                // Wing material switched to wood-like (low metalness, higher roughness) while keeping original color
                const wingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xE14A32, // È¢úËâ≤‰øùÊåÅ‰∏çÂèò
                    metalness: 0.05,
                    roughness: 0.85
                });
                
                const glassMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.25,
                    metalness: 0.0,
                    roughness: 0.0
                });
                
                const darkMetalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x5E5E5E, // Êú∫Â§¥ / Êï¥ÊµÅÁΩ©Áî®Ëâ≤
                    metalness: 0.95,
                    roughness: 0.4
                });
                
                // === ENHANCED FUSELAGE (Êú∫Ë∫´) ===
                const fuselageGeometry = new THREE.CylinderGeometry(1.4, 0.7, 16, 16);
                const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                fuselage.rotation.x = Math.PI / 2;
                fuselage.position.set(0, 0, 0);
                fuselage.castShadow = true;
                fuselage.receiveShadow = true;
                planeGroup.add(fuselage);
                
                // === DETAILED NOSE CONE (Êú∫Èºª) ===
                // Nose shortened by 25% (height 4 -> 3)
                const noseGeometry = new THREE.ConeGeometry(1.4, 3, 16);
                const nose = new THREE.Mesh(noseGeometry, fuselageMaterial);
                nose.position.set(0, 0, 10); // center unchanged; tip moves back 0.5
                nose.rotation.x = Math.PI / 2;
                nose.castShadow = true;
                nose.receiveShadow = true;
                planeGroup.add(nose);
                
                // === ENGINE COWLING (ÂèëÂä®Êú∫Êï¥ÊµÅÁΩ©) ===
                const cowlingGeometry = new THREE.CylinderGeometry(1.6, 1.4, 3, 12);
                const cowling = new THREE.Mesh(cowlingGeometry, darkMetalMaterial);
                cowling.rotation.x = Math.PI / 2;
                cowling.position.set(0, 0, 6.5);
                cowling.castShadow = true;
                planeGroup.add(cowling);
                
                // === REALISTIC WINGS (ÁúüÂÆûÊú∫Áøº) ===
                // Wing root section
                const wingRootGeometry = new THREE.BoxGeometry(4, 0.8, 4);
                const wingRoot = new THREE.Mesh(wingRootGeometry, wingMaterial);
                wingRoot.position.set(0, -0.2, -1);
                wingRoot.castShadow = true;
                planeGroup.add(wingRoot);
                
                // Tapered wing sections for realistic shape
                for (let side = -1; side <= 1; side += 2) {
                    for (let section = 1; section <= 6; section++) {
                        const width = 4 - (section * 0.4);
                        const thickness = 0.8 - (section * 0.08);
                        const wingGeometry = new THREE.BoxGeometry(width, thickness, 3);
                        const wingSection = new THREE.Mesh(wingGeometry, wingMaterial);
                        wingSection.position.set(side * section * 1.8, -0.2 - (section * 0.02), -1);
                        wingSection.castShadow = true;
                        planeGroup.add(wingSection);
                    }
                }
                
                // === CLEAN WING TIPS (ÁÆÄÊ¥ÅÁøºÂ∞ñ) ===
                // ÁßªÈô§Â•áÊÄ™ÁöÑÂçäÁêÉÂΩ¢ÁøºÂ∞ñÔºåÊîπ‰∏∫ÁÆÄÊ¥ÅÁöÑÊ§≠ÂúÜÁøºÂ∞ñ
                const wingTipGeometry = new THREE.BoxGeometry(1, 0.4, 2);
                for (let side = -1; side <= 1; side += 2) {
                    const wingTip = new THREE.Mesh(wingTipGeometry, wingMaterial);
                    wingTip.position.set(side * 10.8, -0.3, -1);
                    wingTip.castShadow = true;
                    planeGroup.add(wingTip);
                }
                
                // === TAIL SECTION (Â∞æÁøº) ===
                const tailGeometry = new THREE.CylinderGeometry(0.6, 0.4, 4, 8);
                const tail = new THREE.Mesh(tailGeometry, fuselageMaterial);
                tail.rotation.x = Math.PI / 2;
                tail.position.set(0, 0, -8);
                tail.castShadow = true;
                planeGroup.add(tail);
                
                // === HORIZONTAL STABILIZER (Ê∞¥Âπ≥Â∞æÁøº) ÈáçÊñ∞Âà∂‰ΩúÔºöÁº©ÊîæÁâà‰∏ªÁøº (40% span) ===
                // Ê®°‰ªø‰∏ªÁøºÁöÑÂàÜÊÆµÈÄíÂáèÔºå‰ΩÜÊï¥‰ΩìË∑®Â∫¶‰∏éÂêÑÂ∞∫ÂØ∏Áº©ÊîæËá≥ 40%
                (function(){
                    const tailGroup = new THREE.Group();
                    const spanScale = 0.4;          // Áõ∏ÂØπ‰∏ªÁøºÊØî‰æã
                    const sections = 6;             // ‰∏é‰∏ªÁøºÁõ∏ÂêåÂàÜÊÆµÊï∞
                    const baseWidth = 4;            // ‰∏ªÁøº root ÊÆµÂÆΩ(Ê≤øX) ÂèÇËÄÉ
                    const baseThickness = 0.8;      // ‰∏ªÁøº root ÂéöÂ∫¶ÂèÇËÄÉ
                    const chordBase = 4;            // ‰∏ªÁøº root chord (Ê≤øZ) ÂèÇËÄÉ
                    // Root central block
                    const rootWidth = baseWidth * spanScale;
                    const rootThickness = baseThickness * 0.6 * spanScale; // Êõ¥ËñÑ
                    const rootChord = chordBase * 0.55; // Â∞æÁøº chord ÂáèÁü≠
                    const rootGeo = new THREE.BoxGeometry(rootWidth, rootThickness, rootChord);
                    const rootMesh = new THREE.Mesh(rootGeo, wingMaterial);
                    rootMesh.position.set(0, 0, -10);
                    rootMesh.castShadow = true;
                    tailGroup.add(rootMesh);
                    // Side tapered sections
                    for (let side = -1; side <= 1; side += 2) {
                        for (let s = 1; s <= sections; s++) {
                            const width = (baseWidth - s * 0.4) * spanScale;
                            const thickness = (baseThickness - s * 0.08) * 0.6 * spanScale;
                            const chord = (chordBase - s * 0.35) * 0.55; // Ê∏êÁº©Âº¶Èïø
                            if (width <= 0.2 || thickness <= 0.02) continue;
                            const geo = new THREE.BoxGeometry(width, thickness, Math.max(chord, 0.6));
                            const mesh = new THREE.Mesh(geo, wingMaterial);
                            mesh.position.set(side * (s * 1.8 * spanScale), -0.02 - s * 0.01, -10);
                            mesh.rotation.y = side * THREE.MathUtils.degToRad(1 + s * 0.6); // ËΩªÂæÆÂêéÊé†
                            mesh.castShadow = true;
                            tailGroup.add(mesh);
                        }
                        // Tip
                        const tipGeo = new THREE.BoxGeometry(0.9 * spanScale, 0.35 * spanScale, 1.2 * 0.55);
                        const tip = new THREE.Mesh(tipGeo, wingMaterial);
                        tip.position.set(side * (sections * 1.8 * spanScale + 0.3), -0.1, -10);
                        tip.castShadow = true;
                        tailGroup.add(tip);
                    }
                    planeGroup.add(tailGroup);
                })();
                
                // === VERTICAL STABILIZER (ÂûÇÁõ¥Â∞æÁøº) REWORK: Ê≠£Á°ÆÂè≥Ëßí‰∏âËßíÂΩ¢ÔºåÁü≠ËæπË¥¥Êú∫Ë∫´ÔºåÊñúËæπÊúùÂâç ===
                (function(){
                    const base = 3.0;        // ÂâçÂêëÔºà+ZÔºâÂü∫Â∫ïÈïøÂ∫¶
                    const height = 4.2;      // ÂûÇÁõ¥È´òÂ∫¶ (+Y)
                    const r = 0.32;          // ÂúÜËßíÂçäÂæÑ
                    const thickness = 0.18;   // ÂéöÂ∫¶ (X)
                    // Âú®‰∫åÁª¥Âπ≥Èù¢ (x=ÂâçÂêëZ, y=È´òÂ∫¶Y) ‰∏äÊûÑÂª∫Âè≥Ëßí‰∏âËßíÂΩ¢ÔºåÂè≥ËßíÂú®Ê†πÈÉ® (0,0)
                    const shape = new THREE.Shape();
                    // ‰ªéÊ†πÈÉ®Á®çÂè≥ (r,0) ÂºÄÂßãÔºåÈ°∫Êó∂ÈíàÁªïË°å
                    shape.moveTo(r,0);
                    shape.lineTo(base - r,0);                                // Â∫ïËæπ
                    shape.quadraticCurveTo(base,0, base, r);                 // Ââç‰∏ãËßíÂúÜËßí
                    shape.lineTo(r, height - r);                             // ÊñúËæπÂà∞ËøëÈ°∂ÁÇπ
                    shape.quadraticCurveTo(0,height, 0, height - r);         // È°∂ËßíÂúÜËßíÔºàÊ†πÈÉ®‰∏äÔºâ
                    shape.lineTo(0, r);                                      // ÂõûÂà∞ÂâçÁºòÊ†πÈÉ®
                    shape.quadraticCurveTo(0,0, r,0);                         // Ê†πÈÉ®‰∏ãËßíÂúÜËßí
                    shape.closePath();
                    // Êå§Âá∫ (depth Ê≤ø +ZÔºå‰πãÂêéÊóãËΩ¨‰ΩøÂÖ∂ÂéöÂ∫¶Ê≤ø X)
                    const extrudeGeo = new THREE.ExtrudeGeometry(shape,{ depth: thickness, bevelEnabled:false });
                    // ÊóãËΩ¨ÔºöÂ∞ÜÂ±ÄÈÉ® Z(ÂéöÂ∫¶) -> XÔºåÂÖ®Â±ÄÂâçÂêë‰ΩøÁî®Â±ÄÈÉ® X
                    extrudeGeo.rotateY(Math.PI / 2);
                    // ÈáçÊñ∞ËÆ°ÁÆóÂåÖÂõ¥ÁõíÂπ∂ÂØπÈΩêÔºöÊ†πÈÉ®ÂûÇÁõ¥Ëæπ (x‚âà0) Ë¥¥Êú∫Ë∫´ÔºåÂ∫ïÈÉ® y=0
                    extrudeGeo.computeBoundingBox();
                    let bb = extrudeGeo.boundingBox;
                    // Â∞ÜÂ∫ïÈÉ®ÁßªÂà∞ y=0
                    extrudeGeo.translate(0, -bb.min.y, 0);
                    extrudeGeo.computeBoundingBox();
                    bb = extrudeGeo.boundingBox;
                    // Â∞ÜÊ†πÈÉ®ÂâçÁºò (z ÊúÄÂ∞è) ÁßªÂà∞ z=0
                    if (Math.abs(bb.min.z) > 1e-5) extrudeGeo.translate(0,0,-bb.min.z);
                    // ÂéöÂ∫¶‰∏≠ÂøÉÂåñ (X Â±Ö‰∏≠)
                    extrudeGeo.computeBoundingBox();
                    bb = extrudeGeo.boundingBox;
                    const xCenter = -(bb.min.x + bb.max.x)/2;
                    extrudeGeo.translate(xCenter,0,0);
                    // ÂàõÂª∫ Mesh Âπ∂ÊîæÁΩÆÂú®Â∞æÈÉ®Âü∫ÂáÜ z=-10
                    const fin = new THREE.Mesh(extrudeGeo, wingMaterial);
                    fin.position.set(0,0,-10);
                    // Ê∞¥Âπ≥ÁøªËΩ¨ÔºàÊ≤øZËΩ¥ÈïúÂÉèÔºâ
                    fin.scale.z = -1;
                    fin.updateMatrix();
                    fin.castShadow = true;
                    planeGroup.add(fin);
                })();
                
                // === ENHANCED PROPELLER ASSEMBLY ===
                // Propeller spinner
                const spinnerGeometry = new THREE.ConeGeometry(0.8, 1.5, 12);
                const spinnerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // Ëû∫ÊóãÊ°®Èî• ÈªëËâ≤
                    metalness: 0.95, 
                    roughness: 0.25 
                });
                const spinner = new THREE.Mesh(spinnerGeometry, spinnerMaterial);
                spinner.position.set(0, 0, 12.0); // moved back to match shorter nose
                spinner.rotation.x = Math.PI / 2;
                spinner.castShadow = true;
                planeGroup.add(spinner);
                
                // Propeller hub
                const hubGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.6, 12);
                const hub = new THREE.Mesh(hubGeometry, spinnerMaterial); // ÈªëËâ≤ÈáëÂ±û
                hub.position.set(0, 0, 11.0); // adjusted with shorter nose
                hub.rotation.x = Math.PI / 2;
                hub.castShadow = true;
                planeGroup.add(hub);
                
                // Enhanced propeller blades
                const propGroup = new THREE.Group();
                const bladeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // Ëû∫ÊóãÊ°®Âè∂ÈªëËâ≤ÈáëÂ±û
                    metalness: 0.9,
                    roughness: 0.35
                });
                
                for (let i = 0; i < 3; i++) {
                    // Realistic blade shape with taper
                    const bladeGeometry = new THREE.BoxGeometry(0.3, 8, 0.15);
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.rotation.z = (i * 2 * Math.PI) / 3;
                    blade.castShadow = true;
                    propGroup.add(blade);
                    
                    // Blade tips
                    const tipGeometry = new THREE.SphereGeometry(0.2, 8, 4);
                    const tip = new THREE.Mesh(tipGeometry, bladeMaterial);
                    tip.position.set(0, 4, 0);
                    tip.rotation.z = (i * 2 * Math.PI) / 3;
                    blade.add(tip);
                }
                
                propGroup.position.set(0, 0, 11.3); // adjusted forward group anchor
                planeGroup.add(propGroup);
                this.propeller = propGroup;
                
                // === DETAILED LANDING GEAR (Ëµ∑ËêΩÊû∂) - Shorter & Smaller ===
                const gearMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x404040,
                    metalness: 0.8,
                    roughness: 0.3
                });
                
                // Main gear struts with hydraulics (shorter and thinner)
                for (let side = -1; side <= 1; side += 2) {
                    const strutGeometry = new THREE.CylinderGeometry(0.06, 0.09, 2.2, 8); // Reduced from 3.5 to 2.2, thinner
                    const strut = new THREE.Mesh(strutGeometry, gearMaterial);
                    strut.position.set(side * 1.8, -1.8, 0); // Moved up and closer
                    strut.castShadow = true;
                    planeGroup.add(strut);
                    
                    // Wheels with detailed rims (smaller)
                    const wheelGeometry = new THREE.CylinderGeometry(0.65, 0.65, 0.3, 16); // Reduced from 0.9 to 0.65
                    const wheelMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a,
                        roughness: 0.9
                    });
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(side * 1.8, -2.9, 0); // Adjusted position
                    wheel.rotation.z = Math.PI / 2;
                    wheel.castShadow = true;
                    planeGroup.add(wheel);
                    
                    // Wheel rims (smaller)
                    const rimGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.32, 16); // Reduced from 0.7 to 0.5
                    const rim = new THREE.Mesh(rimGeometry, gearMaterial);
                    rim.position.set(side * 1.8, -2.9, 0);
                    rim.rotation.z = Math.PI / 2;
                    rim.castShadow = true;
                    planeGroup.add(rim);
                }
                
                // Tail wheel (shorter and smaller)
                const tailGearGroup = new THREE.Group();
                // Strut (thinner and shorter)
                const tailStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.08, 1.5, 8), gearMaterial); // Reduced from 2.2 to 1.5
                tailStrut.rotation.z = 0; // vertical
                tailStrut.position.set(0, -0.2, -8.6); // Moved up
                tailStrut.castShadow = true;
                tailGearGroup.add(tailStrut);
                // Axle block (smaller)
                const tailAxle = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.4), gearMaterial); // Reduced size
                tailAxle.position.set(0, -1.0, -9.0); // Adjusted position
                tailAxle.castShadow = true;
                tailGearGroup.add(tailAxle);
                // Wheel (smaller)
                const tailWheelGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 14); // Reduced from 0.5 to 0.35
                const tailWheel = new THREE.Mesh(tailWheelGeometry, new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, roughness: 0.9 
                }));
                // Match orientation of main gear wheels (rotate around Z)
                tailWheel.rotation.x = 0;
                tailWheel.rotation.z = Math.PI / 2;
                tailWheel.position.set(0, -1.1, -9.0); // Adjusted position
                tailWheel.castShadow = true;
                tailGearGroup.add(tailWheel);
                planeGroup.add(tailGearGroup);
                
                // === COCKPIT CANOPY (ÂçäÁêÉÂΩ¢Â∫ßËà±Áõñ) with Glass + Frame ===
                // ÂçäÁêÉÈÄèÊòéÁéªÁíÉ + Âä†Âº∫Á≠ãÊ°ÜÊû∂
                const canopyRadius = 1.35; // Áï•Â§ß‰∫éÊú∫Ë∫´Êà™Èù¢, Ë¥¥Âêà
                const canopyGeom = new THREE.SphereGeometry(canopyRadius, 32, 20, 0, Math.PI * 2, 0, Math.PI / 2);
                // ÁéªÁíÉÊùêË¥®ÔºöËΩªÂæÆËìùÁªøËâ≤Ë∞ÉÔºåÂèØË∞É
                const canopyGlassMaterial = new THREE.MeshStandardMaterial({
                    color: 0x99c6d8,
                    metalness: 0.0,
                    roughness: 0.05,
                    transparent: true,
                    opacity: 0.28,
                    depthWrite: false
                });
                const canopyGroup = new THREE.Group();
                const canopyGlass = new THREE.Mesh(canopyGeom, canopyGlassMaterial);
                canopyGlass.castShadow = false;
                canopyGlass.receiveShadow = false;
                canopyGroup.add(canopyGlass);

                // Ê°ÜÊû∂ÊùêË¥®ÔºàÁ®çÊ∑±ÈáëÂ±ûÔºâ
                const canopyFrameMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2d3134,
                    metalness: 0.65,
                    roughness: 0.35
                });
                const frameTubeRadius = 0.04;
                const frameRadialSegments = 12;
                const frameTubularSegments = 48;

                // Â∫ïÈÉ®ÁéØÂΩ¢Ê°Ü (Ê≤ø XY Âπ≥Èù¢) - Torus ÈªòËÆ§ËΩ¥ Y (Âπ≥Èù¢ XZ)ÔºåÊóãËΩ¨Âà∞ XY
                const baseRing = new THREE.Mesh(
                    new THREE.TorusGeometry(canopyRadius * 0.995, frameTubeRadius, frameRadialSegments, frameTubularSegments),
                    canopyFrameMaterial
                );
                baseRing.rotation.x = Math.PI / 2; // ËΩ¥‰ªé Y ÊóãÂà∞ ZÔºå‰ΩøÂπ≥Èù¢ÂèòÊàê XY
                baseRing.castShadow = true;
                canopyGroup.add(baseRing);

                // ÂâçÂêéÁ´ñÂêëÊ°Ü (Âπ≥Èù¢ XZ) - ‰∏çÊóãËΩ¨ (ÈªòËÆ§Âπ≥Èù¢ XZ)
                const foreAftRing = new THREE.Mesh(
                    new THREE.TorusGeometry(canopyRadius, frameTubeRadius * 0.75, frameRadialSegments, frameTubularSegments),
                    canopyFrameMaterial
                );
                foreAftRing.castShadow = true;
                canopyGroup.add(foreAftRing);

                // Â∑¶Âè≥Á´ñÂêëÊ°Ü (Âπ≥Èù¢ YZ) - ÊóãËΩ¨ Z 90¬∞
                const leftRightRing = new THREE.Mesh(
                    new THREE.TorusGeometry(canopyRadius, frameTubeRadius * 0.75, frameRadialSegments, frameTubularSegments),
                    canopyFrameMaterial
                );
                leftRightRing.rotation.z = Math.PI / 2;
                leftRightRing.castShadow = true;
                canopyGroup.add(leftRightRing);

                // È°∂ÈÉ®Á∫µÂêëÂä†Âº∫Á≠ã (Ê≤ø Z ÊñπÂêëÁöÑÊù°) ‰ΩøÁî®ÁªÜÈïø Box Áï•È´òÂá∫Ë°®Èù¢
                const topSpine = new THREE.Mesh(new THREE.BoxGeometry(frameTubeRadius * 0.9, frameTubeRadius * 0.9, canopyRadius * 2 * 0.92), canopyFrameMaterial);
                topSpine.position.y = canopyRadius * 0.72; // Áï•‰Ωé‰∫éÈ°∂ÁÇπÔºåÈÅøÂÖçÊÇ¨Á©∫
                topSpine.castShadow = true;
                canopyGroup.add(topSpine);

                // ËΩªÂæÆÊï¥‰ΩìÂêë‰∏äÔºöË¥¥ÂêàÊú∫Ë∫´Â§ñÂ£≥
                canopyGroup.position.set(0, 0.68, 0.2);
                // Ê∞¥Âπ≥ÊóãËΩ¨ 90¬∞ (Áªï Y ËΩ¥) 
                canopyGroup.rotation.y = Math.PI / 2;
                planeGroup.add(canopyGroup);
                
                // === COCKPIT INTERIOR (È©æÈ©∂Ëà±ÂÜÖÈÉ®) - Ë∞ÉÊï¥‰ΩçÁΩÆ ===
                const seatGeometry = new THREE.BoxGeometry(0.8, 0.4, 1.2);
                const seatMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a4a4a, 
                    roughness: 0.8 
                });
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(0, 0.1, 0.5); // Á®çÂæÆÈôç‰ΩéÂ∫ßÊ§Ö‰ΩçÁΩÆ
                seat.castShadow = true;
                planeGroup.add(seat);
                
                // Control stick (ÊìçÁ∫µÊùÜ)
                const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
                const stick = new THREE.Mesh(stickGeometry, darkMetalMaterial);
                stick.position.set(0, 0.4, 1.0); // Ë∞ÉÊï¥ÊìçÁ∫µÊùÜ‰ΩçÁΩÆ
                stick.castShadow = true;
                planeGroup.add(stick);
                
                // Instrument panel (‰ª™Ë°®Êùø)
                const panelGeometry = new THREE.BoxGeometry(1.4, 0.6, 0.08);
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a, 
                    roughness: 0.6,
                    metalness: 0.3
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(0, 0.5, 2.0); // Ë∞ÉÊï¥‰ª™Ë°®Êùø‰ΩçÁΩÆ
                panel.rotation.x = -Math.PI / 6; // ÂêëÂêéÂÄæÊñú15Â∫¶
                panel.castShadow = true;
                planeGroup.add(panel);
                
                // === NAVIGATION LIGHTS (ÂØºËà™ÁÅØ) ===
                // Wing tip lights with proper aviation colors
                for (let side = -1; side <= 1; side += 2) {
                    const lightGeometry = new THREE.SphereGeometry(0.12, 8, 6);
                    const lightMaterial = new THREE.MeshStandardMaterial({ 
                        color: side > 0 ? 0x00ff00 : 0xff0000, // Green right, red left
                        emissive: side > 0 ? 0x004400 : 0x440000,
                        emissiveIntensity: 0.5,
                        metalness: 0.1,
                        roughness: 0.2
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.set(side * 11, 0, -1);
                    planeGroup.add(light);
                }
                
                // Tail navigation light
                const tailLightGeometry = new THREE.SphereGeometry(0.08, 8, 6);
                const tailLightMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0x222222,
                    emissiveIntensity: 0.3,
                    metalness: 0.1,
                    roughness: 0.2
                });
                const tailLight = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
                tailLight.position.set(0, 1, -12);
                planeGroup.add(tailLight);
                
                // === ENHANCED ENGINE EXHAUST STACKS (ÊéíÊ∞îÁÆ°) ===
                for (let i = 0; i < 6; i++) {
                    const exhaustGeometry = new THREE.CylinderGeometry(0.12, 0.18, 1.2, 8);
                    const exhaustMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2a2a2a,
                        metalness: 0.6,
                        roughness: 0.7,
                        emissive: 0x221100,
                        emissiveIntensity: 0.1
                    });
                    const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 1.2;
                    exhaust.position.set(
                        Math.cos(angle) * radius, 
                        Math.sin(angle) * radius, 
                        5
                    );
                    exhaust.rotation.x = Math.PI / 2;
                    exhaust.castShadow = true;
                    planeGroup.add(exhaust);
                }
                
                // === FINAL ASSEMBLY ===
                planeGroup.position.copy(this.playerPosition);
                planeGroup.scale.set(2.16, 2.16, 2.16); // Á≠âÊØî‰æãÂÜçÊîæÂ§ß1.5ÂÄç (Âéü 1.44)
                
                // Store references
                this.loadedModel = null; // Clear custom model reference for visible cannons
                this.aircraft = planeGroup;
                planeGroup.userData.aircraftType = 'built-in-aircraft'; // Ê†áËÆ∞‰∏∫ÂÜÖÁΩÆÈ£ûÊú∫
                this.scene.add(this.aircraft);
                
                console.log('‚ö†Ô∏è BUILT-IN AIRCRAFT CREATED as fallback');
                console.log('‚ö†Ô∏è Aircraft type set to:', planeGroup.userData.aircraftType);
                
                // Remove existing cannons and recreate with proper visibility
                const existingCannons = this.aircraft.getObjectByName('NoseCannons');
                if (existingCannons) {
                    this.aircraft.remove(existingCannons);
                }
                this.gunBarrels = []; // Clear barrel references
                this.createNoseCannons(); // Recreate with full visibility
                
                console.log('Built-in aircraft loaded as fallback');
            }

            // ================= Nose Cannon System =================
            createNoseCannons() {
                if (!this.aircraft) return;
                // ÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                if (this.aircraft.getObjectByName('NoseCannons')) return;
                const barrelsGroup = new THREE.Group();
                barrelsGroup.name = 'NoseCannons';
                
                // Check if using custom GLB model - make guns transparent if so
                const isCustomModel = !!this.loadedModel;
                const barrelMat = new THREE.MeshStandardMaterial({
                    color: 0x2c2c2c,
                    metalness: 0.85,
                    roughness: 0.25,
                    transparent: isCustomModel,
                    opacity: isCustomModel ? 0.0 : 1.0  // Fully transparent for custom models
                });
                
                const barrelGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.6, 12);
                this.gunBarrels = [];
                for (let s of [-1,1]) {
                    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                    barrel.rotation.x = Math.PI/2;
                    barrel.position.set(s*0.6, -0.15, 7.2);
                    barrel.castShadow = !isCustomModel; // No shadows for transparent guns
                    barrelsGroup.add(barrel);
                    this.gunBarrels.push(barrel);
                }
                // Ë£ÖÈ•∞Âü∫Â∫ßÁéØ
                const ringGeo = new THREE.TorusGeometry(0.28, 0.045, 6, 16);
                for (let s of [-1,1]) {
                    const ring = new THREE.Mesh(ringGeo, new THREE.MeshStandardMaterial({
                        color: 0x555555,
                        metalness: 0.6,
                        roughness: 0.4,
                        transparent: isCustomModel,
                        opacity: isCustomModel ? 0.0 : 1.0  // Fully transparent for custom models
                    }));
                    ring.rotation.x = Math.PI/2;
                    ring.position.set(s*0.6, -0.15, 6.45);
                    ring.castShadow = !isCustomModel; // No shadows for transparent rings
                    barrelsGroup.add(ring);
                }
                this.aircraft.add(barrelsGroup);
            }

            setupMouseControls() {
                const canvas = this.renderer.domElement;
                canvas.addEventListener('mousedown', (e)=>{ if (e.button===0) this.isFiring = true; });
                window.addEventListener('mouseup', (e)=>{ if (e.button===0) this.isFiring = false; });
            }

            tryFireGuns(deltaTime) {
                if (!this.isFiring || !this.aircraft || this.gunBarrels.length===0) return;
                const now = performance.now()/1000;
                if (now - this.lastShotTime < this.fireInterval) return;
                this.lastShotTime = now;
                // ÂâçÂêëÊñπÂêë
                this.forwardVec.set(0,0,1).applyEuler(new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll)).normalize();
                // ÁÇÆÂè£Â∞ÑÂáª
                this.gunBarrels.forEach(barrel=>{
                    barrel.getWorldPosition(this.tempVec);
                    this.spawnBullet(this.tempVec, this.forwardVec);
                    this.spawnMuzzleFlash(barrel);
                });
            }

            spawnBullet(origin, forward) {
                const geo = new THREE.SphereGeometry(0.45, 10, 10);
                const mat = new THREE.MeshBasicMaterial({ color: 0xfff066 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(origin);
                this.scene.add(mesh);
                const speed = 450;
                this.bullets.push({ mesh, velocity: forward.clone().multiplyScalar(speed), life: 2, age: 0 });
            }

            spawnMuzzleFlash(barrel) {
                const flashGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const flashMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                barrel.getWorldPosition(flash.position);
                this.scene.add(flash);
                this.muzzleFlashes.push({ mesh: flash, age: 0, life: 0.12 });
            }

            // ====== Scoreboard helpers ======
            ensurePlayerName(){
                const storedName = localStorage.getItem('skywarriors_playerName');
                if (storedName) { this.playerName = storedName; return; }
                this.showNamePrompt();
            }
            showNamePrompt(){
                if (document.getElementById('namePromptOverlay')) return;
                const overlay = document.createElement('div'); overlay.id='namePromptOverlay';
                overlay.innerHTML = `\n<div id="namePromptBox">\n  <h2>Enter Player Name</h2>\n  <input id="playerNameInput" maxlength="18" placeholder="e.g.: Ace Pilot" />\n  <button id="confirmNameBtn">Enter Battle</button>\n  <div class="note">This name will be used for the scoreboard and saved locally.\n  Leave blank to generate a random name.</div>\n</div>`;
                document.body.appendChild(overlay);
                overlay.querySelector('#confirmNameBtn').addEventListener('click', ()=>{
                    const val = overlay.querySelector('#playerNameInput').value.trim();
                    this.playerName = val || ('Pilot_' + Math.random().toString(36).slice(2,7));
                    localStorage.setItem('skywarriors_playerName', this.playerName);
                    overlay.remove();
                    this.registerPlayerIfNeeded();
                    this.updateScoreboardUI();
                });
            }
            loadScores(){
                try { const raw = localStorage.getItem(this.localStorageKey); if(raw) this.scoreData = JSON.parse(raw); } catch(e){ console.warn('Load score error', e); }
            }
            saveScores(){
                try { localStorage.setItem(this.localStorageKey, JSON.stringify(this.scoreData)); } catch(e){ console.warn('Save score error', e); }
            }
            registerPlayerIfNeeded(){
                if(!this.playerName) return;
                if(!this.scoreData.players[this.playerName]){
                    this.scoreData.players[this.playerName] = { tank:0, ship:0, total:0, last: Date.now() };
                    this.saveScores();
                }
            }
            recordKill(type){ // type: 'tank' | 'ship'
                if(!this.playerName) return;
                const p = this.scoreData.players[this.playerName]; if(!p) return;
                if(type==='tank') p.tank +=1; else if(type==='ship') p.ship +=1;
                p.total = p.tank + p.ship; p.last = Date.now();
                this.saveScores();
                this.updateScoreboardUI();
                // session counters
                if(type==='tank') this.sessionKills.tank++; else if(type==='ship') this.sessionKills.ship++;
                this.updateHudStats();
            }
            updateScoreboardUI(){
                const panel = document.getElementById('scoreboardPanel');
                if(!panel){ return; }
                panel.style.display = 'block';
                const rowsContainer = document.getElementById('scoreRows');
                if(!rowsContainer) return;
                const entries = Object.entries(this.scoreData.players).map(([name,data])=>({ name, ...data }));
                entries.sort((a,b)=> b.total - a.total || a.name.localeCompare(b.name));
                rowsContainer.innerHTML = '';
                entries.forEach((d,idx)=>{
                    const tr = document.createElement('tr');
                    if (d.name === this.playerName) tr.classList.add('highlight');
                    tr.innerHTML = `<td>${idx+1}</td><td>${d.name}</td><td>${d.tank}</td><td>${d.ship}</td><td>${d.total}</td>`;
                    rowsContainer.appendChild(tr);
                });
                const nameDisp = document.getElementById('playerNameDisplay');
                if(nameDisp) nameDisp.textContent = 'ÂΩìÂâçÁé©ÂÆ∂: ' + (this.playerName||'--');
                const exportBtn = document.getElementById('exportScoreBtn');
                if(exportBtn && !exportBtn.dataset.bound){
                    exportBtn.dataset.bound = '1';
                    exportBtn.addEventListener('click', ()=> this.exportScoresJSON());
                }
            }
            exportScoresJSON(){
                const blob = new Blob([JSON.stringify(this.scoreData,null,2)], { type:'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'scores.json'; a.click();
                URL.revokeObjectURL(url);
                this.showNotification('Â∑≤ÂØºÂá∫ÁßØÂàÜ JSON', 'success');
            }
            updateHudStats(){
                const hud = document.getElementById('hudStats'); if(!hud) return;
                hud.style.display = 'flex';
                const tk = document.getElementById('hudTankKills');
                const sk = document.getElementById('hudShipKills');
                const tt = document.getElementById('hudTotalKills');
                if(tk) tk.textContent = this.sessionKills.tank;
                if(sk) sk.textContent = this.sessionKills.ship;
                if(tt) tt.textContent = this.sessionKills.tank + this.sessionKills.ship;
            }

            updateBullets(deltaTime) {
                // Â≠êÂºπÁßªÂä® & Ê∑°Âá∫
                for (let i = this.bullets.length-1; i>=0; i--) {
                    const b = this.bullets[i];
                    b.age += deltaTime;
                    b.mesh.position.addScaledVector(b.velocity, deltaTime);
                    // ‰º∏ÈïøËßÜËßâÔºàÊ≤øÂ±ÄÈÉ®ZÁî®scaleÊ®°ÊãüÔºâ
                    b.mesh.scale.z = 1 + b.age*4;
                    const t = b.age / b.life;
                    if (t > 0.6) {
                        b.mesh.material.transparent = true;
                        b.mesh.material.opacity = 1 - (t-0.6)/0.4;
                    }
                    // ==== Á¢∞ÊíûÊ£ÄÊµãÔºöÂ≠êÂºπ vs Âù¶ÂÖã ====
                    if (this.tanks && this.tanks.length>0) {
                        for (let ti = 0; ti < this.tanks.length; ti++) {
                            const tank = this.tanks[ti];
                            if (!tank.alive) continue;
                            const dist = b.mesh.position.distanceTo(tank.mesh.position);
                            if (dist < tank.radius) {
                                // ÈÄ†Êàê‰º§ÂÆ≥
                                tank.health = Math.max(0, tank.health - 1);
                                
                                // ÂàõÂª∫Â∞èÁàÜÁÇ∏ÊïàÊûú
                                this.createExplosion(tank.mesh.position.clone().add(
                                    new THREE.Vector3((Math.random()-0.5)*10, 5, (Math.random()-0.5)*10)
                                ));
                                
                                if (tank.health <= 0) {
                                    // Âù¶ÂÖãË¢´ÊëßÊØÅ
                                    tank.alive = false;
                                    this.createTankDestroyed(tank.mesh.position.clone(), tank.mesh);
                                    this.createScorchMark(tank.mesh.position.x, tank.mesh.position.z);
                                    this.recordKill('tank');
                                    
                                    // Ê∏ÖÈô§Ë°ÄÊù°
                                    if (tank.healthBar) {
                                        tank.healthBar.container.remove();
                                    }
                                } else {
                                    // Âù¶ÂÖãÂèó‰º§‰ΩÜÂ≠òÊ¥ªÔºåÂ¶ÇÊûúÊòØÊôÆÈÄöÂù¶ÂÖãÔºåÁé©ÂÆ∂ÂõûË°Ä
                                    if (!tank.isAA) {
                                        this.playerHealth = Math.min(this.playerMaxHealth, this.playerHealth + 10);
                                        // TODO: Add visual health gain indicator
                                    }
                                }
                                
                                // ÁßªÈô§Â≠êÂºπ
                                this.scene.remove(b.mesh);
                                b.mesh.geometry.dispose();
                                b.mesh.material.dispose();
                                this.bullets.splice(i,1);
                                break; // Ë∑≥Âá∫Âù¶ÂÖãÂæ™ÁéØ
                            }
                        }
                    }
                    // ==== Á¢∞ÊíûÊ£ÄÊµãÔºöÂ≠êÂºπ vs ÊàòËà∞ ====
                    if (this.warships && this.warships.length>0) {
                        for (let wi=0; wi<this.warships.length; wi++) {
                            const ship = this.warships[wi];
                            if(!ship.alive) continue;
                            const distS = b.mesh.position.distanceTo(ship.mesh.position);
                            if (distS < ship.radius) {
                                // ÈÄ†Êàê‰º§ÂÆ≥
                                ship.health = Math.max(0, ship.health - 1);
                                
                                // ÂàõÂª∫ÁàÜÁÇ∏ÊïàÊûú
                                this.createExplosion(ship.mesh.position.clone().add(
                                    new THREE.Vector3((Math.random()-0.5)*20, 8, (Math.random()-0.5)*20)
                                ));
                                
                                if (ship.health <= 0) {
                                    // ÂÜõËà∞Ë¢´ÊëßÊØÅ
                                    ship.alive = false;
                                    this.scene.remove(ship.mesh);
                                    this.createSeaScorch(ship.mesh.position.x, ship.mesh.position.z);
                                    this.recordKill('ship');
                                    
                                    // Ê∏ÖÈô§Ë°ÄÊù°
                                    if (ship.healthBar) {
                                        ship.healthBar.container.remove();
                                    }
                                }
                                
                                this.scene.remove(b.mesh);
                                b.mesh.geometry.dispose();
                                b.mesh.material.dispose();
                                this.bullets.splice(i,1);
                                break;
                            }
                        }
                    }
                    if (b.age >= b.life) {
                        this.scene.remove(b.mesh);
                        b.mesh.geometry.dispose();
                        b.mesh.material.dispose();
                        this.bullets.splice(i,1);
                    }
                }
                // Êû™Âè£ÁÅ´ÂÖâ
                for (let i = this.muzzleFlashes.length-1; i>=0; i--) {
                    const f = this.muzzleFlashes[i];
                    f.age += deltaTime;
                    const p = f.age / f.life;
                    f.mesh.scale.setScalar(1 + p*5);
                    f.mesh.material.transparent = true;
                    f.mesh.material.opacity = 1 - p;
                    if (f.age >= f.life) {
                        this.scene.remove(f.mesh);
                        f.mesh.geometry.dispose();
                        f.mesh.material.dispose();
                        this.muzzleFlashes.splice(i,1);
                    }
                }
            }

            // ==== ÊïåÊñπÂ∞ÑÂáªÁ≥ªÁªü ====
            createEnemyBullet(position, targetPosition, speed = 400) {
                // Create bullet geometry and material (same as player bullets)
                const geometry = new THREE.SphereGeometry(0.45, 10, 10);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xfff066, // Same yellow color as player bullets
                    transparent: true,
                    opacity: 0.95
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Position bullet at origin
                mesh.position.copy(position);
                
                // Calculate direction to target with some inaccuracy
                const direction = new THREE.Vector3()
                    .subVectors(targetPosition, position)
                    .normalize();
                
                // Add to scene
                this.scene.add(mesh);
                
                // Create bullet object
                const bullet = {
                    mesh: mesh,
                    velocity: direction.multiplyScalar(speed),
                    age: 0,
                    life: 3.0 // 3 seconds life
                };
                
                this.enemyBullets.push(bullet);
                
                return bullet;
            }
            
            createEnemyMuzzleFlash(position) {
                // Create muzzle flash with same style as player
                const flashGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const flashMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                flash.position.copy(position);
                this.scene.add(flash);
                this.muzzleFlashes.push({ mesh: flash, age: 0, life: 0.12 });
            }

            updateEnemyBullets(deltaTime) {
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = this.enemyBullets[i];
                    bullet.age += deltaTime;
                    
                    // Move bullet
                    bullet.mesh.position.addScaledVector(bullet.velocity, deltaTime);
                    
                    // Fade out over time
                    const t = bullet.age / bullet.life;
                    if (t > 0.7) {
                        bullet.mesh.material.opacity = 0.9 * (1 - (t - 0.7) / 0.3);
                    }
                    
                    // Check collision with player aircraft
                    const distanceToPlayer = bullet.mesh.position.distanceTo(this.playerPosition);
                    if (distanceToPlayer < 15 && this.aircraft) { // Hit radius
                        // Damage player
                        this.playerHealth = Math.max(0, this.playerHealth - 2);
                        this.updatePlayerHealthDisplay();
                        this.createPlayerHitEffect();
                        
                        // Check if player is dead
                        if (this.playerHealth <= 0) {
                            this.handlePlayerDeath();
                        }
                        
                        // Remove bullet
                        this.scene.remove(bullet.mesh);
                        bullet.mesh.geometry.dispose();
                        bullet.mesh.material.dispose();
                        this.enemyBullets.splice(i, 1);
                        continue;
                    }
                    
                    // Remove old bullets
                    if (bullet.age >= bullet.life) {
                        this.scene.remove(bullet.mesh);
                        bullet.mesh.geometry.dispose();
                        bullet.mesh.material.dispose();
                        this.enemyBullets.splice(i, 1);
                    }
                }
            }

            createPlayerHitEffect() {
                // Visual effect when player gets hit
                const flash = document.createElement('div');
                flash.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: radial-gradient(circle, rgba(255,0,0,0.3) 0%, transparent 50%);
                    pointer-events: none; z-index: 9999;
                `;
                document.body.appendChild(flash);
                
                setTimeout(() => {
                    flash.remove();
                }, 150);
            }
            
            handlePlayerDeath() {
                // Show game over message
                const gameOverDiv = document.createElement('div');
                gameOverDiv.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);
                    display: flex; flex-direction: column; justify-content: center; align-items: center;
                    z-index: 10000; color: white; font-family: 'Segoe UI', sans-serif;
                `;
                
                gameOverDiv.innerHTML = `
                    <h1 style="font-size: 48px; margin-bottom: 20px; color: #ff4444; text-shadow: 0 0 20px rgba(255, 68, 68, 0.8);">GAME OVER</h1>
                    <p style="font-size: 20px; margin-bottom: 30px;">Your aircraft was shot down!</p>
                    <button onclick="location.reload()" style="
                        padding: 12px 30px; font-size: 18px; background: linear-gradient(135deg, #ff4444, #cc3333);
                        border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;
                        box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3); transition: transform 0.2s;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        Restart Game
                    </button>
                `;
                
                document.body.appendChild(gameOverDiv);
                
                // Stop the game loop (optional - you might want to keep some systems running)
                // this.gameRunning = false;
            }

            // Calculate lead target position for enemy shooting
            calculateLeadTarget(shooterPos, targetPos, targetVel, bulletSpeed, accuracy) {
                // Basic predictive aiming
                const distance = shooterPos.distanceTo(targetPos);
                const timeToTarget = distance / bulletSpeed;
                
                // Predict where target will be
                const predictedPos = targetPos.clone().addScaledVector(targetVel, timeToTarget);
                
                // Add inaccuracy based on accuracy parameter
                const inaccuracy = (1.0 - accuracy) * 100; // Convert to units
                predictedPos.add(new THREE.Vector3(
                    (Math.random() - 0.5) * inaccuracy,
                    (Math.random() - 0.5) * inaccuracy * 0.5, // Less vertical spread
                    (Math.random() - 0.5) * inaccuracy
                ));
                
                return predictedPos;
            }

            // ==== ÊàòËà∞Áõ∏ÂÖ≥ ====
            createWarships(count=5){
                for(let i=0;i<count;i++){
                    const x = (Math.random()-0.5)*6500;
                    const z = (Math.random()-0.5)*6500;
                    if (Math.hypot(x,z) < 600) { i--; continue; }
                    const ship = this.createWarship(x,z);
                    this.warships.push(ship);
                }
            }
            createWarship(x,z){
                const g = new THREE.Group();
                // Ëàπ‰ΩìÊ¢≠ÂΩ¢ + Áî≤Êùø
                const hullLen = 160 + Math.random()*60;
                const hullWidth = 22 + Math.random()*6;
                const hullHeight = 10;
                // Ê¢≠ÂΩ¢ hull: Áî±‰∏Ä‰∏™ÈïøÁõíÂÜçÁî®Áº©ÊîæÂΩ¢ÊàêÁ∫∫Èî§Ôºà‰∏≠ÂÆΩÔºå‰∏§Á´ØÈÄêÊ∏êÂèòÁªÜÔºâ
                const spindleGeo = new THREE.BoxGeometry(hullWidth, hullHeight, hullLen, 8,1,16);
                // ÊâãÂä®È°∂ÁÇπË∞ÉÊï¥ÔºöÊ†πÊçÆZË∑ùÁ¶ª‰∏≠ÂøÉÁº©ÊîæX,Y ÂΩ¢ÊàêÂπ≥ÊªëÊ¢≠ÂΩ¢
                const pos = spindleGeo.attributes.position;
                for(let i=0;i<pos.count;i++){
                    const z = pos.getZ(i);
                    const nz = Math.abs(z)/(hullLen/2); // 0..1
                    const taper = 1 - Math.pow(nz,1.4); // ‰∏≠Â§ÆÊúÄÂ§ß
                    pos.setX(i, pos.getX(i)* (0.55 + 0.45*taper));
                    pos.setY(i, pos.getY(i)* (0.55 + 0.45*taper));
                }
                spindleGeo.computeVertexNormals();
                const hullMat = new THREE.MeshStandardMaterial({ color:0x3f454c, metalness:0.25, roughness:0.85 });
                const spindle = new THREE.Mesh(spindleGeo, hullMat);
                spindle.position.y = -41; // Â§ßÈÉ®ÂàÜÊµ∏ÂÖ•Ê∞¥‰∏ãÔºåÂ∞ëÈáèÈú≤Âá∫
                spindle.castShadow = true; spindle.receiveShadow = true;
                g.add(spindle);
                // ‰∏äÂ±ÇÁî≤ÊùøÔºàÁï•Áü≠Ôºâ
                const deck = new THREE.Mesh(new THREE.BoxGeometry(hullWidth*0.9,4,hullLen*0.62), new THREE.MeshStandardMaterial({ color:0x676d75, metalness:0.25, roughness:0.6 }));
                deck.position.set(0, -36.2, 0); // Èú≤Âá∫Ê∞¥Èù¢
                deck.castShadow = true; g.add(deck);
                // ÊåáÊå•Â°î + Èõ∑ËææÁÆÄÂåñ
                const tower = new THREE.Mesh(new THREE.BoxGeometry(hullWidth*0.4,14,hullLen*0.18), new THREE.MeshStandardMaterial({ color:0x7a8088 }));
                tower.position.set(0, deck.position.y + 9, -hullLen*0.08);
                tower.castShadow = true; g.add(tower);
                const radar = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,6,12), new THREE.MeshStandardMaterial({ color:0xd9d9d9 }));
                radar.position.set(0, tower.position.y + 10, -hullLen*0.08);
                radar.rotation.x = Math.PI/2; g.add(radar);
                // Ê°ÖÊùÜÔºàÈ´òÂ∫¶7Ôºâ
                const mastHeight = 7;
                const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,mastHeight,10), new THREE.MeshStandardMaterial({ color:0xdddddd, metalness:0.4, roughness:0.5 }));
                mast.position.set(0, deck.position.y + mastHeight/2 + 2, 0);
                mast.castShadow = true; g.add(mast);
                // Á∫¢Ëâ≤ÁÆ≠Â§¥ÊåáÁ§∫Âô®Ôºà‰∏éÂù¶ÂÖãÈ£éÊ†ºÁªü‰∏ÄÔºâ
                const arrowGroup = new THREE.Group();
                const arrowMat = new THREE.MeshBasicMaterial({ color:0xff2222 });
                const cone = new THREE.Mesh(new THREE.ConeGeometry(3.2,9,18), arrowMat);
                cone.rotation.x = Math.PI; arrowGroup.add(cone);
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,4.5,12), arrowMat);
                stem.position.y = -6.5; arrowGroup.add(stem);
                arrowGroup.position.set(0, deck.position.y + 18, 0);
                arrowGroup.userData = { pulsePhase: Math.random()*Math.PI*2 };
                g.add(arrowGroup);
                // ÁÇÆÂ°î (ÂâçÂêéÂêÑ‰∏Ä‰∏™ÁÆÄÂåñ)
                const turretMat = new THREE.MeshStandardMaterial({ color:0x5b6068, metalness:0.3, roughness:0.6 });
                const shipTurretGeo = new THREE.CylinderGeometry(6,6,4,12);
                const mkTurret1 = new THREE.Mesh(shipTurretGeo, turretMat); mkTurret1.position.set(0, deck.position.y + 3, hullLen*0.18); mkTurret1.castShadow=true; g.add(mkTurret1);
                const mkTurret2 = new THREE.Mesh(shipTurretGeo, turretMat); mkTurret2.position.set(0, deck.position.y + 3, -hullLen*0.25); mkTurret2.castShadow=true; g.add(mkTurret2);
                // ÁÇÆÁÆ°ÂèåËÅî
                const barrelGeo = new THREE.CylinderGeometry(0.7,0.9,18,12);
                [mkTurret1, mkTurret2].forEach((tur,idx)=>{
                    for(let b=0;b<2;b++){
                        const barrel = new THREE.Mesh(barrelGeo, new THREE.MeshStandardMaterial({ color:0x3a3d42, metalness:0.5, roughness:0.4 }));
                        barrel.rotation.x = Math.PI/2;
                        barrel.position.set((b===0? -1.2:1.2), tur.position.y, tur.position.z + (idx===0? 8: -8));
                        barrel.position.y += 2;
                        g.add(barrel);
                    }
                });
                g.position.set(x,0,z);
                this.scene.add(g);
                
                // Create health bar for ship
                const healthBar = this.createHealthBar();
                const maxHealth = 6; // Ships are tougher than tanks
                
                return { 
                    mesh: g, 
                    alive: true, 
                    radius: hullWidth*2, 
                    indicator: arrowGroup,
                    // Health system
                    health: maxHealth,
                    maxHealth: maxHealth,
                    healthBar: healthBar,
                    // Warship shooting properties
                    lastShotTime: 0,
                    shootingRange: 1000, // Reduced range
                    fireRate: 3.0 + Math.random() * 2.0, // 3.0-5.0 seconds between shots (slower)
                    accuracy: 0.4 + Math.random() * 0.2 // 40-60% accuracy (less accurate)
                };
            }
            createSeaScorch(x,z){
                const r = 18 + Math.random()*12;
                const geo = new THREE.CircleGeometry(r, 22);
                const mat = new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.25 });
                const scorch = new THREE.Mesh(geo, mat);
                scorch.rotation.x = -Math.PI/2;
                scorch.position.set(x, -39.9, z);
                this.scene.add(scorch);
                setTimeout(()=>{ this.scene.remove(scorch); geo.dispose(); mat.dispose(); }, 8000);
            }

            // === ÁéØÂ¢ÉÁ≥ªÁªüÂáΩÊï∞ ===
            
            createTrees() {
                const m = this.environmentConfig.treeDensityMultiplier;
                this.createDenseForest(-2500, -2000, 800, 600, 'pine', Math.round(80*m));
                this.createDenseForest(1800, 1500, 700, 500, 'oak', Math.round(70*m));
                this.createMediumForest(-1000, 2200, 900, 700, 'mixed', Math.round(45*m));
                this.createMediumForest(2200, -800, 600, 800, 'birch', Math.round(40*m));
                this.createSparseForest(-3000, 0, 1200, 800, 'oak', Math.round(25*m));
                this.createSparseForest(0, -2800, 1000, 600, 'pine', Math.round(20*m));
                this.createSparseForest(1000, 3000, 800, 600, 'palm', Math.round(15*m));
                for (let i = 0; i < Math.round(100*m); i++) {
                    const x = (Math.random()-0.5)*7000;
                    const z = (Math.random()-0.5)*7000;
                    const treeType = ['pine','oak','birch','palm'][Math.floor(Math.random()*4)];
                    this.createTree(x,z,treeType);
                }
            }

            // ÂØÜÈõÜÊ£ÆÊûó - Ê†ëÊú®Á¥ßÂØÜÊéíÂàó
            createDenseForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    // ‰ΩøÁî®ËÅöÈõÜÂàÜÂ∏ÉÔºåÊ®°ÊãüÁúüÂÆûÊ£ÆÊûó
                    const clusterX = centerX + (Math.random() - 0.5) * width * 0.8;
                    const clusterZ = centerZ + (Math.random() - 0.5) * depth * 0.8;
                    
                    // Âú®ËÅöÈõÜÁÇπÂë®Âõ¥ÈöèÊú∫ÂàÜÂ∏É
                    const offsetX = (Math.random() - 0.5) * 50;
                    const offsetZ = (Math.random() - 0.5) * 50;
                    
                    this.createTree(clusterX + offsetX, clusterZ + offsetZ, forestType);
                }
            }

            // ‰∏≠Á≠âÂØÜÂ∫¶Ê£ÆÊûó
            createMediumForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    const x = centerX + (Math.random() - 0.5) * width;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // ÈöèÊú∫Ë∑≥Ëøá‰∏Ä‰∫õ‰ΩçÁΩÆÔºåÂàõÈÄ†Á©∫Èöô
                    if (Math.random() > 0.3) {
                        this.createTree(x, z, forestType);
                    }
                }
            }

            // Á®ÄÁñèÊ£ÆÊûó
            createSparseForest(centerX, centerZ, width, depth, forestType, treeCount) {
                for (let i = 0; i < treeCount; i++) {
                    const x = centerX + (Math.random() - 0.5) * width;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // Á®ÄÁñèÂàÜÂ∏ÉÔºåÊõ¥Â§öÁ©∫Êó∑Âå∫Âüü
                    if (Math.random() > 0.6) {
                        this.createTree(x, z, forestType);
                    }
                }
            }

            // === ÊπñÊ≥äÁ≥ªÁªüÔºàÊõøÊç¢ÂéüÂÖàÁöÑÊ≤≥ÊµÅÁ≥ªÁªüÔºâ ===
            createLakes() {
                // ÂàõÂª∫Â§ö‰∏™‰∏çÂêåÂ§ßÂ∞è‰∏éÂΩ¢Áä∂ÁöÑÊπñÊ≥ä
                const lakeConfigs = [
                    { x: -1500, z: -1200, radius: 350, color: 0x3A87BD }, // Â§ßÊπñ
                    { x: 1200, z: 800, radius: 250, color: 0x357EBA },   // ‰∏≠ÂûãÊπñ
                    { x: 400, z: -1400, radius: 180, color: 0x2F6FAF },  // ‰∏≠Â∞èÊπñ
                    { x: -800, z: 1600, radius: 200, color: 0x337BB5 },  // Ê£ÆÊûóÊπñ
                    { x: 1800, z: -600, radius: 150, color: 0x2E75AA }   // ‰∏òÈôµÊπñ
                ];

                lakeConfigs.forEach(cfg => this.createLake(cfg.x, cfg.z, cfg.radius, cfg.color));

                // ÁîüÊàê‰∏Ä‰∫õÈöèÊú∫Â∞èÊπñ/Ê±†Â°ò
                for (let i = 0; i < 6; i++) {
                    const x = (Math.random() - 0.5) * 6000;
                    const z = (Math.random() - 0.5) * 6000;
                    const r = 80 + Math.random() * 140;
                    this.createLake(x, z, r, 0x2F6FAF);
                }
            }

            createLake(centerX, centerZ, radius, color) {
                // ‰ΩøÁî®ÁªÜÂàÜÂúÜÂΩ¢Âπ∂ÈöèÊú∫Êâ∞Âä®È°∂ÁÇπÂà∂ÈÄ†Ëá™ÁÑ∂Â§ñÂΩ¢
                const segments = 48;
                const geometry = new THREE.CircleGeometry(radius, segments);
                const pos = geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    if (i === 0) continue; // Ë∑≥Ëøá‰∏≠ÂøÉÁÇπ
                    const vx = pos.getX(i);
                    const vy = pos.getY(i);
                    const r = Math.sqrt(vx * vx + vy * vy);
                    const deform = 1 + (Math.random() - 0.5) * 0.15; // ËΩªÂæÆÂΩ¢Âèò
                    pos.setX(i, vx * deform);
                    pos.setY(i, vy * deform);
                }
                pos.needsUpdate = true;

                // Ê∑ªÂä†ËΩªÂæÆÊ≥¢Êµ™Ê≥ïÁ∫øÊïàÊûúÔºàÈ°∂ÁÇπÊäñÂä®ÂèØÈÄâÔºâ
                geometry.computeVertexNormals();

                const material = new THREE.MeshLambertMaterial({
                    color,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });

                const lake = new THREE.Mesh(geometry, material);
                lake.rotation.x = -Math.PI / 2;
                lake.position.set(centerX, -46, centerZ); // ‰∏éÂú∞Èù¢Á®çÂæÆÂáπÈô∑‰∏ÄÁÇπ
                lake.receiveShadow = true;
                this.scene.add(lake);

                // ÁéØÊπñÊ§çË¢´ÔºöÂú®ÊπñÊ≥äÂ§ñÂúàÈöèÊú∫ÁîüÊàêÊ†ëÊú®ÂíåÁÅåÊú®
                const ringCount = Math.floor(radius / 20);
                for (let i = 0; i < ringCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = radius + 30 + Math.random() * 120;
                    const x = centerX + Math.cos(angle) * dist;
                    const z = centerZ + Math.sin(angle) * dist;
                    const types = ['birch', 'oak', 'pine'];
                    this.createTree(x, z, types[Math.floor(Math.random() * types.length)]);
                }
            }

            createTree(x, z, treeType = 'oak') {
                const treeGroup = new THREE.Group();
                
                // Ocean scene: Generate raised sandy islands (cone-like) under trees
                if (this.sceneType === 'ocean') {
                    const baseRadius = treeType === 'palm' ? 30 : 22;
                    const islandRadiusTop = baseRadius * 0.7;
                    const islandRadiusBottom = baseRadius + Math.random() * (treeType === 'palm' ? 18 : 10);
                    const height = 8 + Math.random()*4; // ÊòéÊòæÈ´ò‰∫éÊ∞¥Èù¢ (Ê∞¥Èù¢ ~ -40)
                    const geo = new THREE.CylinderGeometry(islandRadiusTop, islandRadiusBottom, height, 24, 1, false);
                    geo.translate(0, height/2, 0);
                    const sandColor = new THREE.Color().setHSL(0.12 + Math.random()*0.04, 0.55, 0.62); // ‰∫ÆÈªÑÊ≤ô
                    const island = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color: sandColor }));
                    island.position.set(x, -50, z); // Â∫ïÈÉ®Ë¥¥ËøëÂéüËôöÊãüÂú∞Âπ≥ (-50)
                    island.castShadow = true; island.receiveShadow = true;
                    island.userData.isIsland = true;
                    // È°∂ÈÉ®ÂÜçÂä†‰∏ÄÂúàÊõ¥ÊµÖÁöÑÊ≤ôÊª©ËæπÁºò
                    const rimGeo = new THREE.CylinderGeometry(islandRadiusTop*1.05, islandRadiusTop*1.25, 1.2, 24, 1, false);
                    const rim = new THREE.Mesh(rimGeo, new THREE.MeshLambertMaterial({ color: 0xF5E7A1 }));
                    rim.position.y = height + -50 - 0.4; // Ë¥¥ËøëÈ°∂ÈÉ®
                    rim.receiveShadow = true;
                    island.add(rim);
                    this.scene.add(island);
                }

                let trunkHeight, trunkRadius;
                
                switch(treeType) {
                    case 'pine': // ‰ºòÁæéÁöÑÊùæÊ†ë
                        trunkHeight = 15 + Math.random() * 10;
                        trunkRadius = 0.6 + Math.random() * 0.3;
                        
                        // ÊùæÊ†ëÊ†ëÂπ≤ - Ëá™ÁÑ∂Ê£ïËâ≤
                        const pineTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.7, trunkRadius * 1.2, trunkHeight, 8
                        );
                        const pineTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B4513 // Ê∏©ÊöñÁöÑÊ£ïËâ≤
                        });
                        const pineTrunk = new THREE.Mesh(pineTrunkGeometry, pineTrunkMaterial);
                        pineTrunk.position.y = trunkHeight / 2 - 50;
                        pineTrunk.castShadow = true;
                        treeGroup.add(pineTrunk);
                        
                        // ÊùæÊ†ëÂ±ÇÁä∂Ê†ëÂÜ† - Ê∑±ÁªøÂà∞ÊµÖÁªøÊ∏êÂèò
                        const greenShades = [0x0F4F0F, 0x228B22, 0x32CD32, 0x90EE90];
                        for (let layer = 0; layer < 5; layer++) {
                            const layerRadius = 5 - layer * 0.7;
                            const layerHeight = 3.5 + Math.random() * 0.5;
                            const crownGeometry = new THREE.ConeGeometry(layerRadius, layerHeight, 8);
                            const crownMaterial = new THREE.MeshLambertMaterial({ 
                                color: greenShades[Math.min(layer, 3)]
                            });
                            const crownLayer = new THREE.Mesh(crownGeometry, crownMaterial);
                            crownLayer.position.y = trunkHeight - 50 + layer * 2.8;
                            crownLayer.castShadow = true;
                            treeGroup.add(crownLayer);
                        }
                        break;
                        
                    case 'oak': // ÈõÑ‰ºüÁöÑÊ©°Ê†ë
                        trunkHeight = 10 + Math.random() * 8;
                        trunkRadius = 1.2 + Math.random() * 0.6;
                        
                        // Ê©°Ê†ëÁ≤óÂ£ÆÊ†ëÂπ≤ - Ê∑±Ê£ïËâ≤
                        const oakTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.8, trunkRadius * 1.4, trunkHeight, 8
                        );
                        const oakTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x654321 // Ê∑±Ê£ïËâ≤
                        });
                        const oakTrunk = new THREE.Mesh(oakTrunkGeometry, oakTrunkMaterial);
                        oakTrunk.position.y = trunkHeight / 2 - 50;
                        oakTrunk.castShadow = true;
                        treeGroup.add(oakTrunk);
                        
                        // Ê©°Ê†ëËåÇÂØÜÊ†ëÂÜ† - Â§öÂ±ÇÁªìÊûÑ
                        const mainCrownGeometry = new THREE.SphereGeometry(6 + Math.random() * 2, 10, 8);
                        mainCrownGeometry.scale(1.4, 0.9, 1.4); // ÂéãÊâÅÁöÑÂÆΩÈòîÊ†ëÂÜ†
                        const mainCrownMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22 // Ê£ÆÊûóÁªø
                        });
                        const mainCrown = new THREE.Mesh(mainCrownGeometry, mainCrownMaterial);
                        mainCrown.position.y = trunkHeight - 50 + 4;
                        mainCrown.castShadow = true;
                        treeGroup.add(mainCrown);
                        
                        // È¢ùÂ§ñÁöÑÂ∞èÊ†ëÂÜ†Â¢ûÂä†Â±ÇÊ¨°ÊÑü
                        for (let i = 0; i < 3; i++) {
                            const smallCrownGeometry = new THREE.SphereGeometry(2 + Math.random(), 8, 6);
                            const smallCrownMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x32CD32 // ËæÉ‰∫ÆÁöÑÁªøËâ≤
                            });
                            const smallCrown = new THREE.Mesh(smallCrownGeometry, smallCrownMaterial);
                            smallCrown.position.set(
                                (Math.random() - 0.5) * 8,
                                trunkHeight - 50 + 3 + Math.random() * 3,
                                (Math.random() - 0.5) * 8
                            );
                            smallCrown.castShadow = true;
                            treeGroup.add(smallCrown);
                        }
                        break;
                        
                    case 'birch': // ‰ºòÈõÖÁöÑÊ°¶Ê†ë
                        trunkHeight = 12 + Math.random() * 6;
                        trunkRadius = 0.4 + Math.random() * 0.2;
                        
                        // Ê°¶Ê†ëÁªÜÈïøÁôΩËâ≤Ê†ëÂπ≤
                        const birchTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.9, trunkRadius * 1.1, trunkHeight, 8
                        );
                        const birchTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xF5F5DC // ‰ºòÈõÖÁöÑÁ±≥Ëâ≤ÁôΩ
                        });
                        const birchTrunk = new THREE.Mesh(birchTrunkGeometry, birchTrunkMaterial);
                        birchTrunk.position.y = trunkHeight / 2 - 50;
                        birchTrunk.castShadow = true;
                        treeGroup.add(birchTrunk);
                        
                        // Ê°¶Ê†ëÂûÇÊü≥Áä∂Ê†ëÂÜ†
                        const birchCrownGeometry = new THREE.SphereGeometry(4 + Math.random() * 1.5, 8, 6);
                        birchCrownGeometry.scale(1.2, 1.4, 1.2); // Á®çÂæÆÊãâÈïø
                        const birchCrownMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x9ACD32 // ÈªÑÁªøËâ≤
                        });
                        const birchCrown = new THREE.Mesh(birchCrownGeometry, birchCrownMaterial);
                        birchCrown.position.y = trunkHeight - 50 + 3;
                        birchCrown.castShadow = true;
                        treeGroup.add(birchCrown);
                        break;
                        
                    case 'palm': // ÁÉ≠Â∏¶Ê£ïÊ¶àÊ†ë
                        trunkHeight = 14 + Math.random() * 8;
                        trunkRadius = 0.8;
                        
                        // Ê£ïÊ¶àÊ†ëÂºØÊõ≤Ê†ëÂπ≤
                        const palmTrunkGeometry = new THREE.CylinderGeometry(
                            trunkRadius * 0.6, trunkRadius, trunkHeight, 8
                        );
                        const palmTrunkMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xD2691E // Ê∏©ÊöñÁöÑÊ©ôÊ£ïËâ≤
                        });
                        const palmTrunk = new THREE.Mesh(palmTrunkGeometry, palmTrunkMaterial);
                        palmTrunk.position.y = trunkHeight / 2 - 50;
                        palmTrunk.rotation.z = (Math.random() - 0.5) * 0.4; // ËΩªÂæÆÂÄæÊñú
                        palmTrunk.castShadow = true;
                        treeGroup.add(palmTrunk);
                        
                        // Ê£ïÊ¶àÂè∂ - Êõ¥ÁúüÂÆûÁöÑÈÄ†Âûã
                        for (let leaf = 0; leaf < 12; leaf++) {
                            const leafGeometry = new THREE.CylinderGeometry(0.1, 0.4, 7, 4);
                            const leafMaterial = new THREE.MeshLambertMaterial({ 
                                color: 0x228B22 // ÁÉ≠Â∏¶Áªø
                            });
                            const palmLeaf = new THREE.Mesh(leafGeometry, leafMaterial);
                            const angle = (leaf / 12) * Math.PI * 2;
                            const radius = 2.5 + Math.random() * 0.5;
                            palmLeaf.position.set(
                                Math.cos(angle) * radius,
                                trunkHeight - 50 + 3,
                                Math.sin(angle) * radius
                            );
                            palmLeaf.rotation.z = angle + Math.PI / 2.5; // ÂêëÂ§ñÂºØÊõ≤
                            palmLeaf.rotation.x = (Math.random() - 0.5) * 0.3; // ÈöèÊú∫ÂÄæÊñú
                            palmLeaf.castShadow = true;
                            treeGroup.add(palmLeaf);
                        }
                        break;
                        
                    case 'mixed':
                        // Ê∑∑ÂêàÊûó‰∏≠ÈöèÊú∫ÈÄâÊã©Ê†ëÁßç
                        const mixedTypes = ['pine', 'oak', 'birch'];
                        return this.createTree(x, z, mixedTypes[Math.floor(Math.random() * mixedTypes.length)]);
                }
                
                // Ê∑ªÂä†ËΩªÂæÆÈöèÊú∫ÊóãËΩ¨ÔºåÂ¢ûÂä†Ëá™ÁÑ∂ÊÑü
                treeGroup.rotation.y = Math.random() * Math.PI * 2;
                treeGroup.position.set(x, 0, z);
                this.scene.add(treeGroup);
            }

            // === Extra Environment Helpers ===
            createBushCluster(x,z,count=8){
                for (let i=0;i<count;i++){
                    const r = 2 + Math.random()*2.5;
                    const g = new THREE.SphereGeometry(r, 8, 6);
                    const c = new THREE.Color().setHSL(0.28 + Math.random()*0.08, 0.6, 0.35+Math.random()*0.2);
                    const m = new THREE.MeshLambertMaterial({ color: c });
                    const bush = new THREE.Mesh(g,m);
                    const ang = Math.random()*Math.PI*2;
                    const dist = Math.random()*8;
                    bush.position.set(x + Math.cos(ang)*dist, -50 + r*0.5, z + Math.sin(ang)*dist);
                    bush.castShadow = true;
                    this.scene.add(bush);
                }
            }

            createRocks(count){
                for (let i=0;i<count;i++){
                    const s = 3 + Math.random()*10;
                    const g = new THREE.DodecahedronGeometry(s, 0);
                    const col = new THREE.Color().setHSL(0.08 + Math.random()*0.05, 0.2, 0.25 + Math.random()*0.2);
                    const m = new THREE.MeshLambertMaterial({ color: col });
                    const rock = new THREE.Mesh(g,m);
                    rock.position.set((Math.random()-0.5)*7600, -50 + s*0.5, (Math.random()-0.5)*7600);
                    rock.rotation.y = Math.random()*Math.PI*2;
                    rock.castShadow = true;
                    this.scene.add(rock);
                }
            }

            createGrassPatches(count){
                for (let i=0;i<count;i++){
                    const blades = new THREE.Group();
                    const baseX = (Math.random()-0.5)*7600;
                    const baseZ = (Math.random()-0.5)*7600;
                    const bladeCount = 4 + Math.random()*6;
                    for (let b=0;b<bladeCount;b++){
                        const h = 4 + Math.random()*6;
                        const geo = new THREE.CylinderGeometry(0.05,0.25,h,4,1);
                        const mat = new THREE.MeshLambertMaterial({ color: 0x3c8d1e });
                        const blade = new THREE.Mesh(geo,mat);
                        blade.position.set((Math.random()-0.5)*3, -50 + h/2, (Math.random()-0.5)*3);
                        blade.rotation.x = (Math.random()-0.5)*0.4;
                        blade.rotation.z = (Math.random()-0.5)*0.4;
                        blades.add(blade);
                    }
                    blades.position.set(baseX,0,baseZ);
                    this.scene.add(blades);
                }
            }

            createBirdFlock(){
                const flock = new THREE.Group();
                const count = 12 + Math.floor(Math.random()*8);
                for (let i=0;i<count;i++){
                    const geo = new THREE.ConeGeometry(1.2,3,4);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                    const bird = new THREE.Mesh(geo,mat);
                    bird.rotation.x = Math.PI/2;
                    bird.position.set((Math.random()-0.5)*30,(Math.random()-0.5)*10,(Math.random()-0.5)*30);
                    flock.add(bird);
                }
                flock.position.set((Math.random()-0.5)*6000,150 + Math.random()*250,(Math.random()-0.5)*6000);
                flock.userData = { speed: 20 + Math.random()*15, dir: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize() };
                this.scene.add(flock);
                if(!this.flocks) this.flocks=[];
                this.flocks.push(flock);
            }

            updateFlocks(delta){
                if(!this.flocks) return;
                this.flocks.forEach(f=>{
                    f.position.addScaledVector(f.userData.dir, f.userData.speed*delta);
                    f.position.y += Math.sin(Date.now()*0.001 + f.position.x*0.01)*0.2;
                    const limit = 4000;
                    if (f.position.x > limit) f.position.x = -limit;
                    if (f.position.x < -limit) f.position.x = limit;
                    if (f.position.z > limit) f.position.z = -limit;
                    if (f.position.z < -limit) f.position.z = limit;
                });
            }

            createSoilPatches(count){
                for (let i=0;i<count;i++){
                    const r = 40 + Math.random()*120;
                    const geo = new THREE.CircleGeometry(r, 24);
                    const posAttr = geo.attributes.position;
                    for (let v=0; v<posAttr.count; v++) { // ËΩªÂæÆÊâ∞Âä®ËæπÁºò
                        if (v===0) continue;
                        const x = posAttr.getX(v); const y = posAttr.getY(v);
                        const dist = Math.hypot(x,y);
                        const factor = 1 + (Math.random()-0.5)*0.25;
                        posAttr.setX(v, x * factor);
                        posAttr.setY(v, y * factor);
                    }
                    posAttr.needsUpdate = true;
                    const colors = [0x7b5e31,0x6b4a1f,0xa07547,0x8a6235];
                    const mat = new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random()*colors.length)], side: THREE.DoubleSide, opacity: 0.92, transparent: true });
                    const patch = new THREE.Mesh(geo, mat);
                    patch.rotation.x = -Math.PI/2;
                    patch.position.set((Math.random()-0.5)*7600, -49.9, (Math.random()-0.5)*7600);
                    patch.receiveShadow = true;
                    this.scene.add(patch);
                }
            }

            // ================= Tanks =================
            getGroundHeight(x,z){
                if(!this.ground) return -50;
                this.raycaster.set(new THREE.Vector3(x, 500, z), new THREE.Vector3(0,-1,0));
                const hit = this.raycaster.intersectObject(this.ground, false);
                return hit.length ? hit[0].point.y : -50;
            }

            alignTankToGround(group){
                // ËÆ°ÁÆóÂ±•Â∏¶/Â∫ïÂ∫ßÂÅáÂÆöÂü∫ÂáÜÔºöÊàë‰ª¨Â∞Ü group ÁöÑÂ±ÄÈÉ®ÂéüÁÇπËßÜ‰∏∫Â∫ïÂ∫ß‰∏≠ÂøÉÈ´òÂ∫¶ (approx hull center -2.5)
                // ‰ΩøÁî®Â∞ÑÁ∫øËé∑ÂæóÁúüÂÆûÂú∞Èù¢ÔºåÁÑ∂ÂêéËÆæÁΩÆ group.position.y ‰ΩøÂ∫ïÈù¢Á¶ªÂú∞Èù¢Áï•ÂæÆ‚ÄúÊÇ¨Á©∫‚Äù 0.4
                const gY = this.getGroundHeight(group.position.x, group.position.z);
                // Áî±‰∫é hull.position.y = -50 + 2.5 (Âú®ÊûÑÈÄ†‰∏≠)Ôºågroup.position.y ÂàùÂßã‰∏∫ 0 Êó∂ hull Â∫ïÈÉ®Âú® -50
                // Âõ†Ê≠§ÂΩì group.position.y ÂÅèÁßª d Êó∂ÔºåÂ∫ïÈÉ® = -50 + d
                // Êàë‰ª¨Â∏åÊúõÂ∫ïÈÉ® = gY + 4.0 ÔºàÊä¨Á¶ªÂú∞Èù¢ 4 Âçï‰ΩçÔºâ
                const desiredBottom = gY + 4.0;
                const d = desiredBottom - (-50);
                group.position.y = d;
            }
            createTanks(count=10){
                for (let i=0;i<count;i++) {
                    const x = (Math.random()-0.5)*7000;
                    const z = (Math.random()-0.5)*7000;
                    // ÈÅøÂÖçÁ¶ªÁé©ÂÆ∂Âá∫ÁîüÁÇπÂ§™Ëøë
                    if (Math.hypot(x, z) < 400) { i--; continue; }
                    const tank = this.createTank(x, z);
                    this.tanks.push(tank);
                }
                // ÂàõÂª∫ÂêéÁªü‰∏ÄÂØπÈΩê‰∏ÄÊ¨°ÔºàÂÜó‰ΩôÂÆâÂÖ®Ôºâ
                this.tanks.forEach(t=> this.alignTankToGround(t.mesh));
            }

            createTank(x,z){
                const group = new THREE.Group();
                const palette = [0x4d5a34,0x556b2f,0x6e5b2e,0x5c6133];
                const baseColor = palette[Math.floor(Math.random()*palette.length)];
                const baseMat = new THREE.MeshStandardMaterial({ color: baseColor, metalness:0.25, roughness:0.75 });

                // === Áü©ÂΩ¢Â∫ïÂ∫ß (narrower & taller) ===
                const hullWidth = 24; // narrower (was 30)
                const hullHeight = 8; // taller (was 5)
                const hullLength = 46;
                const hull = new THREE.Mesh(new THREE.BoxGeometry(hullWidth, hullHeight, hullLength), baseMat);
                hull.position.y = -50 + hullHeight/2;
                hull.castShadow = true; hull.receiveShadow = true;
                group.add(hull);

                // === Â±•Â∏¶‰∏é5‰∏™Ë¥üÈáçËΩÆÔºàÊØè‰æßÔºâ ===
                const trackMat = new THREE.MeshStandardMaterial({ color:0x1d1d1d, roughness:0.95 });
                for (let side of [-1,1]){
                    const track = new THREE.Mesh(new THREE.BoxGeometry(4, hullHeight-1.8, hullLength), trackMat);
                    track.position.set(side*(hullWidth/2+3.2), -50 + (hullHeight-1.8)/2, 0);
                    track.castShadow = true; group.add(track);
                }
                const wheelGeo = new THREE.CylinderGeometry(2.4,2.4,1.4,18);
                const wheelMat = new THREE.MeshStandardMaterial({ color:0x3a3a3a, metalness:0.4, roughness:0.6 });
                const wheelZs = [-14,-7,0,7,14];
                for (let side of [-1,1]){
                    wheelZs.forEach(zv=>{
                        const w = new THREE.Mesh(wheelGeo, wheelMat);
                        w.rotation.z = Math.PI/2;
                        w.position.set(side*(hullWidth/2+3.2), -50 + 1.6, zv);
                        group.add(w);
                    });
                }

                // === ÂúÜÊü±ÁÇÆÂ°î ===
                const turretHeight = 9; // Â¢ûÈ´òÁÇÆÂ°î (Âéü 4 -> 7 -> 9)
                const turret = new THREE.Mesh(new THREE.CylinderGeometry(10,10,turretHeight,24), baseMat);
                const turretY = -50 + 2.5 + 2.5 + turretHeight/2; // Â∫ïÂ∫ßÈ°∂Èù¢ + ÁÇÆÂ°î‰∏ÄÂçäÈ´òÂ∫¶ (‰ªç‰ΩøÁî®ÊóßÂ∫ïÁõòÈ´òÂ∫¶ÈÄªËæë)
                turret.position.set(0, turretY, 0);
                turret.castShadow = true; turret.receiveShadow = true;
                group.add(turret);
                // === È°∂ÈÉ®Ëà±Èó®ÔºàÂúÜÂΩ¢ÂúÜÊü±ÔºåÈ´òÂ∫¶2 ÂçäÂæÑ2Ôºâ ===
                const hatchGeo = new THREE.CylinderGeometry(2,2,2,24);
                const hatchMat = new THREE.MeshStandardMaterial({ color: baseColor });
                const hatch = new THREE.Mesh(hatchGeo, hatchMat);
                hatch.position.set(0, turretY + turretHeight/2 + 1, 0); // ÊîæÂú®ÁÇÆÂ°îÈ°∂ÈÉ®Ê≠£‰∏≠
                hatch.castShadow = true; hatch.receiveShadow = true;
                group.add(hatch);

                // === ‰∏ªÊ≠¶Âô®ÊàñÈò≤Á©∫Êú∫Êû™ÈÖçÁΩÆ ===
                const aaVariant = Math.random() < 0.30; // 30% Èò≤Á©∫Âù¶ÂÖã
                if (!aaVariant) {
                    // Â∏∏ËßÑÁÇÆÁÆ°Ôºà‰ªéÁÇÆÂ°î‰∏≠ÂøÉ 35¬∞ Êä¨Ëµ∑Ôºâ
                    const gunPivot = new THREE.Group();
                    gunPivot.name = 'gunPivot'; // Set name for wreck conversion
                    gunPivot.position.set(0, turretY, 0);
                    group.add(gunPivot);
                    const barrelMat = new THREE.MeshStandardMaterial({ color:0x2d2d2d, metalness:0.6, roughness:0.45 });
                    const barrelLength = 26;
                    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.85,barrelLength,18), barrelMat);
                    barrel.rotation.x = Math.PI/2;
                    barrel.position.z = barrelLength/2 + 2;
                    gunPivot.add(barrel);
                    const inner = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,2,12), new THREE.MeshStandardMaterial({ color:0x050505, metalness:0.3, roughness:0.9 }));
                    inner.rotation.x = Math.PI/2;
                    inner.position.z = barrelLength + 2;
                    gunPivot.add(inner);
                    gunPivot.rotation.x = -THREE.MathUtils.degToRad(35);
                } else {
                    // Èò≤Á©∫ÂûãÔºöÂõõËÅîÊú∫Êû™Â°î
                    const mgGroup = new THREE.Group();
                    mgGroup.position.set(0, turretY + turretHeight/2 * 0.2, 0);
                    const mount = new THREE.Mesh(new THREE.CylinderGeometry(2.4,2.6,2.2,16), new THREE.MeshStandardMaterial({ color: baseColor*0.9, metalness:0.4, roughness:0.6 }));
                    mount.castShadow = true; mgGroup.add(mount);
                    const gunMat = new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.55, roughness:0.35 });
                    const tubeGeo = new THREE.CylinderGeometry(0.35,0.35,17,10); // Âä†Èïø3
                    const muzzleGeo = new THREE.CylinderGeometry(0.18,0.18,0.9,10);
                    const offsets = [ [-0.9,0.5], [0.9,0.5], [-0.9,-0.5], [0.9,-0.5] ];
                    offsets.forEach(([ox,oy])=>{
                        const tube = new THREE.Mesh(tubeGeo, gunMat);
                        tube.rotation.x = Math.PI/2;
                        tube.position.set(ox, oy, 6.5 + 1.5); // ÂâçÁßª‰ª•‰øùÊåÅÂêéÁ´Ø‰ΩçÁΩÆËøë‰ºº‰∏çÂèò
                        tube.castShadow = true;
                        mgGroup.add(tube);
                        const muzzle = new THREE.Mesh(muzzleGeo, gunMat);
                        muzzle.rotation.x = Math.PI/2;
                        muzzle.position.set(ox, oy, 13.2 + 1.5); // ‰∏éÊú∫Êû™Âä†ÈïøÂåπÈÖç
                        mgGroup.add(muzzle);
                    });
                    // ËΩªÂæÆ‰ª∞Ëßí
                    mgGroup.rotation.x = -THREE.MathUtils.degToRad(10);
                    group.add(mgGroup);
                    group.userData.aa = true; // Ê†áËÆ∞Èò≤Á©∫
                }

                // === Á∫¢Ëâ≤È´ò‰∫ÆÊåáÁ§∫ÁÆ≠Â§¥Ôºà‰øùÊåÅÔºâ ===
                const arrowGroup = new THREE.Group();
                const arrowMat = new THREE.MeshBasicMaterial({ color:0xff2222 });
                const cone = new THREE.Mesh(new THREE.ConeGeometry(3.2,9,18), arrowMat);
                cone.rotation.x = Math.PI; // ÊåáÂêë‰∏ã
                arrowGroup.add(cone);
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,4.5,12), arrowMat);
                stem.position.y = -6.5;
                arrowGroup.add(stem);
                arrowGroup.position.set(0, turretY + 12, 0);
                arrowGroup.userData = { pulsePhase: Math.random()*Math.PI*2 };
                group.add(arrowGroup);

                group.position.set(x,0,z);
                // Ë¥¥ÂêàÂú∞Èù¢È´òÂ∫¶
                this.alignTankToGround(group);
                this.scene.add(group);
                
                // Create health bar
                const healthBar = this.createHealthBar();
                
                // Add movement properties for dynamic animation
                const moveSpeed = 15 + Math.random() * 10; // 15-25 units per second
                const direction = Math.random() * Math.PI * 2; // Random initial direction
                const turretSpeed = (Math.random() - 0.5) * 0.3; // -0.15 to +0.15 rad/s
                
                // Determine tank type and health
                const isAA = aaVariant;
                const maxHealth = isAA ? 4 : 3; // AA tanks are tougher
                
                return { 
                    mesh: group, 
                    alive: true, 
                    radius: 16, 
                    indicator: arrowGroup,
                    // Health system
                    health: maxHealth,
                    maxHealth: maxHealth,
                    healthBar: healthBar,
                    isAA: isAA,
                    // Movement properties
                    velocity: new THREE.Vector3(),
                    moveDirection: direction,
                    moveSpeed: moveSpeed,
                    turretRotation: Math.random() * Math.PI * 2,
                    turretSpeed: turretSpeed,
                    changeDirectionTimer: Math.random() * 8, // Random 0-8 seconds
                    turretReference: turret, // Store reference to turret for rotation
                    // AA shooting properties
                    lastShotTime: 0,
                    shootingRange: 600, // Reduced range for better balance
                    fireRate: 2.0 + Math.random() * 1.5, // 2.0-3.5 seconds between shots (slower)
                    accuracy: 0.5 + Math.random() * 0.2 // 50-70% accuracy (less accurate)
                };
            }

            // === Tank Movement System (Performance Optimized) ===
            updateTanks(deltaTime) {
                if (!this.tanks) return;
                
                // Throttle updates - only update tanks every 3rd frame for smoother performance
                this.tankUpdateCounter = (this.tankUpdateCounter || 0) + 1;
                const shouldUpdateMovement = this.tankUpdateCounter % 3 === 0;
                
                this.tanks.forEach((tank, index) => {
                    if (!tank.alive) return;
                    
                    // Always update turret rotation (lightweight)
                    if (tank.turretReference) {
                        tank.turretRotation += tank.turretSpeed * deltaTime;
                        tank.turretReference.rotation.y = tank.turretRotation;
                    }
                    
                    // Throttle movement updates for performance
                    if (!shouldUpdateMovement) return;
                    
                    // Update direction change timer
                    tank.changeDirectionTimer -= deltaTime * 3; // Compensate for throttling
                    if (tank.changeDirectionTimer <= 0) {
                        const turnAngle = (Math.PI / 2) + (Math.random() * Math.PI / 2);
                        tank.moveDirection += (Math.random() > 0.5) ? turnAngle : -turnAngle;
                        tank.changeDirectionTimer = 4 + Math.random() * 6;
                    }
                    
                    // Calculate movement velocity (reuse existing Vector3)
                    tank.velocity.set(
                        Math.cos(tank.moveDirection) * tank.moveSpeed,
                        0,
                        Math.sin(tank.moveDirection) * tank.moveSpeed
                    );
                    
                    // Apply movement with throttling compensation
                    const moveMultiplier = deltaTime * 3; // Compensate for 1/3 update frequency
                    tank.mesh.position.x += tank.velocity.x * moveMultiplier;
                    tank.mesh.position.z += tank.velocity.z * moveMultiplier;
                    
                    // Boundary checking
                    const worldBoundary = 3500;
                    const pos = tank.mesh.position;
                    if (Math.abs(pos.x) > worldBoundary || Math.abs(pos.z) > worldBoundary) {
                        tank.moveDirection += Math.PI;
                        tank.changeDirectionTimer = 1 + Math.random() * 2;
                    }
                    
                    // Ground alignment - only every 5th tank per frame to spread load
                    const frameOffset = this.tankUpdateCounter + index;
                    if (frameOffset % 15 === 0) { // Every 5 frames for each tank
                        this.alignTankToGround(tank.mesh);
                    }
                    
                    // Tank body rotation (lightweight)
                    tank.mesh.rotation.y = tank.moveDirection;
                    
                    // AA Tank shooting logic (only for AA tanks)
                    if (tank.isAA && tank.alive) {
                        const currentTime = performance.now() / 1000;
                        const timeSinceLastShot = currentTime - tank.lastShotTime;
                        
                        if (timeSinceLastShot > tank.fireRate) {
                            const distanceToPlayer = tank.mesh.position.distanceTo(this.playerPosition);
                            
                            if (distanceToPlayer < tank.shootingRange) {
                                // Calculate lead target position
                                const leadPosition = this.calculateLeadTarget(
                                    tank.mesh.position, 
                                    this.playerPosition, 
                                    this.playerVelocity,
                                    400, // Bullet speed
                                    tank.accuracy
                                );
                                
                                // Create enemy bullet
                                const bulletStartPos = tank.mesh.position.clone();
                                bulletStartPos.y += 10; // Shoot from turret height
                                this.createEnemyBullet(bulletStartPos, leadPosition);
                                
                                // Create muzzle flash for AA tank
                                this.createEnemyMuzzleFlash(bulletStartPos);
                                
                                tank.lastShotTime = currentTime;
                                
                                // Aim turret at target (visual only)
                                if (tank.turretReference) {
                                    const aimDirection = new THREE.Vector3()
                                        .subVectors(leadPosition, tank.mesh.position)
                                        .normalize();
                                    tank.turretReference.rotation.y = Math.atan2(aimDirection.x, aimDirection.z);
                                }
                            }
                        }
                    }
                });
            }

            // === Warship AI System ===
            updateWarships(deltaTime) {
                if (!this.warships) return;
                
                const currentTime = performance.now() / 1000;
                
                this.warships.forEach((ship, index) => {
                    if (!ship.alive) return;
                    
                    // Warship shooting logic
                    const timeSinceLastShot = currentTime - ship.lastShotTime;
                    
                    if (timeSinceLastShot > ship.fireRate) {
                        const distanceToPlayer = ship.mesh.position.distanceTo(this.playerPosition);
                        
                        if (distanceToPlayer < ship.shootingRange) {
                            // Calculate lead target position
                            const leadPosition = this.calculateLeadTarget(
                                ship.mesh.position,
                                this.playerPosition,
                                this.playerVelocity,
                                350, // Slightly slower bullets than AA tanks
                                ship.accuracy
                            );
                            
                            // Create enemy bullet from ship
                            const bulletStartPos = ship.mesh.position.clone();
                            bulletStartPos.y += 25; // Shoot from ship deck height
                            this.createEnemyBullet(bulletStartPos, leadPosition, 350);
                            
                            // Create muzzle flash for warship
                            this.createEnemyMuzzleFlash(bulletStartPos);
                            
                            ship.lastShotTime = currentTime;
                        }
                    }
                });
            }

            updateTankIndicators(delta){
                const t = performance.now()*0.001;
                // Tanks
                if(this.tanks){
                    this.tanks.forEach(tank=>{
                        if(!tank.alive) { if(tank.indicator) tank.indicator.visible=false; return; }
                        if(tank.indicator){
                            tank.indicator.visible = true;
                            tank.indicator.lookAt(this.camera.position);
                            const phase = t*4 + (tank.indicator.userData.pulsePhase||0);
                            const s = 1 + Math.sin(phase)*0.25;
                            tank.indicator.scale.set(s,s,s);
                        }
                    });
                }
                // Warships
                if(this.warships){
                    this.warships.forEach(ship=>{
                        if(!ship.alive) { if(ship.indicator) ship.indicator.visible=false; return; }
                        if(ship.indicator){
                            ship.indicator.visible = true;
                            ship.indicator.lookAt(this.camera.position);
                            const phase = t*4 + (ship.indicator.userData.pulsePhase||0);
                            const s = 1 + Math.sin(phase)*0.25;
                            ship.indicator.scale.set(s,s,s);
                        }
                    });
                }
            }

            createExplosion(position){
                const group = new THREE.Group();
                group.position.copy(position);
                this.scene.add(group);
                // ÈùôÊÄÅÁÅ´Ëä± + ÂéüÂú∞ÁáÉÁÉßÁÅ´ÁÑ∞
                const flameCount = 26;
                for (let i=0;i<flameCount;i++) {
                    const size = 0.9 + Math.random()*1.4;
                    const geo = new THREE.SphereGeometry(size, 6, 6);
                    const col = 0xffa533;
                    const mat = new THREE.MeshBasicMaterial({ color: col, transparent:true, opacity:1 });
                    const p = new THREE.Mesh(geo, mat);
                    // ÈùôÊ≠¢Ôºödir = 0
                    p.userData = { dir: new THREE.Vector3(0,0,0), life: 0.65 + Math.random()*0.5, age:0, flame:true };
                    // ÈöèÊú∫ÂàÜÂ∏ÉÂú®ÁàÜÂøÉËΩªÂæÆÂçäÂæÑÂÜÖ
                    const ang = Math.random()*Math.PI*2; const rad = Math.random()*3.2;
                    p.position.set(Math.cos(ang)*rad, Math.random()*2, Math.sin(ang)*rad);
                    group.add(p);
                }
                // ËΩªÁÉüÂêë‰∏äÔºàÂæàÊÖ¢ÔºåÂá†‰πéÂéüÂú∞Ôºâ
                for (let i=0;i<12;i++) {
                    const geo = new THREE.SphereGeometry(2+Math.random()*2.5, 8,6);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x2b2b2b, transparent:true, opacity:0.55 });
                    const s = new THREE.Mesh(geo, mat);
                    s.userData = { dir: new THREE.Vector3(0, (0.15+Math.random()*0.25), 0), life: 2.2 + Math.random()*0.8, age:0, smoke:true };
                    const ang = Math.random()*Math.PI*2; const rad = Math.random()*2.5;
                    s.position.set(Math.cos(ang)*rad, 0.4+Math.random()*1.2, Math.sin(ang)*rad);
                    group.add(s);
                }
                const animate = () => {
                    const dt = 0.016;
                    group.children.forEach(c=>{
                        if (!c.userData) return;
                        c.userData.age += dt;
                        const ratio = c.userData.age / c.userData.life;
                        // ‰ªÖÁÉüÁºìÊÖ¢‰∏äÂçá
                        if (c.userData.smoke) c.position.add(c.userData.dir.clone().multiplyScalar(dt));
                        if (c.material) {
                            if (c.userData.flame) {
                                c.material.opacity = Math.max(0, 1 - ratio*1.2);
                                c.scale.multiplyScalar(1 + dt*0.8);
                            } else if (c.userData.smoke) {
                                c.material.opacity = Math.max(0, 0.55 * (1 - ratio));
                                c.scale.multiplyScalar(1 + dt*0.35);
                            }
                        }
                    });
                    // Ê∏ÖÁêÜ
                    for (let i=group.children.length-1;i>=0;i--) {
                        const ch = group.children[i];
                        if (ch.userData && ch.userData.age >= ch.userData.life) {
                            group.remove(ch); ch.geometry.dispose(); ch.material.dispose();
                        }
                    }
                    if (group.children.length>0) requestAnimationFrame(animate); else this.scene.remove(group);
                };
                animate();
            }

            // ===== Health Bar System =====
            createHealthBar() {
                const container = document.createElement('div');
                container.className = 'health-bar-container';
                container.style.display = 'none';
                
                const bg = document.createElement('div');
                bg.className = 'health-bar-bg';
                
                const fill = document.createElement('div');
                fill.className = 'health-bar-fill';
                fill.style.width = '100%';
                
                const text = document.createElement('div');
                text.className = 'health-bar-text';
                
                bg.appendChild(fill);
                container.appendChild(bg);
                container.appendChild(text);
                document.body.appendChild(container);
                
                return { container, fill, text };
            }

            updateHealthBar(entity, camera) {
                if (!entity.health || !entity.healthBar || !entity.alive) return;
                
                const { container, fill, text } = entity.healthBar;
                const worldPos = entity.mesh.position.clone();
                worldPos.y += 25; // Offset above entity
                
                // Convert 3D position to screen coordinates
                const screenPos = worldPos.clone();
                screenPos.project(camera);
                
                // Check if entity is in view
                if (screenPos.z > 1 || screenPos.x < -1 || screenPos.x > 1 || screenPos.y < -1 || screenPos.y > 1) {
                    container.style.display = 'none';
                    return;
                }
                
                // Convert to pixel coordinates
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;
                
                // Update position
                container.style.left = x + 'px';
                container.style.top = y + 'px';
                container.style.display = 'block';
                
                // Update health percentage
                const healthPercent = (entity.health / entity.maxHealth) * 100;
                fill.style.width = healthPercent + '%';
                
                // Update color based on health
                if (healthPercent > 66) {
                    fill.style.background = 'linear-gradient(90deg, #44ff44, #88ff88)';
                } else if (healthPercent > 33) {
                    fill.style.background = 'linear-gradient(90deg, #ffaa00, #ffdd44)';
                } else {
                    fill.style.background = 'linear-gradient(90deg, #ff4444, #ff7777)';
                }
                
                // Update text
                text.textContent = `${entity.health}/${entity.maxHealth}`;
            }

            updateHealthBars() {
                // Update health bars for all tanks
                if (this.tanks && this.tanks.length > 0) {
                    this.tanks.forEach(tank => {
                        if (tank.alive && tank.healthBar && tank.health < tank.maxHealth) {
                            this.updateHealthBar(tank, this.camera);
                        } else if (tank.healthBar) {
                            // Hide health bar if tank is at full health
                            tank.healthBar.container.style.display = 'none';
                        }
                    });
                }
                
                // Update health bars for all warships
                if (this.warships && this.warships.length > 0) {
                    this.warships.forEach(ship => {
                        if (ship.alive && ship.healthBar && ship.health < ship.maxHealth) {
                            this.updateHealthBar(ship, this.camera);
                        } else if (ship.healthBar) {
                            // Hide health bar if ship is at full health
                            ship.healthBar.container.style.display = 'none';
                        }
                    });
                }
            }

            createScorchMark(x,z){
                const r = 18 + Math.random()*6;
                const geo = new THREE.CircleGeometry(r, 20);
                const mat = new THREE.MeshBasicMaterial({ color: 0x1d1b1a, transparent:true, opacity:0.55, side:THREE.DoubleSide });
                const m = new THREE.Mesh(geo, mat);
                m.rotation.x = -Math.PI/2;
                m.position.set(x, -49.8, z);
                this.scene.add(m);
                // Ê∏êÈöê
                const start = performance.now();
                const fade = () => {
                    const t = (performance.now()-start)/8000;
                    if (t<1) {
                        mat.opacity = 0.55*(1-t);
                        requestAnimationFrame(fade);
                    } else {
                        this.scene.remove(m); geo.dispose(); mat.dispose();
                    }
                };
                requestAnimationFrame(fade);
            }

            // ================= Simple One-time Tank Destruction System =================
            createTankDestroyed(position, tankMesh) {
                try {
                    // ÂÆâÂÖ®Ê£ÄÊü•
                    if (!position || !tankMesh) {
                        console.warn('Invalid tank destruction parameters');
                        return;
                    }
                    
                    // Á´ãÂç≥ÂÅúÊ≠¢Âù¶ÂÖãÁßªÂä® - Êó†ÈúÄÂ§çÊùÇÊ£ÄÊü•
                    // updateTanks‰∏≠ÁöÑaliveÊ£ÄÊü•‰ºöËá™Âä®Â§ÑÁêÜ
                    
                    // ËΩ¨Êç¢Â§ñËßÇ
                    this.convertTankToWreck(tankMesh);
                    
                    // ÂàõÂª∫ÁÆÄÂçïÁÉüÈõæ
                    this.createExplosionSmoke(position);
                    
                } catch (e) {
                    console.error('Tank destruction error:', e);
                }
            }

            convertTankToWreck(tankMesh) {
                try {
                    // ÂÆâÂÖ®ÁöÑÊùêË¥®ËΩ¨Êç¢
                    tankMesh.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // ÁÆÄÂçïÁöÑÊùêË¥®ÊõøÊç¢ÔºåÈÅøÂÖçÂ§çÊùÇÊìç‰Ωú
                            const newMat = new THREE.MeshStandardMaterial({
                                color: 0x2a2422, // Ê∑±Ëâ≤ÁÉßÊØÅÂ§ñËßÇ
                                metalness: 0.1,
                                roughness: 0.9
                            });
                            
                            child.material = newMat;
                        }
                        
                        // ÂÆâÂÖ®ÁöÑÁÇÆÁÆ°‰∏ãÂûÇÊ£ÄÊü•
                        if (child.name === 'gunPivot') {
                            child.rotation.x = -Math.PI / 6; // ‰∏ãÂûÇ30Â∫¶
                        }
                    });
                    
                    // ËΩªÂæÆÂÄæÊñúÊïàÊûú
                    tankMesh.rotation.z += (Math.random() - 0.5) * 0.1;
                    tankMesh.rotation.x += (Math.random() - 0.5) * 0.08;
                    
                } catch (e) {
                    console.warn('Tank wreck conversion error:', e);
                }
            }

            createExplosionSmoke(position) {
                // ÊûÅÁÆÄÁâà‰∏ÄÊ¨°ÊÄßÁÉüÈõæÊïàÊûúÔºåÁªù‰∏çÂç°Ê≠ª
                const smokeGroup = new THREE.Group();
                
                // Âè™ÂàõÂª∫2‰∏™ÁÆÄÂçïÁöÑÁÉüÈõæÁêÉ‰ΩìÔºåÈôç‰ΩéÂ§çÊùÇÂ∫¶
                for (let i = 0; i < 2; i++) {
                    const smokeGeo = new THREE.SphereGeometry(1.2, 4, 3); // ÊûÅ‰ΩéÈù¢Êï∞
                    const smokeMat = new THREE.MeshBasicMaterial({
                        color: 0x333333,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                    smoke.position.set(
                        position.x + (Math.random() - 0.5) * 3,
                        position.y + 1 + i,
                        position.z + (Math.random() - 0.5) * 3
                    );
                    smoke.scale.setScalar(0.4);
                    
                    smokeGroup.add(smoke);
                }
                
                this.scene.add(smokeGroup);
                
                // ÊúÄÁÆÄÂçïÁöÑÊ∂àÂ§±ÈÄªËæë - 2ÁßíÂêéÁõ¥Êé•Âà†Èô§ÔºåÊ≤°ÊúâÂä®ÁîªÂæ™ÁéØ
                setTimeout(() => {
                    try {
                        this.scene.remove(smokeGroup);
                        // ÂÆâÂÖ®Ê∏ÖÁêÜ
                        smokeGroup.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                        smokeGroup.clear();
                    } catch (e) {
                        console.warn('Smoke cleanup error:', e);
                    }
                }, 2000);
            }

            // ÔºàÂÖ¨Ë∑ØÁ≥ªÁªüÂ∑≤ÁßªÈô§Ôºâ

            createBuildings() {
                // ÂàõÂª∫ÂüéÈïáÂå∫Âüü
                this.createTownArea(-800, -800, 600, 600); // ‰∏ªÂüéÂå∫
                this.createTownArea(1200, 800, 400, 400);  // Â∞èÈïá1
                this.createTownArea(-1500, 1000, 300, 300); // Â∞èÈïá2
                
                // ÂàõÂª∫‰∏Ä‰∫õÁã¨Á´ãÂª∫Á≠ë
                for (let i = 0; i < 50; i++) {
                    const x = (Math.random() - 0.5) * 6000;
                    const z = (Math.random() - 0.5) * 6000;
                    this.createRandomBuilding(x, z);
                }
            }

            createTownArea(centerX, centerZ, width, depth) {
                const buildingsPerRow = 6;
                const spacing = Math.min(width, depth) / buildingsPerRow;
                
                for (let i = 0; i < buildingsPerRow; i++) {
                    for (let j = 0; j < buildingsPerRow; j++) {
                        const x = centerX + (i - buildingsPerRow/2) * spacing + (Math.random() - 0.5) * 20;
                        const z = centerZ + (j - buildingsPerRow/2) * spacing + (Math.random() - 0.5) * 20;
                        this.createRandomBuilding(x, z, true); // ÂüéÈïáÂª∫Á≠ëÊõ¥Â§ß
                    }
                }
            }

            createRandomBuilding(x, z, isTown = false) {
                const buildingGroup = new THREE.Group();
                
                // Âª∫Á≠ëÂ∞∫ÂØ∏
                const width = isTown ? 20 + Math.random() * 30 : 10 + Math.random() * 15;
                const depth = isTown ? 20 + Math.random() * 30 : 10 + Math.random() * 15;
                const height = isTown ? 30 + Math.random() * 80 : 15 + Math.random() * 25;
                
                // ‰∏ªÂª∫Á≠ë
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingColors = [0x8B7355, 0xA0522D, 0x696969, 0x778899, 0xDC143C]; // ÂêÑÁßçÂª∫Á≠ëÈ¢úËâ≤
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)]
                });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.y = height / 2 - 50;
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);
                
                // Â±ãÈ°∂
                const roofGeometry = new THREE.ConeGeometry(
                    Math.max(width, depth) * 0.7, 
                    height * 0.3, 
                    4
                );
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B0000 // Á∫¢Ëâ≤Â±ãÈ°∂
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = height - 50 + height * 0.15;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                buildingGroup.add(roof);
                
                // ÈöèÊú∫Ê∑ªÂä†Á™óÊà∑ÔºàÁÆÄÂçïÁöÑÈªÑËâ≤ÊñπÂùóÔºâ
                if (isTown) {
                    for (let i = 0; i < 8; i++) {
                        const windowGeometry = new THREE.PlaneGeometry(3, 4);
                        const windowMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00, // ÈªÑËâ≤Á™óÊà∑ÔºàÁÅØÂÖâÔºâ
                            transparent: true,
                            opacity: 0.8
                        });
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            (Math.random() - 0.5) * width * 0.8,
                            (Math.random() - 0.3) * height - 50,
                            width / 2 + 0.1
                        );
                        buildingGroup.add(window);
                    }
                }
                
                buildingGroup.position.set(x, 0, z);
                this.scene.add(buildingGroup);
            }

            showAnimationControls() {
                if (!this.modelAnimations || this.modelAnimations.length === 0) return;
                
                // ÂàõÂª∫Âä®ÁîªÊéßÂà∂Èù¢Êùø
                const controlPanel = document.createElement('div');
                controlPanel.id = 'animationControls';
                controlPanel.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 15px;
                    border-radius: 10px;
                    font-family: monospace;
                    z-index: 1000;
                    max-width: 250px;
                `;
                
                controlPanel.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #00ff00;">‚úàÔ∏è Animation Controls</h4>
                    <div id="animationList"></div>
                    <button id="playAllAnimations" style="margin-top: 10px; width: 100%;">‚ñ∂Ô∏è Play All</button>
                    <button id="stopAllAnimations" style="margin-top: 5px; width: 100%;">‚èπÔ∏è Stop All</button>
                `;
                
                const animationList = controlPanel.querySelector('#animationList');
                
                // ‰∏∫ÊØè‰∏™Âä®ÁîªÂàõÂª∫ÊéßÂà∂ÊåâÈíÆ
                this.modelAnimations.forEach((clip, index) => {
                    const animDiv = document.createElement('div');
                    animDiv.style.cssText = 'margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                    
                    animDiv.innerHTML = `
                        <div style="font-size: 12px; color: #00ffff;">${clip.name || `Animation ${index + 1}`}</div>
                        <div style="font-size: 10px; color: #888;">Duration: ${clip.duration.toFixed(1)}s</div>
                        <button class="playAnim" data-index="${index}" style="font-size: 10px; margin-top: 3px;">‚ñ∂Ô∏è Play</button>
                        <button class="pauseAnim" data-index="${index}" style="font-size: 10px; margin-left: 5px;">‚è∏Ô∏è Pause</button>
                    `;
                    
                    animationList.appendChild(animDiv);
                });
                
                // Ê∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
                controlPanel.querySelector('#playAllAnimations').addEventListener('click', () => {
                    this.activeAnimations.forEach(action => action.play());
                });
                
                controlPanel.querySelector('#stopAllAnimations').addEventListener('click', () => {
                    this.activeAnimations.forEach(action => action.stop());
                });
                
                // Âçï‰∏™Âä®ÁîªÊéßÂà∂
                controlPanel.querySelectorAll('.playAnim').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (this.activeAnimations[index]) {
                            this.activeAnimations[index].play();
                        }
                    });
                });
                
                controlPanel.querySelectorAll('.pauseAnim').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (this.activeAnimations[index]) {
                            this.activeAnimations[index].paused = !this.activeAnimations[index].paused;
                        }
                    });
                });
                
                document.body.appendChild(controlPanel);
                
                // 3ÁßíÂêéËá™Âä®Ê∑°ÂåñÊéßÂà∂Èù¢Êùø
                setTimeout(() => {
                    if (controlPanel.parentNode) {
                        controlPanel.style.opacity = '0.3';
                    }
                }, 3000);
            }

            setupFileUpload() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('glbUpload');
                
                // File input change
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        this.loadGLBModel(file);
                    }
                });
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#4CAF50';
                    uploadArea.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                });
                
                uploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '';
                    uploadArea.style.backgroundColor = '';
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '';
                    uploadArea.style.backgroundColor = '';
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        if (file.name.toLowerCase().endsWith('.glb') || file.name.toLowerCase().endsWith('.gltf')) {
                            this.loadGLBModel(file);
                        } else {
                            this.showNotification('Please drop a GLB or GLTF file', 'error');
                        }
                    }
                });
            }

            loadGLBModel(file) {
                this.showNotification('Loading aircraft model...', 'success');
                
                const loader = new GLTFLoader();
                const url = URL.createObjectURL(file);
                
                loader.load(url, (gltf) => {
                    // Remove existing aircraft if loaded model exists
                    if (this.loadedModel) {
                        this.scene.remove(this.loadedModel);
                        // Ê∏ÖÁêÜÊóßÁöÑÂä®ÁîªÊ∑∑ÂêàÂô®
                        if (this.modelAnimationMixer) {
                            this.modelAnimationMixer.stopAllAction();
                            this.modelAnimationMixer = null;
                        }
                    } else if (this.aircraft) {
                        this.scene.remove(this.aircraft);
                    }
                    
                    const model = gltf.scene;
                    
                    // === Âä®ÁîªÁ≥ªÁªüËÆæÁΩÆ ===
                    this.modelAnimations = gltf.animations; // Â≠òÂÇ®Âä®ÁîªÊï∞ÊçÆ
                    this.modelAnimationMixer = null;
                    this.activeAnimations = []; // Â≠òÂÇ®ÂΩìÂâçÊí≠ÊîæÁöÑÂä®Áîª
                    
                    // Â¶ÇÊûúÊ®°ÂûãÂåÖÂê´Âä®ÁîªÔºåÂàõÂª∫Âä®ÁîªÊ∑∑ÂêàÂô®
                    if (gltf.animations && gltf.animations.length > 0) {
                        this.modelAnimationMixer = new THREE.AnimationMixer(model);
                        
                        console.log(`Found ${gltf.animations.length} animations:`, gltf.animations.map(anim => anim.name));
                        
                        // Ëá™Âä®Êí≠ÊîæÊâÄÊúâÂä®ÁîªÔºàÈÄöÂ∏∏Áî®‰∫éËû∫ÊóãÊ°®„ÄÅÂºïÊìéÁ≠âÂæ™ÁéØÂä®ÁîªÔºâ
                        gltf.animations.forEach((clip, index) => {
                            const action = this.modelAnimationMixer.clipAction(clip);
                            action.setLoop(THREE.LoopRepeat);
                            action.clampWhenFinished = false;
                            
                            // Ëá™Âä®ËØÜÂà´Âä®ÁîªÁ±ªÂûã
                            const animName = clip.name.toLowerCase();
                            if (animName.includes('propeller') || 
                                animName.includes('rotor') || 
                                animName.includes('engine') ||
                                animName.includes('fan') ||
                                animName.includes('spin')) {
                                // Âø´ÈÄüÂæ™ÁéØÂä®ÁîªÔºàËû∫ÊóãÊ°®Á≠âÔºâ
                                action.timeScale = 2.0; // 2ÂÄçÈÄüÂ∫¶
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing fast animation: ${clip.name}`);
                            } else if (animName.includes('idle') || 
                                      animName.includes('loop') ||
                                      clip.duration > 10) {
                                // ÊÖ¢ÈÄüÂæ™ÁéØÂä®Áîª
                                action.timeScale = 1.0;
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing slow animation: ${clip.name}`);
                            } else {
                                // ÂÖ∂‰ªñÂä®ÁîªÈªòËÆ§‰πüÊí≠Êîæ
                                action.timeScale = 1.0;
                                action.play();
                                this.activeAnimations.push(action);
                                console.log(`Auto-playing animation: ${clip.name}`);
                            }
                        });
                        
                        this.showNotification(`Aircraft loaded with ${gltf.animations.length} animations!`, 'success');
                    } else {
                        this.showNotification('Aircraft loaded (no animations found)', 'success');
                    }
                    
                    // Calculate model bounding box to determine appropriate scale
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    
                    // Target size should be similar to default aircraft (wingspan ~18, length ~14)
                    const targetSize = 18; // Target wingspan/length
                    const currentMaxSize = Math.max(size.x, size.y, size.z);
                    const scaleRatio = targetSize / currentMaxSize;
                    
                    // Apply calculated scale (minimum 15x for very small models) and additional 1.5x multiplier
                    const finalScale = Math.max(scaleRatio, 15) * 1.5;
                    model.scale.set(finalScale, finalScale, finalScale);
                    
                    // Enhance materials for better lighting
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        this.enhanceMaterial(mat);
                                    });
                                } else {
                                    this.enhanceMaterial(child.material);
                                }
                            }
                        }
                    });
                    
                    model.position.copy(this.playerPosition);
                    this.loadedModel = model;
                    this.aircraft = model;
                    this.scene.add(model);
                    
                    // Recreate nose cannons with transparency for custom model
                    this.createNoseCannons();
                    
                    // ÊòæÁ§∫Âä®ÁîªÊéßÂà∂Èù¢ÊùøÔºàÂ¶ÇÊûúÊúâÂä®ÁîªÔºâ
                    if (gltf.animations && gltf.animations.length > 0) {
                        // ÁßªÈô§ÊóßÁöÑÊéßÂà∂Èù¢Êùø
                        const oldPanel = document.getElementById('animationControls');
                        if (oldPanel) oldPanel.remove();
                        
                        // ÊòæÁ§∫Êñ∞ÁöÑÂä®ÁîªÊéßÂà∂Èù¢Êùø
                        setTimeout(() => this.showAnimationControls(), 500);
                    }
                    
                    URL.revokeObjectURL(url);
                    
                }, undefined, (error) => {
                    console.error('Error loading GLB model:', error);
                    this.showNotification('Failed to load aircraft model', 'error');
                    URL.revokeObjectURL(url);
                });
            }

            enhanceMaterial(material) {
                // === ËΩªÂæÆÂ¢û‰∫ÆËøáÊöóÊùêË¥® ===
                if (material.color && material.color.r + material.color.g + material.color.b < 0.3) {
                    material.color.multiplyScalar(1.5); // Èôç‰ΩéÂà∞1.5ÂÄçÔºåÈÅøÂÖçËøáÊõù
                }
                
                // === ÈÄÇÂ∫¶‰ºòÂåñPBRÊùêË¥®Â±ûÊÄß ===
                if (material.metalness !== undefined) {
                    material.metalness = Math.min(material.metalness + 0.2, 0.6); // ÈÄÇÂ∫¶Â¢ûÂä†ÈáëÂ±ûÂ∫¶
                }
                if (material.roughness !== undefined) {
                    material.roughness = Math.max(material.roughness - 0.1, 0.4); // ÈÄÇÂ∫¶Èôç‰ΩéÁ≤óÁ≥ôÂ∫¶
                }
                
                // === ÁßªÈô§Ëá™ÂèëÂÖâÊïàÊûú ===
                // ‰∏çÊ∑ªÂä†Ëá™ÂèëÂÖâÔºå‰ΩøÁî®Ëá™ÁÑ∂ÂÖâÁÖß
                
                // === ÈÄÇÂ∫¶ÁéØÂ¢ÉÂÖâÂìçÂ∫î ===
                if (material.envMapIntensity !== undefined) {
                    material.envMapIntensity = 1.0; // Èôç‰ΩéÂà∞1.0ÔºåËá™ÁÑ∂ÂèçÂ∞Ñ
                }
                
                // === Á°Æ‰øùÊùêË¥®ÂìçÂ∫îÂÖâÁÖß ===
                material.needsUpdate = true;
                
                // === ÈÄÇÂ∫¶ÊèêÂçáÊûÅÊöóÊùêË¥® ===
                if (material.color && material.color.getHSL({}).l < 0.15) {
                    // ‰ªÖÂØπÊûÅÊöóÊùêË¥®ËøõË°åËΩªÂæÆË∞ÉÊï¥
                    const hsl = material.color.getHSL({});
                    material.color.setHSL(hsl.h, hsl.s, Math.max(hsl.l, 0.2)); // ÊúÄ‰Ωé20%‰∫ÆÂ∫¶
                }
            }

            setupKeyboardControls() {
                document.addEventListener('keydown', (event) => {
                    this.inputState.keys.add(event.code);
                    
                    // Camera view switching with C key
                    if (event.code === 'KeyC') {
                        this.switchCameraView();
                    }
                });
                
                document.addEventListener('keyup', (event) => {
                    this.inputState.keys.delete(event.code);
                });
            }
            
            switchCameraView() {
                this.currentViewIndex = (this.currentViewIndex + 1) % this.viewModes.length;
                const currentView = this.viewModes[this.currentViewIndex];
                
                // Show view change notification
                this.showViewChangeNotification(currentView.name);
            }
            
            showViewChangeNotification(viewName) {
                // Remove existing notification
                const existingNotification = document.getElementById('viewChangeNotification');
                if (existingNotification) {
                    existingNotification.remove();
                }
                
                // Create new notification
                const notification = document.createElement('div');
                notification.id = 'viewChangeNotification';
                notification.style.cssText = `
                    position: fixed; top: 120px; right: 20px; z-index: 1500;
                    background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(6px);
                    color: white; padding: 8px 16px; border-radius: 6px;
                    font-family: 'Segoe UI', sans-serif; font-size: 14px; font-weight: 600;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    animation: slideInFade 0.3s ease-out;
                `;
                notification.textContent = `üì∑ ${viewName}`;
                document.body.appendChild(notification);
                
                // Auto remove after 2 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 2000);
            }

            updateInputFromKeyboard(deltaTime) {
                const keys = this.inputState.keys;
                const turnSpeed = 1.5; // radians per second
                const pitchSpeed = 1.0; // radians per second  
                const speedChangeRate = 0.8; // speed change per second

                // Yaw controls (left/right turns)
                if (keys.has('KeyA') || keys.has('ArrowLeft')) {
                    this.inputState.yaw += turnSpeed * deltaTime;
                }
                if (keys.has('KeyD') || keys.has('ArrowRight')) {
                    this.inputState.yaw -= turnSpeed * deltaTime;
                }

                // Pitch controls (nose up/down)
                if (keys.has('KeyW') || keys.has('ArrowUp')) {
                    this.inputState.pitch = Math.min(this.inputState.pitch + pitchSpeed * deltaTime, Math.PI / 4);
                }
                if (keys.has('KeyS') || keys.has('ArrowDown')) {
                    this.inputState.pitch = Math.max(this.inputState.pitch - pitchSpeed * deltaTime, -Math.PI / 4);
                }

                // Roll controls (banking) - ÂÖÅËÆ∏360Â∫¶ÁøªËΩ¨
                if (keys.has('KeyQ')) {
                    this.inputState.roll -= turnSpeed * deltaTime; // ÁßªÈô§ÈôêÂà∂ÔºåÂÖÅËÆ∏Êó†ÈôêÁøªËΩ¨
                } else if (keys.has('KeyE')) {
                    this.inputState.roll += turnSpeed * deltaTime; // ÁßªÈô§ÈôêÂà∂ÔºåÂÖÅËÆ∏Êó†ÈôêÁøªËΩ¨
                } else {
                    // Auto-level roll - ‰ªÖÂú®Êé•ËøëÊ∞¥Âπ≥Êó∂Ëá™Âä®Ë∞ÉÂπ≥
                    const levelingSpeed = 2.0;
                    // ËÆ°ÁÆóÂà∞ÊúÄËøëÁöÑÊ∞¥Âπ≥‰ΩçÁΩÆÁöÑË∑ùÁ¶ª
                    const normalizedRoll = ((this.inputState.roll % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                    let targetRoll = 0;
                    if (normalizedRoll > Math.PI) {
                        targetRoll = Math.PI * 2;
                    }
                    const rollDiff = Math.abs(normalizedRoll - targetRoll);
                    
                    // Âè™ÊúâÂú®Êé•ËøëÊ∞¥Âπ≥‰ΩçÁΩÆÊó∂ÊâçËá™Âä®Ë∞ÉÂπ≥
                    if (rollDiff < Math.PI / 6) { // 30Â∫¶ËåÉÂõ¥ÂÜÖ
                        if (Math.abs(this.inputState.roll) > 0.01) {
                            this.inputState.roll = THREE.MathUtils.lerp(this.inputState.roll, Math.round(this.inputState.roll / (Math.PI * 2)) * Math.PI * 2, deltaTime * levelingSpeed);
                        } else {
                            this.inputState.roll = Math.round(this.inputState.roll / (Math.PI * 2)) * Math.PI * 2;
                        }
                    }
                }

                // Speed controls
                if (keys.has('ShiftLeft') || keys.has('ShiftRight') || keys.has('Space')) {
                    this.inputState.speed = Math.min(this.inputState.speed + speedChangeRate * deltaTime, 1.0);
                }
                if (keys.has('ControlLeft') || keys.has('ControlRight') || keys.has('KeyX')) {
                    this.inputState.speed = Math.max(this.inputState.speed - speedChangeRate * deltaTime, 0.2);
                }

                // Auto-level pitch when no input
                if (!keys.has('KeyW') && !keys.has('KeyS') && 
                    !keys.has('ArrowUp') && !keys.has('ArrowDown')) {
                    const levelingSpeed = 2.0;
                    if (Math.abs(this.inputState.pitch) > 0.01) {
                        this.inputState.pitch = THREE.MathUtils.lerp(this.inputState.pitch, 0, deltaTime * levelingSpeed);
                    } else {
                        this.inputState.pitch = 0;
                    }
                }

                // Weather toggle
                if (keys.has('KeyR')) {
                    if (!this.rKeyPressed) {
                        this.toggleWeather();
                        this.rKeyPressed = true;
                    }
                } else {
                    this.rKeyPressed = false;
                }
            }

            updatePlayer(deltaTime) {
                if (!this.aircraft) return;

                // Update input from keyboard
                this.updateInputFromKeyboard(deltaTime);

                // Update speed based on input
                const maxSpeed = 120; // Maximum speed
                const targetSpeed = Math.max(this.inputState.speed * maxSpeed, 30); // Minimum 30 for flight
                this.playerSpeed = THREE.MathUtils.lerp(this.playerSpeed, targetSpeed, deltaTime * 2);

                // Calculate forward direction based on pitch and yaw
                const forward = new THREE.Vector3(0, 0, 1); // +Z is forward for our aircraft
                const rotation = new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll);
                forward.applyEuler(rotation);

                // Apply constant thrust in forward direction (this ensures the plane always moves forward)
                const thrust = forward.clone().multiplyScalar(this.playerSpeed);
                this.playerVelocity.copy(thrust); // Set velocity directly to thrust direction and speed

                // Apply lift when flying forward (simple aerodynamics)
                if (this.playerSpeed > 40) {
                    const liftStrength = Math.min(this.playerSpeed / 80, 1.0);
                    const liftDirection = new THREE.Vector3(0, 1, 0); // Upward
                    const lift = liftDirection.multiplyScalar(liftStrength * 25 * deltaTime);
                    this.playerVelocity.add(lift);
                }

                // Apply gravity
                const gravity = new THREE.Vector3(0, -30, 0);
                this.playerVelocity.add(gravity.multiplyScalar(deltaTime));

                // Light air resistance (much reduced)
                this.playerVelocity.multiplyScalar(1 - 0.1 * deltaTime);

                // Update position
                this.playerPosition.add(this.playerVelocity.clone().multiplyScalar(deltaTime));

                // === INFINITE LOOPING WORLD SYSTEM ===
                const worldBoundary = 4000; // 8000x8000Âú∞ÂΩ¢ÁöÑËæπÁïåÔºà‰ªé‰∏≠ÂøÉÂà∞ËæπÁºò4000Âçï‰ΩçÔºâ
                let worldWrapped = false;
                
                // XËΩ¥ËæπÁïåÊ£ÄÊü•
                if (this.playerPosition.x > worldBoundary) {
                    this.playerPosition.x = -worldBoundary + 1;
                    worldWrapped = true;
                } else if (this.playerPosition.x < -worldBoundary) {
                    this.playerPosition.x = worldBoundary - 1;
                    worldWrapped = true;
                }
                
                // ZËΩ¥ËæπÁïåÊ£ÄÊü•
                if (this.playerPosition.z > worldBoundary) {
                    this.playerPosition.z = -worldBoundary + 1;
                    worldWrapped = true;
                } else if (this.playerPosition.z < -worldBoundary) {
                    this.playerPosition.z = worldBoundary - 1;
                    worldWrapped = true;
                }
                
                // ÊòæÁ§∫Âæ™ÁéØ‰∏ñÁïåÊèêÁ§∫Ê∂àÊÅØ
                if (worldWrapped) {
                    this.showWrapMessage();
                }

                // Keep aircraft above ground
                if (this.playerPosition.y < 10) {
                    this.playerPosition.y = 10;
                    this.playerVelocity.y = Math.max(this.playerVelocity.y, 0);
                    this.playerVelocity.multiplyScalar(0.7); // Bounce damping
                }

                // Update aircraft position and rotation
                this.aircraft.position.copy(this.playerPosition);
                
                // Set aircraft rotation based on flight controls
                this.aircraft.rotation.set(
                    this.inputState.pitch,
                    this.inputState.yaw, 
                    this.inputState.roll
                );

                // === ÁßªÈô§Âä®ÊÄÅÂÖâÁÖßË∑üË∏™Ôºå‰ΩøÁî®Ëá™ÁÑ∂ÂÖâÁÖß ===
                // ‰∏çÂÜçÈúÄË¶Å‰∏ìÁî®ÂÖâÊ∫êË∑üÈöèÈ£ûÊú∫

                // Update propeller animation
                this.updatePropeller(deltaTime);
                // bird flocks removed
            }

            updateCamera() {
                if (!this.aircraft) return;
                
                // Get current view mode
                const currentView = this.viewModes[this.currentViewIndex];
                
                // Calculate aircraft rotation matrix
                const aircraftRotation = new THREE.Euler(this.inputState.pitch, this.inputState.yaw, this.inputState.roll);
                const rotationMatrix = new THREE.Matrix4().makeRotationFromEuler(aircraftRotation);
                
                // Apply aircraft rotation to the camera offset (for chase view)
                let cameraOffset;
                if (this.currentViewIndex === 0) {
                    // Chase view - camera follows aircraft orientation
                    cameraOffset = currentView.offset.clone().applyMatrix4(rotationMatrix);
                } else {
                    // Fixed side/top views - don't rotate with aircraft
                    cameraOffset = currentView.offset.clone();
                }
                
                // Calculate target camera position
                const targetPosition = this.playerPosition.clone().add(cameraOffset);
                
                // Smooth camera movement
                this.camera.position.lerp(targetPosition, 0.1);
                
                // Camera look target
                let lookTarget;
                if (this.currentViewIndex === 3) {
                    // Tactical view - look slightly ahead of aircraft
                    const forward = new THREE.Vector3(0, 0, 1).applyMatrix4(rotationMatrix);
                    lookTarget = this.playerPosition.clone().add(forward.multiplyScalar(30));
                } else {
                    // All other views look at aircraft center
                    lookTarget = this.playerPosition.clone();
                }
                
                this.camera.lookAt(lookTarget);
            }

            updateClouds(deltaTime) {
                // Slowly move clouds
                this.clouds.forEach(cloud => {
                    cloud.position.x += Math.sin(Date.now() * 0.0001) * 0.1;
                    cloud.rotation.y += deltaTime * 0.1;
                });
            }

            hideLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                const progressFill = document.getElementById('progressFill');
                
                // Simulate loading progress
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 20;
                    if (progress >= 100) {
                        progress = 100;
                        progressFill.style.width = '100%';
                        
                        setTimeout(() => {
                            loadingScreen.style.opacity = '0';
                            loadingScreen.style.transition = 'opacity 1s ease';
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                            }, 1000);
                        }, 500);
                        
                        clearInterval(progressInterval);
                    }
                    progressFill.style.width = progress + '%';
                }, 100);
            }

            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification-${type}`;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }

            // === Scene Switcher UI (dynamic English) ===
            setupSceneSwitcher(){
                // Remove any legacy static panel (Chinese) if still present
                const existing = document.getElementById('sceneSwitcher');
                if (existing && !existing.__dynamic) existing.remove();
                if (document.getElementById('sceneSwitcher')) return; // already created
                const panel = document.createElement('div');
                panel.id = 'sceneSwitcher';
                panel.__dynamic = true;
                const scenes = [
                    { key:'grassland', label:'Grassland' },
                    { key:'snow', label:'Snow' },
                    { key:'desert', label:'Desert' },
                    { key:'ocean', label:'Ocean' }
                ];
                scenes.forEach(s => {
                    const btn = document.createElement('button');
                    btn.textContent = s.label;
                    btn.dataset.scene = s.key;
                    if (this.sceneType === s.key || (this.sceneType === 'default' && s.key==='grassland')) btn.classList.add('active');
                    btn.addEventListener('click', ()=>{
                        if (this.sceneType === s.key) return;
                        this.switchSceneType(s.key);
                    });
                    panel.appendChild(btn);
                });
                document.body.appendChild(panel);
                if (!window.__SCENE_SWITCHER_VERSION_LOGGED) {
                    window.__SCENE_SWITCHER_VERSION_LOGGED = true;
                    console.log('[SceneSwitcher] v1 loaded', new Date().toISOString());
                }
            }

            updateSceneSwitcherActive(){
                const panel = document.getElementById('sceneSwitcher');
                if (!panel) return;
                panel.querySelectorAll('button').forEach(btn => {
                    if (btn.dataset.scene === this.sceneType) btn.classList.add('active');
                    else btn.classList.remove('active');
                });
            }

            // Dynamic scene switching (no full page reload)
            switchSceneType(newType){
                if (newType === 'default') newType = 'grassland'; // normalize
                const valid = ['grassland','snow','desert','ocean'];
                if (!valid.includes(newType)) return;
                if (this.sceneType === newType) return;
                const prevScene = this.scene;
                const aircraft = this.aircraft;
                const playerPos = this.playerPosition.clone();
                const playerVel = this.playerVelocity.clone();
                this.sceneType = newType;
                // Update URL hash (omit hash for grassland for cleanliness)
                if (newType === 'grassland') history.replaceState(null,'', window.location.pathname + window.location.search);
                else history.replaceState(null,'', '#'+newType);
                this.disposeOldScene(prevScene, aircraft);
                const fogColors = { grassland:0x87CEEB, snow:0xdbe9f5, desert:0xe2c27b, ocean:0x6fb2ff };
                this.scene = new THREE.Scene();
                const fogColor = fogColors[this.sceneType] || fogColors.grassland;
                this.scene.fog = new THREE.Fog(fogColor, 100, 2000);
                this.renderer.setClearColor(fogColor,1);
                if (aircraft) {
                    this.aircraft = aircraft;
                    this.aircraft.position.copy(playerPos);
                    this.scene.add(this.aircraft);
                }
                this.tanks = []; this.bullets = []; this.muzzleFlashes = []; this.warships = [];
                this.gunBarrels = [];
                this.setupLighting();
                this.environmentConfig = this.getEnvironmentConfig(this.sceneType);
                this.createTerrain();
                if (this.sceneType !== 'ocean') this.createClouds();
                this.createNoseCannons();
                if (this.isFiring) this.lastShotTime = 0;
                this.playerPosition.copy(playerPos);
                this.playerVelocity.copy(playerVel);
                this.updateSceneSwitcherActive();
                this.showNotification('Switched to scene: '+ this.sceneType.charAt(0).toUpperCase()+this.sceneType.slice(1), 'success');
            }

            disposeOldScene(oldScene, aircraftKeep){
                if (!oldScene) return;
                oldScene.traverse(obj=>{
                    if (aircraftKeep && (obj===aircraftKeep || aircraftKeep.children.includes(obj))) return;
                    if (obj.isMesh) {
                        if (obj.geometry) obj.geometry.dispose();
                        if (Array.isArray(obj.material)) obj.material.forEach(m=>m && m.dispose && m.dispose());
                        else if (obj.material) obj.material.dispose();
                    }
                });
            }

            gameLoop() {
                const deltaTime = 0.016; // Approximately 60 FPS
                
                this.updatePlayer(deltaTime);
                this.updateCamera();
                this.updateClouds(deltaTime);
                this.updatePropeller(deltaTime);
                // Tank movement and turret rotation
                this.updateTanks(deltaTime);
                // Warship AI and shooting
                this.updateWarships(deltaTime);
                // Weapon updates
                this.tryFireGuns(deltaTime);
                this.updateBullets(deltaTime);
                this.updateEnemyBullets(deltaTime);
                this.updateTankIndicators(deltaTime);
                
                // Update health bars for tanks and warships (throttled for performance)
                this.healthBarUpdateCounter = (this.healthBarUpdateCounter || 0) + 1;
                if (this.healthBarUpdateCounter % 3 === 0) {
                    this.updateHealthBars();
                }
                
                // Update player health display (throttled)
                if (this.healthBarUpdateCounter % 10 === 0) {
                    this.updatePlayerHealthDisplay();
                }
                
                // === Êõ¥Êñ∞GLBÊ®°ÂûãÂä®Áîª ===
                if (this.modelAnimationMixer) {
                    const animationDelta = this.animationClock.getDelta();
                    this.modelAnimationMixer.update(animationDelta);
                }
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.gameLoop());
            }

            updatePropeller(deltaTime) {
                // Animate propeller spinning
                if (this.propeller) {
                    this.propeller.rotation.z += 30 * deltaTime; // Fast spinning around Z axis (forward motion)
                }
            }

            showWrapMessage() {
                // Èò≤Ê≠¢Ê∂àÊÅØËøá‰∫éÈ¢ëÁπÅÊòæÁ§∫
                const currentTime = Date.now();
                if (currentTime - this.lastWrapMessageTime < 3000) return; // 3ÁßíÈó¥Èöî
                
                this.lastWrapMessageTime = currentTime;
                
                // ÂàõÂª∫ÊèêÁ§∫Ê∂àÊÅØ
                const messages = [
                    "üåç Entering a new sector...",
                    "‚úàÔ∏è Flying to the far side of the world",
                    "üó∫Ô∏è Warping at world boundary...",
                    "üåå Looping world enables endless exploration"
                ];
                
                const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                
                // ÊòæÁ§∫‰∏¥Êó∂Ê∂àÊÅØ
                const messageElement = document.createElement('div');
                messageElement.textContent = randomMessage;
                messageElement.style.cssText = `
                    position: fixed;
                    top: 20%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #00ff00;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-size: 18px;
                    font-family: 'Courier New', monospace;
                    z-index: 1000;
                    pointer-events: none;
                    animation: fadeInOut 3s ease-in-out;
                `;
                
                // Ê∑ªÂä†CSSÂä®Áîª
                if (!document.querySelector('#wrapMessageStyle')) {
                    const style = document.createElement('style');
                    style.id = 'wrapMessageStyle';
                    style.textContent = `
                        @keyframes fadeInOut {
                            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                            20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(messageElement);
                
                // 3ÁßíÂêéÁßªÈô§Ê∂àÊÅØ
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.parentNode.removeChild(messageElement);
                    }
                }, 3000);
            }
        }

        // Start the game
        const game = new SkyWarriors();
    </script>
</body>
</html>
