<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Warriors - 3D Flight Combat</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        * {
            box-sizing: border-box;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 10000;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Sky Warriors...</div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';

        // Remove loading screen
        document.getElementById('loading').remove();

        // Game Configuration
        const gameConfig = {
            planet: { radius: 2000, seaLevel: 0, maxCeiling: 3200 },
            player: { maxSpeed: 180, accel: 60, drag: 0.08, hp: 100 },
            weapons: { rate: 10, bulletSpeed: 400, damage: 20, weakspotMultiplier: 2 },
            tanks: { spawnInterval: 3, maxAlive: 20, hp: 60, aaRatio: 0.2, aggroRange: 800 },
            scoring: { kill: 100, aaBonus: 100, comboWindow: 2.0, comboBonusPerKill: 0.2, comboBonusMax: 1.0 }
        };

        // Game class
        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.clock = new THREE.Clock();
                this.currentScene = 'HOME';
                this.score = 0;
                this.kills = 0;
                
                this.setupRenderer();
                this.setupInput();
                this.createHomeScene();
                this.gameLoop();
            }

            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB, 1);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupInput() {
                this.inputState = {
                    pitch: 0, yaw: 0, speed: 0.5, shoot: false,
                    mouseX: 0, mouseY: 0
                };
                this.isPointerLocked = false;
                this.isTouchDevice = 'ontouchstart' in window;

                // Mouse events
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isTouchDevice && !this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                document.addEventListener('mousemove', (event) => {
                    if (this.isPointerLocked && this.currentScene === 'PLAY') {
                        const sensitivity = 0.002;
                        this.inputState.yaw -= event.movementX * sensitivity;
                        this.inputState.pitch -= event.movementY * sensitivity;
                        this.inputState.pitch = THREE.MathUtils.clamp(this.inputState.pitch, -Math.PI / 2, Math.PI / 2);
                    }
                });

                document.addEventListener('mousedown', (event) => {
                    if (event.button === 0) this.inputState.shoot = true;
                });

                document.addEventListener('mouseup', (event) => {
                    if (event.button === 0) this.inputState.shoot = false;
                });

                document.addEventListener('wheel', (event) => {
                    if (this.isPointerLocked && this.currentScene === 'PLAY') {
                        event.preventDefault();
                        const delta = event.deltaY > 0 ? -0.1 : 0.1;
                        this.inputState.speed = THREE.MathUtils.clamp(this.inputState.speed + delta, 0, 1);
                    }
                });

                // Touch events
                if (this.isTouchDevice) {
                    let touches = [];
                    
                    this.renderer.domElement.addEventListener('touchstart', (event) => {
                        event.preventDefault();
                        touches = Array.from(event.touches);
                        if (touches.length === 1) this.inputState.shoot = true;
                    }, { passive: false });

                    this.renderer.domElement.addEventListener('touchmove', (event) => {
                        event.preventDefault();
                        const newTouches = Array.from(event.touches);
                        
                        if (newTouches.length === 1 && touches.length === 1 && this.currentScene === 'PLAY') {
                            const sensitivity = 0.005;
                            const deltaX = newTouches[0].clientX - touches[0].clientX;
                            const deltaY = newTouches[0].clientY - touches[0].clientY;
                            
                            this.inputState.yaw -= deltaX * sensitivity;
                            this.inputState.pitch -= deltaY * sensitivity;
                            this.inputState.pitch = THREE.MathUtils.clamp(this.inputState.pitch, -Math.PI / 2, Math.PI / 2);
                        } else if (newTouches.length === 2 && touches.length === 2) {
                            const oldDistance = Math.hypot(
                                touches[1].clientX - touches[0].clientX,
                                touches[1].clientY - touches[0].clientY
                            );
                            const newDistance = Math.hypot(
                                newTouches[1].clientX - newTouches[0].clientX,
                                newTouches[1].clientY - newTouches[0].clientY
                            );
                            
                            const delta = (newDistance - oldDistance) * 0.001;
                            this.inputState.speed = THREE.MathUtils.clamp(this.inputState.speed + delta, 0, 1);
                        }
                        
                        touches = newTouches;
                    }, { passive: false });

                    this.renderer.domElement.addEventListener('touchend', (event) => {
                        event.preventDefault();
                        touches = Array.from(event.touches);
                        if (touches.length === 0) this.inputState.shoot = false;
                    }, { passive: false });
                }
            }

            createHomeScene() {
                // Clear scene
                while (this.scene.children.length > 0) {
                    this.scene.remove(this.scene.children[0]);
                }

                this.scene.background = new THREE.Color(0x222222);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const pointLight = new THREE.PointLight(0xffffff, 1, 100);
                pointLight.position.set(20, 20, 20);
                this.scene.add(pointLight);

                // Create aircraft
                this.aircraft = new THREE.Group();
                
                const fuselageGeometry = new THREE.CylinderGeometry(1, 2, 12, 8);
                const fuselageMaterial = new THREE.MeshPhongMaterial({ color: 0x4a4a4a });
                const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                fuselage.rotation.z = Math.PI / 2;

                const wingGeometry = new THREE.BoxGeometry(16, 0.5, 4);
                const wingMaterial = new THREE.MeshPhongMaterial({ color: 0x4a4a4a });
                const wings = new THREE.Mesh(wingGeometry, wingMaterial);
                wings.position.z = -2;

                this.aircraft.add(fuselage);
                this.aircraft.add(wings);
                this.scene.add(this.aircraft);

                // Position camera
                this.camera.position.set(30, 10, 30);
                this.camera.lookAt(0, 0, 0);

                // Create UI
                this.createHomeUI();
            }

            createHomeUI() {
                const ui = document.createElement('div');
                ui.id = 'home-ui';
                ui.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none; z-index: 1000; font-family: Arial, sans-serif; color: white;
                `;

                const title = document.createElement('h1');
                title.textContent = 'Sky Warriors';
                title.style.cssText = `
                    position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
                    font-size: 48px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                    margin: 0; pointer-events: none;
                `;

                const startButton = document.createElement('button');
                startButton.textContent = 'START MISSION';
                startButton.style.cssText = `
                    position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
                    padding: 15px 30px; font-size: 24px; font-weight: bold;
                    background: linear-gradient(45deg, #ff6b6b, #ff8e8e); border: none; border-radius: 10px;
                    color: white; cursor: pointer; pointer-events: auto; transition: all 0.3s ease;
                    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
                `;

                startButton.addEventListener('click', () => {
                    ui.remove();
                    this.createPlayScene();
                });

                const instructions = document.createElement('div');
                instructions.innerHTML = `
                    <div style="position: absolute; bottom: 200px; left: 50%; transform: translateX(-50%); text-align: center;">
                        <p style="margin: 5px 0; font-size: 16px; opacity: 0.8;">
                            üñ±Ô∏è Mouse: Pitch & Yaw | üéØ Left Click: Shoot | üìè Scroll: Speed
                        </p>
                        <p style="margin: 5px 0; font-size: 16px; opacity: 0.8;">
                            üì± Touch: Drag to steer | üëÜ Tap to shoot | üëê Pinch for speed
                        </p>
                    </div>
                `;

                ui.appendChild(title);
                ui.appendChild(startButton);
                ui.appendChild(instructions);
                document.body.appendChild(ui);
            }

            createPlayScene() {
                this.currentScene = 'PLAY';
                
                // Clear scene
                while (this.scene.children.length > 0) {
                    this.scene.remove(this.scene.children[0]);
                }

                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 1000, 8000);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1000, 1000, 1000);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                // Create planet
                this.createPlanet();

                // Create player
                this.createPlayer();

                // Create tanks
                this.tanks = [];
                this.createTanks();

                // Create crosshair
                this.createCrosshair();

                // Create game HUD
                this.createGameHUD();

                // Weapon system
                this.raycaster = new THREE.Raycaster();
                this.lastShotTime = 0;
            }

            createPlanet() {
                const geometry = new THREE.SphereGeometry(gameConfig.planet.radius, 64, 32);
                const material = new THREE.MeshLambertMaterial({ color: 0x4a7c59 });
                this.planet = new THREE.Mesh(geometry, material);
                this.planet.receiveShadow = true;
                this.scene.add(this.planet);

                // Add some trees
                this.createTrees();
            }

            createTrees() {
                const treeCount = 1000;
                const treeGeometry = new THREE.ConeGeometry(3, 8, 8);
                const treeMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
                
                for (let i = 0; i < treeCount; i++) {
                    const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                    const position = new THREE.Vector3().randomDirection().multiplyScalar(gameConfig.planet.radius + 4);
                    tree.position.copy(position);
                    tree.lookAt(0, 0, 0);
                    tree.rotateX(Math.PI);
                    tree.castShadow = true;
                    this.scene.add(tree);
                }
            }

            createPlayer() {
                this.player = new THREE.Group();
                this.playerPosition = new THREE.Vector3(0, gameConfig.planet.radius + 100, 0);
                this.playerVelocity = new THREE.Vector3();
                this.playerHealth = gameConfig.player.hp;
                this.playerSpeed = 0;

                // Create aircraft
                const fuselageGeometry = new THREE.CylinderGeometry(1, 2, 12, 8);
                const fuselageMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
                const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                fuselage.rotation.z = Math.PI / 2;
                fuselage.castShadow = true;

                const wingGeometry = new THREE.BoxGeometry(16, 0.5, 4);
                const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
                const wings = new THREE.Mesh(wingGeometry, wingMaterial);
                wings.position.z = -2;
                wings.castShadow = true;

                this.player.add(fuselage);
                this.player.add(wings);
                this.player.position.copy(this.playerPosition);
                this.scene.add(this.player);
            }

            createTanks() {
                for (let i = 0; i < 10; i++) {
                    const tank = this.createTank();
                    this.tanks.push(tank);
                    this.scene.add(tank.group);
                }
            }

            createTank() {
                const tankGroup = new THREE.Group();
                const position = new THREE.Vector3().randomDirection().multiplyScalar(gameConfig.planet.radius + 5);
                
                // Tank body
                const hullGeometry = new THREE.BoxGeometry(8, 3, 5);
                const hullMaterial = new THREE.MeshLambertMaterial({ color: 0x2d4a2d });
                const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                hull.position.y = 1.5;
                hull.castShadow = true;

                // Tank turret
                const turretGeometry = new THREE.BoxGeometry(4, 2, 4);
                const turretMaterial = new THREE.MeshLambertMaterial({ color: 0x1f331f });
                const turret = new THREE.Mesh(turretGeometry, turretMaterial);
                turret.position.y = 3.5;
                turret.castShadow = true;

                tankGroup.add(hull);
                tankGroup.add(turret);
                tankGroup.position.copy(position);

                return {
                    group: tankGroup,
                    position: position,
                    health: gameConfig.tanks.hp,
                    alive: true
                };
            }

            createCrosshair() {
                const crosshair = document.createElement('div');
                crosshair.id = 'crosshair';
                crosshair.style.cssText = `
                    position: fixed; top: 50%; left: 50%; width: 20px; height: 20px;
                    margin: -10px 0 0 -10px; border: 2px solid #ff0000; border-radius: 50%;
                    pointer-events: none; z-index: 1000; opacity: 0.8;
                `;
                document.body.appendChild(crosshair);
            }

            createGameHUD() {
                const hud = document.createElement('div');
                hud.id = 'game-hud';
                hud.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none; z-index: 1000; font-family: Arial, sans-serif;
                    color: white; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                `;

                hud.innerHTML = `
                    <div id="score" style="position: absolute; top: 20px; left: 20px; font-size: 24px;">Score: 0</div>
                    <div id="kills" style="position: absolute; top: 60px; left: 20px; font-size: 20px;">Kills: 0/15</div>
                    <div id="health" style="position: absolute; top: 20px; right: 20px; font-size: 24px;">Health: 100</div>
                    <div id="speed" style="position: absolute; bottom: 80px; left: 20px; font-size: 18px;">Speed: 0 km/h</div>
                    <div id="altitude" style="position: absolute; bottom: 50px; left: 20px; font-size: 18px;">Altitude: 0 m</div>
                `;

                document.body.appendChild(hud);
            }

            updatePlayer(deltaTime) {
                if (this.currentScene !== 'PLAY') return;

                // Update speed
                const targetSpeed = this.inputState.speed * gameConfig.player.maxSpeed;
                this.playerSpeed = THREE.MathUtils.lerp(this.playerSpeed, targetSpeed, deltaTime * 2);

                // Calculate movement
                const forward = new THREE.Vector3(1, 0, 0);
                const rotation = new THREE.Euler(this.inputState.pitch, this.inputState.yaw, 0);
                forward.applyEuler(rotation);

                this.playerVelocity.copy(forward).multiplyScalar(this.playerSpeed * deltaTime);
                this.playerPosition.add(this.playerVelocity);

                // Apply gravity
                const gravityDirection = this.playerPosition.clone().normalize().multiplyScalar(-1);
                const distanceFromSurface = this.playerPosition.length() - gameConfig.planet.radius;
                const gravityStrength = Math.max(0, 1 - distanceFromSurface / 1000) * 50;
                const gravity = gravityDirection.multiplyScalar(gravityStrength * deltaTime);
                this.playerVelocity.add(gravity);

                // Prevent underground
                const minDistance = gameConfig.planet.radius + 5;
                if (this.playerPosition.length() < minDistance) {
                    this.playerPosition.normalize().multiplyScalar(minDistance);
                    this.playerVelocity.set(0, 0, 0);
                }

                // Update player object
                this.player.position.copy(this.playerPosition);
                this.player.lookAt(this.playerPosition.clone().add(forward));

                // Apply drag
                this.playerVelocity.multiplyScalar(1 - gameConfig.player.drag * deltaTime);

                // Update camera
                this.updateCamera();

                // Handle shooting
                if (this.inputState.shoot) {
                    this.shoot();
                }
            }

            updateCamera() {
                const playerForward = new THREE.Vector3(1, 0, 0);
                playerForward.applyEuler(new THREE.Euler(this.inputState.pitch, this.inputState.yaw, 0));
                
                const cameraOffset = playerForward.clone().multiplyScalar(-100);
                cameraOffset.add(new THREE.Vector3(0, 30, 0));
                
                const targetPos = this.playerPosition.clone().add(cameraOffset);
                this.camera.position.lerp(targetPos, 0.1);
                this.camera.lookAt(this.playerPosition);
            }

            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime < 1000 / gameConfig.weapons.rate) return;
                this.lastShotTime = currentTime;

                // Create muzzle flash
                this.createMuzzleFlash();

                // Raycast
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                
                for (let i = 0; i < this.tanks.length; i++) {
                    const tank = this.tanks[i];
                    if (!tank.alive) continue;

                    const distance = this.camera.position.distanceTo(tank.position);
                    if (distance > 2000) continue;

                    const intersects = this.raycaster.intersectObject(tank.group, true);
                    if (intersects.length > 0) {
                        tank.health -= gameConfig.weapons.damage;
                        this.createHitEffect(tank.position);
                        
                        if (tank.health <= 0) {
                            tank.alive = false;
                            this.scene.remove(tank.group);
                            this.score += gameConfig.scoring.kill;
                            this.kills++;
                            
                            // Spawn new tank
                            const newTank = this.createTank();
                            this.tanks[i] = newTank;
                            this.scene.add(newTank.group);
                        }
                        break;
                    }
                }
            }

            createMuzzleFlash() {
                const flash = document.createElement('div');
                flash.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: radial-gradient(circle at 50% 50%, rgba(255, 255, 0, 0.3) 0%, transparent 30%);
                    pointer-events: none; z-index: 999;
                `;
                document.body.appendChild(flash);
                setTimeout(() => document.body.removeChild(flash), 50);
            }

            createHitEffect(position) {
                const particleCount = 10;
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 4, 4),
                        new THREE.MeshBasicMaterial({ color: 0xff4444 })
                    );
                    particle.position.copy(position);
                    particle.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5
                    ));
                    this.scene.add(particle);
                    
                    setTimeout(() => this.scene.remove(particle), 1000);
                }
            }

            updateHUD() {
                if (this.currentScene !== 'PLAY') return;

                const scoreEl = document.getElementById('score');
                const killsEl = document.getElementById('kills');
                const healthEl = document.getElementById('health');
                const speedEl = document.getElementById('speed');
                const altitudeEl = document.getElementById('altitude');

                if (scoreEl) scoreEl.textContent = `Score: ${this.score}`;
                if (killsEl) killsEl.textContent = `Kills: ${this.kills}/15`;
                if (healthEl) healthEl.textContent = `Health: ${Math.round(this.playerHealth)}`;
                if (speedEl) speedEl.textContent = `Speed: ${Math.round(this.playerSpeed)} km/h`;
                if (altitudeEl) altitudeEl.textContent = `Altitude: ${Math.round(this.playerPosition.length() - gameConfig.planet.radius)} m`;
            }

            gameLoop() {
                const deltaTime = this.clock.getDelta();

                if (this.currentScene === 'HOME' && this.aircraft) {
                    this.aircraft.rotation.y += deltaTime * 0.5;
                    this.aircraft.position.y = Math.sin(Date.now() * 0.001) * 2;
                } else if (this.currentScene === 'PLAY') {
                    this.updatePlayer(deltaTime);
                    this.updateHUD();
                }

                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game
        new Game();
    </script>
</body>
</html>
